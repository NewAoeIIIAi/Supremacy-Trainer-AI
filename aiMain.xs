
//==============================================================================
// Draugur AI, Version 7.01
// by Felix Hermansson (hoodncloak@hotmail.com)
// 20 April 2008
//
// Improved main AI file for AoE3 - The Asian Dynasties
//
// Based on the original aiMain file for AoE3 - The Asian Dynasties by Ensemble 
// Studios and Big Huge Games, as well the Draugur AI file 6.00 for AoE3 - The
// War Chiefs
//==============================================================================


//==============================================================================
//
// AI changes made by SkyTeam
// This uses Felix Hermansson's Drauger AI_(Version 7.01) as a base, but has 
// varied improvements
// Last Updated: 20140908
//
//==============================================================================
// TAD20141125 Changes introduced:
/* 
   - obsolete code removed 
   - wrong comments corrected   
*/
//==============================================================================
// Draugur AI Changes introduced:
// 
// Version 1:
//
// Global changes: 
// - obsolete code removed
// - wrong comments corrected
//
// age3Monitor():
// - enabling of new churchUpgradeMonitor rule added
// - enabling of new royalDecreeMonitor rule added
//
// age4Monitor():
// - townWatch rule removed
//
// buildingMonitor():
// - plantations removed (handled in rule updateGoldBreakdown)
// - church moved to Age 3, independent of mills or difficulty level
//
// buyCards():
// - buy loop changed to 5 attempts per call to provide more flexibility
// - rule re-worked to include mercenaries, advanced trading post, 
//   advanced arsenal and royal decree
//
// churchUpgradeMonitor():
// - new rule to handle basic church upgrades
//
// commHandler():
// - confirmation statement for ally training request added
// - maximum resources tributed limited to 500 per request
//
// crateMonitor():
// - number of gatherers to gather from crates limited 
//
// echoMessage():
// - new function to provide debug output using player chats
//
// envoyMonitor():
// - new rule to make sure Dutch use only envoys for scouting
//
// exploreMonitor():
// - landExplorePlan not staffed for Dutch (now handled in rule envoyMonitor)
//
// findEnemyBase():
// - function aborted also for Amazonia, not just for Caribbean standard map
//
// getBaseEnemyStrength():
// - blockhouses and trading posts added to calculation
//
// getBaseValue():
// - value for trading post changed
// - banks and factories added to calculation
//
// getPointAllyStrength():
// - blockhouses and trading posts added to calculation
//
// getPointEnemyStrength():
// - blockhouses and trading posts added to calculation
//
// getPointValue():
// - banks, factories and trading posts added to calculation
// - value for plantation corrected
//
// init():
// - variables gGoodFishMap and gNavyMap for random maps are based on the 
//   availability of a water spawn flag instead of the map name
// - buyCards rule can be disabled by the new control variable cvOkToBuildDeck
// - call for new rule envoyMonitor added
// - call for new rule nativeScoutMonitor added
//
// initGatherGoal():
// - initial gathering share for gold added for Dutch
//
// initPersonality():
// - general bias towards artillery added
// - biases towards natives and trade posts strengthened
// - general negative cavalry bias deleted
//
// initUnitPicker():
// - obsolete rules artilleryMonitor and nativeMonitor no longer enabled
//
// monitorFeeding():
// - maximum resources tributed limited to 500 per feeding loop
//
// nativeScoutMonitor():
// - new rule added to make sure native scouts are used for independent
//   scouting
//
// reInitGatherers():
// - rule disabled after first call to keep AI from constantly swapping
//   villagers
//
// royalDecreeMonitor():
// - new rule to handle unique church upgrades and troops for the different
//   civilizations
//
// scoreOpportunity():
// - minimum radius changed
// - value for unclaimed trading post changed
//
// shipGrantedHandler():
// - function re-worked to include mercenaries, advanced trading post, 
//   advanced arsenal and royal decree
// - aiEcho changed to provide name of chosen card
//                   
// townCenterComplete():
// - standard water transport unit to be maintained changed from caravel/galley 
//   to galleon/fluyt (AI uses both as available)
//
// townWatch():
// - rule removed (replaced by churchUpgradeMonitor)
//
// updateForecasts():
// - church moved to Age 3, independent of difficulty level
// - forecasted tech for Ottomans in Age 5 corrected
// - basic church upgrades added to forecasts for Ages 3 and 4
// - unique church upgrades and troops added to forecasts for Ages 3 and 4
// - mercenaries added to forecasts for Ages 3, 4 and 5
// - additional banks added to forecast for Dutch (granted by 'Coffee Trade'
//   tech)
//
// updateGatherers():
// - gather percentage for gold adjusted according to gathering rates
//
// updateGoldBreakdown():
// - number of plantations now depends on number of gold gatherers instead of
//   number of gold gathering plans
//==============================================================================
// Version 2:
//
// age2Monitor():
// - enabling of new stageCoachMonitor rule added
//
// age3Monitor():
// - build plan for additional Ottoman town center added
//
// age4Monitor():
// - enabling of new ironHorseMonitor rule added
// 
// buildingMonitor():
// - market moved to Age 2, and enabled for Ottoman and Dutch
// - pen to be built only for at least six herdables
//
// buyCards():
// - priorities for '2 Covered Wagons' and '4 Outposts' set to 0 to keep
//   these cards from being included in a deck
//
// churchUpgradeMonitor():
// - corrected a problem which could lead to research plan being created
//   multiple times
//
// crateMonitor():
// - number of gatherers to gather from crates limited (not correct in
//   version 1)
//
// createSimpleAttackGoal():
// - added Amazonia map to so-called special handling for island maps
//
// createSimpleBuildPlan():
// - included explorer as builder unit for town centers
//
// defendBase():
// - new rule to keep a defensive force around the main base even if there is 
//   a forward base
//
// envoyMonitor():
// - enabled envoy exploration for civilizations other than Dutch
// - corrected a problem which led to explore plan being constantly recreated
//
// exploreMonitor():
// - rule changed so nugget gathering is not stopped as long as there are 
//   nuggets left close to the main base
//
// findEnemyBase():
// - function changed so explorer is not drafted for this task
//
// herdableMonitor():
// - new rule to actively capture herdables
//
// init():
// - standard random maps viable for fishing updated according to patch 1.05
// - call for new rule rescueExplorer added
//
// initArrays():
// - standard random map array updated according to patch 1.05
//
// ironHorseMonitor():
// - new rule to handle iron horse upgrade
//
// livestockMonitor():
// - new rule to gather herdables at livestock pen if available
//
// nativeScoutMonitor():
// - check for cvOkToExplore added (missing in version 1)
// - corrected a problem which led to explore plan being constantly recreated
//
// navyManager():
// - removed obsolete check for water spawn flag
//
// ottomanMonitor():
// - techs 'Galata Tower District', 'Topkapi' and 'Tanzimat' will only be 
//   researched if number of settlers is getting close to ~75% of maximum
// - disabled rule once all six techs have been researched
//
// rescueExplorer():
// - new rule added to rescue fallen explorer
//
// royalDecreeMonitor():
// - corrected a problem which led to explore plan being constantly recreated
//
// setUnitPickerPreference():
// - tertiary army unit line now properly supported
// - in-game bias towards appropriate counter units added
//
// shipGrantedHandler():
// - target number of town centers now independent of rush/boom bias
// 
// slaughterMonitor():
// - new rule to force food gathering from herdables
//
// stageCoachMonitor():
// - new rule to handle stage coach upgrade
//
// tcMonitor():
// - rule enabled and changed so explorers can build town centers
// 
// updateForecasts():
// - mercenary forecasts for Age 3 corrected (bug in version 1)
// - market moved to Age 2
// - added town center to forecast for Ages 3 and higher
//
// updateGatherers():
// - factories included in calculation
//
// useLevy():
// - corrected enemy calculation
//==============================================================================
// Version 3:
//
// Global changes: 
// - changes in original aiMain.xs file from patch 1.07 included
//
// age3Monitor():
// - enabling of new navyUpgradeMonitor rule added
// 
// buildingMonitor():
// - removed call for now superfluous herdMonitor rule
//
// buyCards():
// - priority for 'Conestoga Wagons' set to 0 to keep this card from being 
//   included in a German deck (leaving room for second factory)
// - 600 resources cards will be ignored in deck construction (700 resources
//   are included instead)
//
// createSimpleBuildPlan():
// - added settler wagons as builders if no settlers or coureurs are available
//
// exploreMonitor():
// - removed extended nugget gathering introduced in version 2
// - call for new rule localNuggetGathering added
// - added unconditional stop for "normal" nugget gathering after 5 min in Age 2
// - changed civilization-specific unit assignment for Dutch (introduced in 
//   version 2) to keep units from becoming stuck in the explore plan
//
// herdMonitor():
// - rule removed (replaced by livestockMonitor in version 2)
//
// init():
// - enabled explorer to build TC for games with boat start
//
// localNuggetGathering():
// - new rule added to slowly gather nuggets within the AI's own base over time
//
// navyManager():
// - increased number of warships to be maintained
//
// navyUpgradeMonitor():
// - new rule added to handle upgrades for warships
//
// ottomanMonitor():
// - 'Tanzimat' tech removed (will no longer be researched)
//
// ransomExplorer():
// - new rule added to ransom fallen explorer
//
// rescueExplorer():
// - reduced priority of rescue plan
//
// selectForwardBaseLocation():
// - changed to position fort somewhat randomly, but closer to own base
//
// transportArriveFailsafe():
// - reduced timeout from 60 to 30 seconds
//
// updateForecasts():
// - mercenary forecasts for Age 3 changed according to patch 1.06
// - frigates and navy techs added to forecasts for Ages 3, 4 and 5
// - 'Tanzimat' tech removed from forecast for Ottomans
//==============================================================================
// Version 3.08:
//
// buyCards():
// - priority for 'Fort Vauban' set to 0 to keep this card from being 
//   included in a French deck (second fort not handled properly)
//==============================================================================
// Version 3.09:
//
// buildingMonitor():
// - artillery foundry moved to Age 3
// - market moved to Age 2 for Dutch (just like for everyone else)
//
// buyCards():
// - 'Advanced Arsenal' removed from list of "best cards"
// - priority for 'Team Bastions' set to 0 to keep this card from being 
//   included in an Ottoman deck
//
// navyManager():
// - decreased minimum number of warships to be maintained
//
// shipGrantedHandler():
// - special treatment for 'Advanced Arsenal' removed
//
// townCenterComplete():
// - standard water transport unit to be maintained changed back to 
//   caravel/galley (change from version 1 removed)
//==============================================================================
// Version 4:
//
// Global changes: 
// - changes in original aiMain.xs file from TWC expansion included
//
// age2Monitor():
// - enabling of new healerMonitor rule added
// 
// bigTechManager():
// - all "parties" removed, to be used as levy
// - Iroquois techs which deliver crates assigned to economy escrow
// - minimal interval time for rule reduced from 300 to 120 seconds
// - tech 'Tezcatlipoca' added for Aztecs
// - techs 'Rawhide Covers', 'Siege Drill' and 'Horse Secrets' added for 
//   Iroquois
// - techs 'Bonepipe Armor', 'War Drums' and 'Flaming Arrows' added for 
//   Sioux
//
// buildingMonitor():
// - capitol and church build plans removed for natives
// - fire pit moved to Age 2
//
// buyCards():
// - priority for 'Castrametation' set to 0 to keep this card from being 
//   included (second fort not handled properly)
//
// churchUpgradeMonitor():
// - rule disabled for native civilizations
//
// createSimpleBuildPlan():
// - included war chiefs as builder units for town centers
//
// danceMonitor():
// - target number of dancers increased from 1/15 to 1/5 of settler count
// - war chief dance used only when war chief is down
// - warrior priests added as dancers
//
// exploreMonitor():
// - proper handling for war chiefs added
// - logical type 'scout' replaced by 'validSharpshoot' to exclude explorer 
//   and war chiefs
//
// getBaseEnemyStrength():
// - war huts and nobles huts added to calculation
//
// getPointAllyStrength():
// - war huts and nobles huts added to calculation
//
// getPointEnemyStrength():
// - war huts and nobles huts added to calculation
//
// healerMonitor():
// - new rule added to handle healers
//
// init():
// - natives aim for 10% more settlers, as more are used at the fire pit
// - war chiefs added as possibility for temporary main base position
// - war chiefs added as builders for boat start
//
// initEcon():
// - xpTlalocCanoe defined as gGalleonUnit for Aztecs
//
// initPersonality():
// - bias towards artillery added for Iroquois
// - biases towards natives and trade posts strengthened for natives
// - random rush/boom and offense/defense biases for Aztecs coupled
//
// livestockMonitor():
// - proper behavior for natives added (farm instead of pen)
//
// localNuggetGathering():
// - proper handling for war chiefs added
//
// navyManager():
// - number of native warships increased
// - tlaloc canoes added for Aztecs in Age 4 and 5
//
// navyUpgradeMonitor():
// - rule disabled for native civilizations
//
// nuggetHandler():
// - war chiefs added as possible location designators
//
// ransomExplorer():
// - rule disabled for native civilizations
//
// rescueExplorer():
// - rule disabled for native civilizations
// - logical type 'scout' replaced by 'validSharpshoot' to exclude explorer 
//   and war chiefs
//
// royalDecreeMonitor():
// - rule disabled for native civilizations
//
// setUnitPickerPreference():
// - changed definition for light infantry to cope with changes in abstract
//   type introduced with TWC
//
// useWarParties():
// - new rule added to use war parties as levy replacement for natives
//
// updateForecasts():
// - church and church techs excluded for natives
// - fire pit added for natives
// - houses removed for Sioux
// - ships and navy techs excluded for natives as appropriate
//==============================================================================
// Version 5:
//
// age3Monitor():
// - enabling of new minorTribeTechMonitor rule added
//
// age4Monitor():
// - enabling of new balloonMonitor rule added
//
// aztecWarhutUpgradeMonitor():
// - new rule added to upgrade Aztec war huts as well, and not just noble's huts
//
// balloonMonitor():
// - new rule added to use advanced balloons for scouting
//
// buyCards():
// - 'Advanced Balloon' added to list of "best cards"
// - deck construction logic reworked to prefer more valuable shipments for 
//   units and resource crates
// - native allies and renegades explicitly included in native decks 
// - obsolete loop for "best cards" in deck construction removed
// - priority for 600 resource cards set back to normal as construction logic
//   now properly prefers 700 over 600 resources
// - priority for Aztec higher infinite crate cards and all pet animal cards 
//   set to 0 to keep them from being included
// - priority for crossbowmen, longbowmen, pikemen and strelets cards for
//   Ages 3 and 4 set to 0 to keep them from being included
// - priority for German 1 Falconet card set to 0 to keep it from being included
//   on higher HC levels
// - priority for mortar, petard and ram cards for set to 0 to keep them 
//   from being included
// - priority for Russian balloon cards set to 0, as a bug in the game code
//   keeps 'Advanced Balloon' from being included
// - priority for Spy cards set to 0 to keep them from being included
// - selection of mercenaries, renegades and native allies randomized
//
// createHerdPlan():
// - new rule added to properly capture herdables in 'nomad' start games
//
// danceMonitor():
// - dances to spawn skull knights and dog soldiers added for Age 4 and 5
// - fertility dance forbidden if at pop cap
// - maximum number of dancers limited to 25
// - obsolete code removed
// - travois dance limited to situations where new travoises make sense,
//   i.e. there are buildings to be erected
//
// exploreMonitor():
// - rule changed to use converted guardians or cheap infantry units as scouts 
//   whenever possible
// - rule re-worked to destroy and re-create explore plan when nugget gathering
//   is stopped
// - corrected plans for explorers and war chiefs to be assigned to (bug in 
//   version 4)
//
// findEnemyBase():
// - function changed so cheap infantry units are used whenever possible
//
// initEcon():
// - canoe defined as gCaravelUnit and war canoe as gGalleonUnit for natives
// - creating of herd plan deleted (replaced by new createHerdPlan rule)
// - replaced constant 'cCivAztecs' by 'cCivXPAztec' (bug in version 4)
//
// initPersonality():
// - randomized personalities added for non-SPC/campaign games
//
// ironHorseMonitor():
// - check added to limit number of time upgrade is researched, as a bug in the
//   game code allows research even at native trade posts, wasting resources
//
// localNuggetGathering():
// - plans for explorers and war chiefs to be assigned to corrected (bug in 
//   version 4)
//
// minorTribeTechMonitor():
// - new rule to handle techs for minor native tribes (unit upgrades excluded)
//
// navyManager():
// - numbers of native warships to be maintained changed
// - constant 'cCivAztecs' replaced by 'cCivXPAztec' (bug in version 4)
//
// navyUpgradeMonitor():
// - 'Ship's Howitzers' tech added
//
// rescueExplorer():
// - rule changed to use converted guardians or cheap infantry units as rescuers
//   whenever possible
//
// shipGrantedHandler():
// - special handling for 'Advanced Balloon' added
//
// stageCoachMonitor():
// - check added to limit number of time upgrade is researched, as a bug in the
//   game code allows research even at native trade posts, wasting resources
//
// turtleUp():
// - minor comment corrected
// - enabling of new aztecWarhutUpgradeMonitor rule added
//
// updateForecasts():
// - church techs for Age 4 corrected (bug in version 4)
// - costs for allies and support included for natives
// - forecasts for ships and navy techs changed
//
// xpBuilderMonitor():
// - bug corrected which kept houses from being built
// - logic changed to allow plantations and siege workshops to be built
//
// waterAttackDefend():
// - number of native warships used in an attack increased
// - special treatment for war canoes removed
//==============================================================================
// Version 6:
//
// Global changes: 
// - several "TODO" comments dating from the original aiMain file removed
//
// advancedArsenalUpgradeMonitor():
// - new rule added to force advanced arsenal upgrades if necessary
//
// age2Monitor():
// - enabling of new maintainCreeCoureurs rule added
// - enabling of new settlerUpgradeMonitor rule added
//
// age3Monitor():
// - enabling of new arsenalUpgradeMonitor rule added
// - enabling of new eliteUpgradeMonitor rule added
// - enabling of new veteranUpgradeMonitor rule added
// - enabling of new warriorSocietyUpgradeMonitor rule added
// - number of towers to be built increased upon reaching Age 3
//
// age4Monitor(): 
// - enabling of new advancedArsenalUpgradeMonitor rule added
// - enabling of new artilleryUpgradeMonitor rule added
// - enabling of new autoFeedRevolutionary rule added
// - enabling of new championUpgradeMonitor rule added
// - enabling of new guardUpgradeMonitor rule added
// - enabling of new minorNativeChampionUpgradeMonitor rule added
// - enabling of new newWayIroquoisMonitor and newWaySiouxMonitor rules added
// - enabling of new revolutionMonitor rule added
// - enabling of new royalGuardUpgradeMonitor rule added
// - enabling of new setRevolutionFlag rule added
// - number of towers to be built increased yet again upon reaching Age 4
//
// ageUpgradeMonitor():
// - new functions chooseEuropeanPolitician() and chooseNativeCouncilMember() 
//   called to select age-up politicians / council members
// - obsolete code removed
//
// arsenalUpgradeMonitor():
// - new rule added to force arsenal upgrades if necessary
//
// autoFeedRevolutionary():
// - new rule added to automatically feed resources to an AI ally who has
//   revolted
//
// artilleryUpgradeMonitor():
// - new rule added to force artillery upgrades if necessary
//
// aztecWarhutUpgradeMonitor():
// - minimal interval time for rule raised to 60 seconds
// - rule limited to Aztecs only (bug in version 5)
//
// buildingMonitor():
// - additional military production buildings added for Ages 4 and 5
//
// buyCards():
// - number of Age 2 economy cards to be included in a deck adjusted according 
//   to player personalities
// - priority of outpost wagon cards adjusted according to player personalities
// - special treatment for Huron and Cheyenne allies cards removed (bug in 
//   techtree file has been corrected with patch 1.03)
//
// championUpgradeMonitor():
// - new rule added to force champion unit upgrades if necessary
//
// checkRevolutionLastPush():
// - new function added to check feasibility of a revolution aimed at 
//   eliminating a weakened opponent
//
// checkRevolutionLastStand():
// - new function added to check feasibility of a revolution aimed at delaying
//   defeat
//
// checkRevolutionMegaLevy():
// - new function added to check feasibility of a revolution aimed at defending 
//   an overrun main base
//
// checkRevolutionMonopolyBreaker():
// - new function added to check feasibility of a revolution aimed at breaking a 
//   trade monopoly
//
// chooseEuropeanPolitician():
// - new function added to improve and somewhat randomize non-revolutionary 
//   age-up politician selection for European civilizations
//
// chooseNativeCouncilMember():
// - new function added to improve and somewhat randomize age-up council member
//   selection for native civilizations
//
// chooseRevolutionary():
// - new function added to select revolutionaries
//
// churchUpgradeMonitor():
// - all upgrades assigned to military instead of economy escrow
//
// commHandler():
// - tributing prohibited after a revolution
// - tributing prohibited in Age 1
//
// eliteUpgradeMonitor():
// - new rule added to force elite unit upgrades if necessary
//
// extraShipMonitor():
// - rule changed to call different handlers for pre- and post-revolutionary
//   shipments
//
// fillInWallGaps():
// - settler replaced by generic econ unit in build plan
//
// guardUpgradeMonitor():
// - new rule added to force guard unit upgrades if necessary
//
// getBaseValue():
// - native settlers, settler wagons, coureurs and Cree coureurs added to
//   calculation
//
// initArrays():
// - arrays added to use in age-up politician / council member selection
// - array of post-revolutionary shipments added
//
// initPersonality():
// - randomization of personalities for non-SPC/campaign games redefined
//
// maintainCreeCoureurs():
// - new rule added to build Cree coureurs whenever possible
//
// minorNativeChampionUpgradeMonitor():
// - new rule added to force minor native champion unit upgrades if necessary
//
// monitorFeeding():
// - feeding of eliminated players prohibited
// - feeding prohibited after a revolution
// - feeding prohibited in Age 1
//
// newWayIroquoisMonitor():
// - new rule added to force 'New Way' upgrades for Iroquois if necessary
//
// newWaySiouxMonitor():
// - new rule added to force 'New Way' upgrades for Sioux if necessary
//
// revolutionaryShipmentHandler():
// - new function added to handle revolutionary shipments
//
// royalGuardUpgradeMonitor():
// - new rule added to force royal guard unit upgrades if necessary
//
// settlerUpgradeMonitor():
// - new rule added to handle hitpoint and attack upgrades for settlers
//
// setUnitPickerPreference():
// - Aztec "cavalry" units added to in-game counter unit bias calculations
//
// shipGrantedHandler():
// - handling of post-revolution shipments forbidden (handled in new 
//   'revolutionaryShipmentHandler' function
// - special handling for 'Advanced Arsenal' and 'New Ways' added
// - special handling for German shipments added to cope with uhlans being
//   included in calculations
//
// shouldIResign():
// - conditions for resignation partly changed to cope with revolutions
//
// turtleUp():
// - minimum number of towers set to 0 (number could become negative)
//
// updateForecasts():
// - additional military buildings added
// - calculation for basic church techs corrected (bug in version 1)
// - costs for unit upgrades added in Ages 3 and above
// - obsolete code removed
//
// useFactoryWagons():
// - minimal interval time for rule reduced from 20 to 5 seconds
//
// veteranUpgradeMonitor():
// - new rule added to force veteran unit upgrades if necessary
//
// warriorSocietyUpgradeMonitor():
// - new rule added to force warrior society upgrades if necessary
//==============================================================================
// Version 7:
//
// Global changes: 
// - changes in original aiMain.xs file from TAD expansion included
// - global variable gFrigateUnit added to handle Japanese tekkousen
// - random map name "ceylon" replaced by "Ceylon" as defined in the array
// - various comments updated
//
// age2Monitor():
// - research plan for Chinese village upgrade removed; to be handled in
//   new villageUpgradeMonitor rule
//
// age3Monitor():
// - enabling of consulateMonitor rule added
// - enabling of monasteryMonitor rule added
// - enabling of new agraFortUpgradeMonitor rule added
// - enabling of new arsenalUpgradeAsianMonitor rule added
// - enabling of new churchUpgradeAsianMonitor rule added
// - enabling of new disciplinedUpgradeMonitor rule added
// - enabling of new minorAsianDisciplinedUpgradeMonitor rule added
// - enabling of new minorAsianTribeTechMonitor rule added
// - enabling of new summerPalaceTacticMonitor rule for Chinese added
// - number of Asian castles to be built increased upon reaching Age 3
// - research plan for Chinese village upgrade removed; to be handled in
//   new villageUpgradeMonitor rule
//
// age4Monitor():
// - basic probability for revolution to be considered raised from 20% to 40%
// - enabling of new dojoUpgradeMonitor rule for Japanese added
// - enabling of new factoryTacticMonitor rule added
// - enabling of new factoryUpgradeMonitor rule added
// - enabling of new fortUpgradeMonitor rule added
// - enabling of new goldenPavillionUpgradeMonitor rule for Japanese added
// - enabling of new honoredUpgradeMonitor rule added
// - enabling of new mansabdarMonitor rule added
// - enabling of new minorAsianHonoredUpgradeMonitor rule added
// - enabling of new sacredFieldMonitor rule for Indians added
// - enabling of new shrineUpgradeMonitor rule for Japanese added
// - number of Asian castles to be built increased upon reaching Age 4
//
// age5Monitor():
// - enabling of new brigadeMonitor rule added
//
// ageUpgradeMonitor():
// - new function chooseAsianWonder() called to select age-up wonder
//
// agraFortUpgradeMonitor():
// - new rule added to upgrade agra fort
//
// arsenalUpgradeAsianMonitor():
// - new rule added to handle upgrades at arsenals built from arsenal wagons
//
// advancedArsenalUpgradeMonitor():
// - check for arsenal added
// - necessary number of units to consider upgrade reduced for 'Pillage' tech
// - rule disabled for Asian civilizations
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// arsenalUpgradeMonitor():
// - check for arsenal added
// - necessary number of units to consider upgrade increased for 'Gunnery 
//   Quadrant' tech
// - new impacted units added to calculations for several techs
// - rule disabled for Asian civilizations
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// artilleryUpgradeMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - rule disabled for Asian civilizations
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// aztecWarhutUpgradeMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - rule disabled for anyone but Aztecs
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
// - upgrade plan priority reduced
//
// brigadeMonitor():
// - new rule added to handle brigade technologies at the consulate in Age 5
//
// buildingMonitor():
// - building of gLivestockPenUnit disabled for Chinese and Japanese
// - enabling of consulateMonitor rule removed
// - minimum number of herdables to build gLivestockPenUnit (sacred field)
// - more war huts added for Aztecs (for a total of 3 in Age 4, 5 in Age 5)
//
// buyCards():
// - rule reworked to properly handle Asian civilizations
// - construction logic to prefers 700 over 600 resources and coin over wood 
//   over food expanded to include German shipments
// - number of Age 3 cards increased from 4 to 5
// - number of economy-biased Age 1 cards reduced from 4 to 3
// - number of renegade cards to be included limited to 2
//
// championUpgradeMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - necessary number of units to consider upgrade reduced for several units
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// chooseAsianWonder():
// - new function added to improve and somewhat randomize age-up wonder
//   selection for Asian civilizations
//
// chooseConsulateFlag():
// - function completely reworked and selection biases changed
// - new consulateLevy rule enabled if Ottomans are chosen
//
// chooseEuropeanPolitician():
// - Ceylon added to list of water maps used to calculate politician bias
//
// chooseNativeCouncilMember():
// - check for unavailable council members included (bug in version 6)
//
// chooseRevolutionary():
// - Ceylon added to list of water maps used to calculate revolutionary bias
//
// churchUpgradeAsianMonitor():
// - new rule added to handle upgrades at churches built from church wagons
//
// churchUpgradeMonitor():
// - rule disabled for Asian civilizations
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// commHandler():
// - number of Asian castles to be built defined
//
// consulateLevy():
// - new rule added to use minutemen from consulate if available
//
// consulateMonitor():
// - export generation rate increased in Age 4 and above
// - minimal time interval for rule increased from 30 to 45 seconds
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created, and to avoid unnecessary upgrades
//
// createConsulateResearchPlan():
// - function removed (research handled directly in reworked consulateMonitor
//   rule)
//
// createSimpleBuildPlan():
// - bank wagon included as possible builder for Dutch banks
// - monks included as builders for town centers
//
// deathMatchSetup():
// - maximum number of Asian castles to be built defined
//
// disciplinedUpgradeMonitor():
// - new rule added to force disciplined unit upgrades if necessary
//
// dojoTacticMonitor():
// - new rule added to randomize unit generation at Japanese dojos 
//
// dojoUpgradeMonitor():
// - new rule added to handle dojo upgrade for Japanese
//
// eliteUpgradeMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - necessary number of units to consider upgrade reduced for cavalry units
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// exploreMonitor():
// - list of preferred scouts updated to include Asian units
// - proper handling for Asian monks added
//
// findEnemyBase():
// - list of preferred scouts updated to include Asian units
//
// factoryTacticMonitor():
// - new rule added to configure factory production
//
// factoryUpgradeMonitor():
// - new rule added to upgrade factories and heavy artillery
//
// fortUpgradeMonitor():
// - new rule added to upgrade forts
//
// getBaseValue():
// - Asian, Indian and Japanese settlers added to calculation
// - mills, farms and rice paddies added to calculation
//
// getBaseEnemyStrength():
// - agra fort, castles and Asian outposts added to calculation
//
// getPointAllyStrength():
// - agra fort, castles and Asian outposts added to calculation
//
// getPointEnemyStrength():
// - agra fort, castles and Asian outposts added to calculation
//
// getPointValue():
// - mills, farms and rice paddies added to calculation
//
// getSteamPower():
// - rule removed (replaced by factoryUpgradeMonitor)
//
// goldenPavillionTacticMonitor():
// - new rule added to have golden pavillion boost land unit hitpoints
//
// goldenPavillionUpgradeMonitor():
// - new rule added to handle upgrades at golden pavillion
//
// guardUpgradeMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - necessary number of units to consider upgrade reduced for several units
// - upgrades for units which only get royal guard upgrades removed
// - rule disabled for Asian civilizations
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// herdableMonitor():
// - Mongol scouts included to capture herdables
//
// honoredUpgradeMonitor():
// - new rule added to force honored unit upgrades if necessary
//
// init():
// - Asian monks included as builders for boat start
// - Asian monks included as possible location designators
// - call for new rule nativeScoutMonitor added
// - covered wagons (if available) added as builders for boat start
//
// initArrays():
// - arrays added to use in age-up wonder selection
//
// initEcon():
// - Japanese no longer forced to start farming immediately
// - shrine defined as gLivestockPenUnit for Japanese
// - tekkousen defined as gFrigateUnit for Japanese
//
// initPersonality():
// - biases towards natives and trade posts strengthened for Asians
// - default values for btRushBoom and btOffenseDefense changed for India
// - randomized Asian personalities added for non-SPC/campaign games
//
// ironHorseMonitor():
// - special handling for trade posts on Asian maps added
//
// livestockMonitor():
// - cUnitTypeLivestockPen replaced by gLivestockPenUnit to include sacred
//   fields, shrines and villages
//
// localNuggetGathering():
// - check added to make sure there is a TC
// - proper handling for Asian monks added
//
// mansabdarMonitor():
// - new rule added to maintain Indian mansabdar units where appropriate
//   (not for elephants)
//
// minorAsianDisciplinedUpgradeMonitor():
// - new rule added to force disciplined unit upgrades for minor Asian 
//   civilizations if necessary
//
// minorAsianHonoredUpgradeMonitor():
// - new rule added to force honored unit upgrades for minor Asian 
//   civilizations if necessary
//
// minorAsianTribeTechMonitor():
// - new rule to handle techs for minor Asian tribes (unit upgrades excluded)
//
// minorNativeChampionUpgradeMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - native ally versions of units included in calculations
// - necessary number of units to consider upgrade reduced
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
// 
// minorTribeTechMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
// - tech 'Ceremonial Feast' added
//
// monasteryMonitor():
// - check for monastery removed
// - minimal time interval for rule increased from 45 to 60 seconds
// - priority for monastery build plan reduced
// - rule removed from group tcComplete
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
// - unnecessary upgrades removed
//
// mongolScoutMonitor():
// - new rule added to make sure Mongol scouts are used for independent
//   scouting
//
// navyManager():
// - cUnitTypeFrigate replaced by gFrigateUnit to include Japanese tekkousen
// - civilization specific handling for Chinese added
//
// navyUpgradeMonitor():
// - cUnitTypeDock replaced by gDockUnit to include Asian version of the dock
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// newWayIroquoisMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - new impacted units added to calculations for 'Counter Infantry Rifling'
//   and 'Infantry Breastplate' techs
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// newWaySiouxMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - necessary number of units to consider upgrade reduced for 'Pillage' tech
// - new impacted units added to calculations for 'Counter Infantry Rifling'
//   and 'Infantry Breastplate' techs
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// nuggetHandler():
// - Asian monks included as possible location designators
//
// orchardMonitor():
// - minimal time interval for rule reduced from 45 to 5 seconds
//
// porcelainTowerTacticMonitor():
// - new rule added to cycle through porcelain tower resource generation
//   options on a regular basis
//
// ransomExplorer():
// - rule disabled for Asian civilizations
//
// rescueExplorer():
// - list of preferred rescuers updated to include Asian units
//
// royalDecreeMonitor():
// - rule disabled for Asian civilizations
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// royalGuardUpgradeMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - necessary number of units to consider upgrade reduced for several units
// - rule disabled for Asian civilizations
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// sacredFieldMonitor():
// - new rule added to control sacred field upgrade and production of sacred
//   cows
//
// settlerUpgradeMonitor():
// - Asian-specific settler upgrade added
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// setConsulateArmyPreference():
// - preference for dutch expedition army (includes mortars) set to 0.0
//
// setUnitPickerPreference():
// - mercenaries from the monastery allowed for Asian civilizations
// - mercenaries from the monastery excluded for native and European
//   civilizations
// - preference for mansabdar gurkha set to 0.0 (replacing mansabdar urumi)
// - preference for rams, petards and mortars set to 0.0
// - special handling for iron troops, yojimbos and flail elephants removed
//
// shipGrantedHandler():
// - calculation for value of tower shipments corrected
// - individual handling for different settler types added to keep free Indian
//   settlers from messing up calculations
// - special handling for missionaries and surgeons removed
// - special handling for new Asian-specific cards included
// - value of all warship shipments (instead of just some of them) reduced to 0
//
// shrineMonitor():
// - rule reworked to cycle through resource generation options in Age 3 and
//   above
//
// shrineUpgradeMonitor():
// - new rule to handle shrine upgrade for Japanese
//
// slaughterMonitor():
// - rule disabled for Indians and Japanese
//
// summerPalaceTacticMonitor():
// - new rule added to have summer palace randomly spawn either territorial,
//   forbidden or imperial armies in Age 3 and above
//
// stageCoachMonitor():
// - special handling for trade posts on Asian maps added
//
// tcMonitor():
// - monks included as builders for town centers
//
// towerManager():
// - check added to destroy tower upgrade plans which are no longer valid
// - order of blockhouse upgrades corrected
//
// townCenterComplete():
// - enabling of consulateMonitor rule removed
// - Japanese no longer forced to start farming immediately
//
// turtleUp():
// - number of Asian castles to be built defined
//
// updateForecasts():
// - agra fort upgrades added for Indians
// - consulate added for Asians
// - cUnitTypeFrigate replaced by gFrigateUnit to include Japanese tekkousen
// - dojo upgrade added for Japanese
// - factory upgrades added
// - fort upgrades added
// - gFrigateUnit excluded for Chinese
// - independent calculation for Asian rice paddies added
// - monastery added for Asians
// - more war huts added for Aztecs (for a total of 3 in Age 4, 5 in Age 5)
// - native allies included for Asians
// - sacred field upgrade added for Indians
// - saloon added for Europeans
// - shrine upgrade added for Japanese
// - tower upgrades (including blockhouse, war hut, nobles hut and castle)
//   added
// - unit upgrades included for Asians
//
// updateGatherers():
// - first factory (producing artillery) removed from calculation
//
// useFactoryWagons():
// - enabling of getSteamPower rule removed
//
// useLevy():
// - rule disabled for native and Asian civilizations
//
// veteranUpgradeMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - necessary number of units to consider upgrade reduced for several units
// - rule disabled for Asian civilizations
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//
// villageUpgradeMonitor():
// - new rule added to handle Chinese village upgrades independent of
//   age advancement
//
// wagonMonitor():
// - new rule added to use Chinese village wagons, Indian grove wagons and
//   wagons from Russian and Dutch consulate
//
// warriorSocietyUpgradeMonitor():
// - minimal time interval for rule increased from 60 to 90 seconds
// - native ally versions of units included in calculations
// - necessary number of units to consider upgrade reduced
// - rule reworked to have plans which are no longer valid destroyed and 
//   re-created
//==============================================================================
// Version 7.01:
//
// age4Monitor():
// - basic probability for revolution to be considered reduced from 40% to 17%
//
// checkRevolutionLastPush():
// - function removed as it has become obsolete
//
// chooseAsianWonder():
// - wonder selection biases for Chinese adjusted to changes in patch 1.01
//
// chooseNativeCouncilMember():
// - council member selection biases for Aztecs adjusted to changes in 
//   patch 1.01
//
// revolutionMonitor():
// - rule reworked to no longer allow a revolution aimed at eliminating a 
//   weakened opponent 
//
// wagonMonitor():
// - rule updated to include farm travois, war hut travois and nobles hut 
//   travois provided by Aztec wise woman and shaman
//==============================================================================
// Known problems:
//
// buyCards():
// - British will try to add 'Holy Roman Army', which is not available, to their 
//   deck (most probably a bug in aiHCDeckAddCardToDeck)
// - Japanese will never add '2 Team Castle Wagons' to the deck (most probably a 
//   bug in aiHCDeckAddCardToDeck)
// - Indians will never add 'Foreign Logging' to the deck (most probably a 
//   bug in aiHCDeckAddCardToDeck)
// - Russians will never add 'Advanced Balloon' to the deck (most probably a 
//   bug in aiHCDeckAddCardToDeck)
//
// ironHorseMonitor():
// - upgrade is never researched (problem in the game code itself?)
//
// ransomExplorer():
// - explorer is ransomed only sporadically (problem in the game code itself?)
//
// useLevy():
// - levy is never researched (problem in the game code itself?)
//==============================================================================




//==============================================================================
// Constants
//==============================================================================

// Temporary constants, to be deleted if implemented in C++

extern const int cNumResourceTypes = 3;  // Gold, food, wood.
extern const float   baselineHandicap = 1.0;    // This is the handicap given to cDifficultyHard.  Our intent is to ship with this at 1.0,
                                                // meaning that hard has no handicap advantage or penalty.
                                                // All other difficulty levels will be adjusted relative to this constant.  This means that
                                                // we can gradually reduce this number as the AI's competence increases, and all the difficulty levels will respond.
extern int           gMaxPop = 250;             // Absolute hard limit pop cap for game...will be set lower on some difficulty levels 
extern const int   cMaxSettlersPerPlantation = 10;

// Start mode constants.
extern const int     cStartModeScenarioNoTC = 0;   // Scenario, wait for aiStart unit, then play without a TC
extern const int     cStartModeScenarioTC = 1;     // Scenario, wait for aiStart unit, then play with starting TC
extern const int     cStartModeScenarioWagon = 2;  // Scenario, wait for aiStart unit, then start TC build plan.
extern const int     cStartModeBoat = 3;           // RM or GC game, with a caravel start.  Wait to unload, then start TC build plan.
extern const int     cStartModeLandTC = 4;         // RM or GC game, starting with a TC...just go.
extern const int     cStartModeLandWagon = 5;      // RM or GC game, starting with a wagon.  Explore, start TC build plan.



//==============================================================================
// Econ variables
//==============================================================================
extern int  gGatherGoal = -1;       // Stores all top-level gatherer data
extern int  gFarmBaseID = -1;       // Current operating bases for each resource
extern int  gFoodBaseID = -1;
extern int  gGoldBaseID = -1;
extern int  gWoodBaseID = -1;
extern int  gNextFarmBaseID = -1;   // Overflow operating bases for each resource
extern int  gNextFoodBaseID = -1;
extern int  gNextGoldBaseID = -1;
extern int  gNextWoodBaseID = -1;
extern int  gPrevFarmBaseID = -1;   // Phasing-out bases for each resource
extern int  gPrevFoodBaseID = -1;
extern int  gPrevGoldBaseID = -1;
extern int  gPrevWoodBaseID = -1;
//extern float gMaximumBaseResourceDistance = 150.0;

extern int  gDefaultDeck = -1;   // Home city deck used by each AI
extern bool gEarlyEconPhase = true; // Used to indicate that we're in a special startup econ phase, i.e. almost all food for most civs.
                                    // This is turned off when we decide it's time to go military, i.e when we build a barracks or get attacked
                                    // or reach age 2.
                                    
extern bool gTimeToFarm = false;    // Set true when we start to run out of cheap early food.
extern bool gTimeForPlantations = false;  // Set true when we start to run out of mine-able gold.
extern bool gStopToLogging = false;   // Set true when we no wood at main.

extern float gTSFactorDistance = -200.0;  // negative is good
extern float gTSFactorPoint = 10.0;			// positive is good
extern float gTSFactorTimeToDone = 0.0;	// positive is good
extern float gTSFactorBase = 100.0;			// positive is good
extern float gTSFactorDanger = -10.0;		// negative is good

extern int  gEconUnit = cUnitTypeSettler; // Set appropriately for the different civilizations later.
extern int  gHouseUnit = cUnitTypeHouse;  // Housing unit, different per civ.
extern int  gTowerUnit = cUnitTypeOutpost;   // Tower unit, blockhouse for Russians, huts and teepees for natives, castle for Asians.
extern int  gTowerWagonUnit = cUnitTypeOutpostWagon;
extern int  gFarmUnit = cUnitTypeMill;    // Will be farm for natives and rice paddy for Asians.
extern int  gPlantationUnit = cUnitTypePlantation;    // Will be farm for natives and rice paddy for Asians.
extern int  gLivestockPenUnit = cUnitTypeLivestockPen;    // The Asians all have different ones.
extern int  gCoveredWagonUnit = cUnitTypeCoveredWagon;    // Allow for a different type (currently none).
extern int  gMarketUnit = cUnitTypeMarket;    // The Asians have a different type.
extern int  gDockUnit = cUnitTypeDock;    // The Asians have a different type.

extern bool gFlagChosen = false;  // need to make sure they only build one

extern int  gLastTribSentTime = 0;

extern int  gEconUpgradePlan = -1;

extern bool gGoldEmergency = false;  // Set this true if we need a gold mine, and don't have enough wood.  Overrides econ to 100% wood.

extern int  gVPEscrowID = -1;       // Used to reserve resources for accelerator building.
extern int  gUpgradeEscrowID = -1;  // Used to reserve ships for age upgrades
// extern int  gHouseEscrowID = -1;    // Used to buy houses/manors only, off econ account.
extern int  gTowerEscrowID = -1;

extern int GTowerBuildPlanID = -1;
extern int gTCBuildPlanID = -1; 

extern int gStartMode = -1;    // See start mode constants, above.  This variable is set 
                        // in main() and is used to decide which cascades of rules
                        // should be used to start the AI.
                        
extern bool gGoodFishingMap = false;    // Set in init(), can be overridden in postInit() if desired.  True indicates that fishing is a good idea on this map.
extern int  gFishingPlan = -1;      // Plan ID for main fishing plan.
extern int gFishingBoatMaintainPlan = -1; // Fishing boats to maintain
extern int gFishingUnit = cUnitTypeFishingBoat; // Fishing Boat
extern int gNumFishBoats = 0;    // Set in the rule startFishing, higher for boomers.

extern int  gHerdPlanID = -1;
                        
extern int gSettlerMaintainPlan = -1;   // Main plan to control settler population

extern int gTransportUnit = cUnitTypeAbstractWarShip;  // hard coded ship type for now
extern int  gWaterTransportUnitMaintainPlan = -1;  // The plan that maintains all the ships
extern int  gWaterExplorePlan = -1;    // Plan ID for ocean exploration plan
extern bool gWaterMap = false;               // True when we are on a water map
extern int  gNavyDefendPlan = -1;
extern int  gNavyAttackPlan = -1;

extern vector gTCSearchVector = cInvalidVector;  // Used to define the center of the TC building placement search.
extern int   gTCStartTime = 10000;                   // Used to define when the TC build plan can go active.  In ms.

extern int  gAgeUpResearchPlan = -1;      // Plan used to send politician from HC, used to detect if an age upgrade is in progress.

extern int  gAgeUpTime = 0;            // Time we entered this age

extern int gNuggetMessagePercentage = 100;
extern int gFeedGoldTo = -1;     // If set, this indicates which player we need to be supplying with regular gold shipments.
extern int gFeedWoodTo = -1;     // See commsHandler and monitorFeeding rule.
extern int gFeedFoodTo = -1;

extern const int  cForwardBaseStateNone = -1;      // None exists, none in progress
extern const int  cForwardBaseStateBuilding = 0;   // Fort wagon exists, but no fort yet.
extern const int  cForwardBaseStateActive = 1;     // Base is active, defend and train plans there.
extern int gForwardBaseState = cForwardBaseStateNone;
extern int gForwardBaseID = -1;                    // Set when state goes to Active
//extern int gForwBaseID = -1;
extern vector gForwardBaseLocation = cInvalidVector;  // Set when state goes to 'building' or earlier.
extern int gForwardBaseBuildPlan = -1;
extern vector gTowerBuildPlace = cInvalidVector;  // Set when state goes to 'building' or earlier.
extern int  gNativeDancePlan = -1;


//==============================================================================
// Military variables
//==============================================================================
extern int  gLandDefendPlan0 = -1;   // Primary land defend plan
extern int  gLandReservePlan = -1;     // Reserve defend plan, gathers units for use in the next military mission
extern int  gWaterDefendPlan0 = -1;    // Primary water defend plan

extern bool gDefenseReflex = false;    // Set true when a defense reflex is overriding normal ops.
extern bool gDefenseReflexPaused = false; // Set true when we're in a defense reflex, but overwhelmed, so we're hiding to rebuild an army.
extern int  gDefenseReflexBaseID = -1; // Set to the base ID that we're defending in this emergency
extern vector  gDefenseReflexLocation = cInvalidVector;  // Location we're defending in this emergency
extern int  gDefenseReflexStartTime = 0;

extern int  gLandUnitPicker = -1;      // Picks the best land military units to train.
extern int  gMainAttackGoal = -1;      // Attack goal monitors opportunities, launches missions.
extern int  gLandMilUnitUpgradePlan = -1;    // The plan ID of the most recent unit upgrade plan
extern int  gArtilleryMaintainPlan = -1;     // Manual plan to force building of some siege.

extern int  gCaravelMaintain = -1;     // Maintain plans for naval units.
extern int  gGalleonMaintain = -1;
extern int  gFrigateMaintain = -1;
extern int  gMonitorMaintain = -1;
extern int  gCanoeMaintain = -1;
extern int  gWaterExploreMaintain = -1;

extern int  gCaravelUnit = cUnitTypeCaravel; // Will be Galley for Ottomans, Canoe for natives, War Junk for Chinese, Fune for Japanese
extern int  gGalleonUnit = cUnitTypeGalleon; // Will be Fluyt for Dutch, War Canoe for natives, Fuchuan for Chinese, Atakabune for Japanese
extern int  gFrigateUnit = cUnitTypeFrigate; // Will be Tekkousen for Japanese

extern bool gNavyMap = false;    // Setting this false prevents navies
extern const int cNavyModeOff = 0;
//extern const int cNavyModeExplore = 1;
extern const int cNavyModeActive = 2;
extern int  gNavyMode = cNavyModeOff; // Tells us whether we're making no navy, just an exploring ship, or a full navy.
extern vector gNavyVec = cInvalidVector;  // The center of the navy's operations.


extern int  gPrimaryArmyUnit = -1;     // Main land unit type
extern int  gSecondaryArmyUnit = -1;    // Secondary land unit type
extern int  gTertiaryArmyUnit = -1;    // Tertiary land unit type
extern int  gNumArmyUnitTypes = 3;    // How many land unit types do we want to train?

extern int  gLandPrimaryArmyUnit = -1;     // Main land unit type
extern int  gLandSecondaryArmyUnit = -1;    // Secondary land unit type
extern int  gLandTertiaryArmyUnit = -1;    // Tertiary land unit type
extern int  gAbstractArtilleryUnit = cUnitTypeFalconet;

extern int  gPrimaryNavyUnit = -1;     // Main water unit type
extern int  gSecondaryNavyUnit = -1;    // Secondary water unit type
extern int  gTertiaryNavyUnit = -1;    // Tertiary water unit type
extern int  gNumNavyUnitTypes = -1;    // How many water unit types do we want to train?

extern int  gGoodArmyPop = -1;         // This number is updated by the pop manager, to give a ballpark feel for the pop count needed to create a credible
                                       // attack army.  It is based on military pop allowed and game time, and is very sensitive to difficulty level.  
                                       // This is used by the strategyMaster rule to help decide when certain mission types make sense.  For example, if 
                                       // your available military pop is only 1/2 of gGoodArmyPop, a base attack would be foolish, but villager raiding or
                                       // claiming a VP site might be good choices.  


extern int  gUnitPickSource = cOpportunitySourceAutoGenerated;  // Indicates who decides which units are being trained...self, trigger, or ally player.
extern int  gUnitPickPlayerID = -1;                // If the source is cOpportunitySourceAllyRequest, this will hold the player ID.


extern int  gMostRecentAllyOpportunityID = -1;  // Which opportunity (if any) was created by an ally?  (Only one at a time allowed.)
extern int  gMostRecentTriggerOpportunityID = -1;  // Which opportunity (if any) was created by a trigger?  (Only one at a time allowed.)

extern int  gLastClaimMissionTime = -1;
extern int  gLastAttackMissionTime = -1;
extern int  gLastDefendMissionTime = -1;
extern int  gClaimMissionInterval = 60000;  // 1 minutes.  This variable indicates how long it takes for claim opportunities to score their maximum.  Typically, a new one will launch before this time.
extern int  gAttackMissionInterval = 60000; // 1 minutes.  Suppresses attack scores (linearly) for 1 minutes after one launches.  Attacks will usually happen before this period is over.
extern int  gDefendMissionInterval = 120000;  // 2 minutes.   Makes the AI less likely to do another defend right after doing one.
extern bool gDelayAttacks = false;     // Can be used on low difficulty levels to prevent attacks before the AI is attacked.  (AI is defend-only until this variable is
                                       // set false.
extern int gInitialStrategy = -1;
extern int gBarracksUnit = cUnitTypeBarracks;
extern int gStableUnit = cUnitTypeStable;
extern int gArtilleryDepotUnit = cUnitTypeArtilleryDepot;
extern int gSiegeWeaponUnit = cUnitTypeMortar;
extern int gExplorerUnit = cUnitTypeExplorer;
extern int gBaseAttackPlan = -1;
extern vector gBaseAttackLocation = cInvalidVector;
extern bool gJapaneseIsAlly = false;  //this globle varible is used to determine when for AI players to cease hunting if Japanese is in ally's team, for AI's villagers always try to hunt animals at a shrine. 
extern bool gJapaneseIsEnemy = false;
extern bool gIndianIsAlly = false;
extern vector gHousePosition = cInvalidVector;

//==============================================================================
// Other global variables
//==============================================================================
extern bool gSPC = false;           // Set true in main if this is an spc or campaign game
extern int  gExplorerControlPlan = -1; // Defend plan set up to control the explorer's location
extern int  gLandExplorePlan = -1;  // Primary land exploration
extern int  gMainBase = -1;
extern int  gcVPTypeAny = 0;
extern int  gcVPTypeNative = cVPNative;
extern int  gcVPTypeSecret = cVPSecret;
extern int  gcVPTypeTrade = cVPTrade;
extern float gInitRushBoom = 0.0;
extern float gInitOffenseDefense = 0.0;
extern float gInitBiasCav = 0.0;
extern float gInitBiasInf = 0.0;
extern float gInitBiasArt = 0.0;
extern float gInitBiasNative = 0.0;
extern float gInitBiasTrade = 0.0;
extern bool gIAmCaptain = false;
extern int  gCaptainPlayerNumber = -1;
extern int  gResignType = -1;       // Reason for AI requesting permission to resign
extern bool gBuildWalls = false;    // Global indicating if we're walling up or not.
extern int  gNumTowers = 0;         // How many towers do we want to build?
extern int  gPrevNumTowers = 0;     // Set when a command is received, to allow resetting when a cancel is received.
extern bool gIsMonopolyRunning = false; // Set true while a monopoly countdown is in effect.
extern int  gMonopolyTeam = -1;         // TeamID of team that will win if the monopoly timer completes.
extern int  gMonopolyEndTime = -1;      // Gametime when current monopoly should end
extern bool gIsKOTHRunning = false; // Set true while a KOTH countdown is in effect.
extern int  gKOTHTeam = -1;         // TeamID of team that will win if the KOTH timer completes.
extern bool gRevolutionFlag = false;    // Set true after a successful revolt


//==============================================================================
// Function forward declarations.
//
// Used in loader file to override default values, called at start of main()
mutable void preInit(void) {}

// Used in loader file to override initialization decisions, called at end of main()
mutable void postInit(void) {}
mutable void econMaster(int mode=-1, int value=-1) {}
mutable void shipGrantedHandler(int parm=-1) {}
mutable int initUnitPicker(string name="BUG", int numberTypes=1, int minUnits=10,int maxUnits=20, int minPop=-1, int maxPop=-1, int numberBuildings=1, bool guessEnemyUnitType=false) {return(-1);}
mutable void updateForecasts(void) {}
mutable void setUnitPickerPreference(int upID=-1) {}
mutable void endDefenseReflex(void) {}

   
//==============================================================================
// Global Arrays
//==============================================================================
// Forecast float array initialized below.
extern int  gForecasts = -1;

// Forecasted demand over the next few minutes
//extern float gGoldForecast = 0.0;			
//extern float gWoodForecast = 0.0;
//extern float gFoodForecast = 0.0;

// Percentage of gatherers assigned.  Array.
extern int  gTargetGathererPercents = -1;

extern int  gMapNames = -1;   // An array of random map names, so we can store ID numbers in player histories

extern int  gTargetSettlerCounts = -1; // How many settlers do we want per age?

extern int  gConsulateTechs = -1; //List of all the consulate techs
extern int  gConsulateTechsSize = -1; //Size of the list of all the consulate techs

extern int  gAsianWonders = -1; //List of wonders for the Asian civs

extern int  gAge2PoliticianList = -1; // List of Age 2 European politicians
extern int  gAge3PoliticianList = -1; // List of Age 3 European politicians
extern int  gAge4PoliticianList = -1; // List of Age 4 European politicians
extern int  gAge5PoliticianList = -1; // List of Age 5 European politicians

extern int  gAge2WonderList = -1; // List of Age 2 Asian age-up wonders
extern int  gAge3WonderList = -1; // List of Age 3 Asian age-up wonders
extern int  gAge4WonderList = -1; // List of Age 4 Asian age-up wonders
extern int  gAge5WonderList = -1; // List of Age 5 Asian age-up wonders

extern int  gAge2WonderTechList = -1; // List of Age 2 Asian age-up technologies
extern int  gAge3WonderTechList = -1; // List of Age 3 Asian age-up technologies
extern int  gAge4WonderTechList = -1; // List of Age 4 Asian age-up technologies
extern int  gAge5WonderTechList = -1; // List of Age 5 Asian age-up technologies

extern int  gAgeUpPoliticians = -1; // Array of available age-up politicians
extern int  gPoliticianScores = -1; // Array used to calculate "scores" for different European politicians
extern int  gNatCouncilScores = -1; // Array used to calculate "scores" for different native council members
extern int  gAsianWonderScores = -1; // Array used to calculate "scores" for different Asian wonders

extern int  gRevolutionaryCards = -1; // List of available post-revolution cards

// New control variables added for the Draugur AI
extern bool cvOkToBuildDeck = true;      // Set to false in preInit() to force the AI to use a pre-assigned deck instead of building its own. For custom scenarios only!
extern bool cvIsNormal = true; // Set to false in this is the player's handicap game

//==============================================================================
/* initArrays()
   Initialize all global arrays here, to make it easy to find var type and size.
*/
//==============================================================================
void initArrays(void)
{
   gForecasts = xsArrayCreateFloat(cNumResourceTypes, 0.0, "Forecasts");
   gTargetGathererPercents = xsArrayCreateFloat(cNumResourceTypes, 0.0, "Gatherer Percents");
   gMapNames = xsArrayCreateString(50, "", "Map names");
      xsArraySetString(gMapNames, 0, "amazonia");
      xsArraySetString(gMapNames, 1, "bayou");
      xsArraySetString(gMapNames, 2, "caribbean");
      xsArraySetString(gMapNames, 3, "carolina");
      xsArraySetString(gMapNames, 4, "great lakes");
      xsArraySetString(gMapNames, 5, "great plains");
      xsArraySetString(gMapNames, 6, "new england");
      xsArraySetString(gMapNames, 7, "pampas");
      xsArraySetString(gMapNames, 8, "patagonia");
      xsArraySetString(gMapNames, 9, "rockies");
      xsArraySetString(gMapNames, 10, "saguenay");
      xsArraySetString(gMapNames, 11, "sonora");
      xsArraySetString(gMapNames, 12, "texas");
      xsArraySetString(gMapNames, 13, "yucatan");
      xsArraySetString(gMapNames, 14, "yukon");
      xsArraySetString(gMapNames, 15, "great plainsLarge");
      xsArraySetString(gMapNames, 16, "carolinalarge");
      xsArraySetString(gMapNames, 17, "saguenayLarge");
      xsArraySetString(gMapNames, 18, "sonoraLarge");
      xsArraySetString(gMapNames, 19, "texasLarge");
      xsArraySetString(gMapNames, 20, "hispaniola");
      xsArraySetString(gMapNames, 21, "andes");
      xsArraySetString(gMapNames, 22, "ozarks");
      xsArraySetString(gMapNames, 23, "araucania");
      xsArraySetString(gMapNames, 24, "california");
      xsArraySetString(gMapNames, 25, "grand canyon");
      xsArraySetString(gMapNames, 26, "northwest territory");
      xsArraySetString(gMapNames, 27, "painted desert");
      xsArraySetString(gMapNames, 28, "unknown");
      xsArraySetString(gMapNames, 29, "Borneo");
      xsArraySetString(gMapNames, 30, "Ceylon");
      xsArraySetString(gMapNames, 31, "Deccan");
      xsArraySetString(gMapNames, 32, "Himalayas");
      xsArraySetString(gMapNames, 33, "Honshu");
      xsArraySetString(gMapNames, 34, "Mongolia");
      xsArraySetString(gMapNames, 35, "silkRoad");
      xsArraySetString(gMapNames, 36, "Yellow riverDry");
      xsArraySetString(gMapNames, 37, "Yellow riverLarge");
      xsArraySetString(gMapNames, 38, "deccanLarge");
      xsArraySetString(gMapNames, 39, "himalayasUpper");
      xsArraySetString(gMapNames, 40, "honshuRegicide");
      xsArraySetString(gMapNames, 41, "indochina");
      xsArraySetString(gMapNames, 42, "plymouth");
      xsArraySetString(gMapNames, 43, "siberia");
      xsArraySetString(gMapNames, 44, "siberiaLarge");
      xsArraySetString(gMapNames, 45, "silkRoadLarge");

   gTargetSettlerCounts = xsArrayCreateInt(cAge5+1, 0, "Target Settler Counts");
      xsArraySetInt(gTargetSettlerCounts, cAge1, 20);
      xsArraySetInt(gTargetSettlerCounts, cAge2, 100);
      xsArraySetInt(gTargetSettlerCounts, cAge3, 100);
      xsArraySetInt(gTargetSettlerCounts, cAge4, 100);
      xsArraySetInt(gTargetSettlerCounts, cAge5, 100);
     
     //BHG: JFR: if we are in deatmatch we dont want to research the consulate tech that takes us to age 5
     if (aiGetGameMode() == cGameModeDeathmatch) {
      gConsulateTechsSize = 32;
     }else{
      gConsulateTechsSize = 33;
     }
     //...BHG: JFR:
     
     gConsulateTechs = xsArrayCreateInt(40, 0, "Consulate Tech IDs");
        xsArraySetInt(gConsulateTechs, 0, cTechypConsulateBritishBrigade);
        xsArraySetInt(gConsulateTechs, 1, cTechypConsulateBritishLifeGuards);
        xsArraySetInt(gConsulateTechs, 2, cTechypConsulateBritishRedcoats);
        xsArraySetInt(gConsulateTechs, 3, cTechypConsulateBritishRogersRangers);
        xsArraySetInt(gConsulateTechs, 4, cTechypConsulateDutchBrigade);
        xsArraySetInt(gConsulateTechs, 5, cTechypConsulateFrenchBrigade);
        xsArraySetInt(gConsulateTechs, 6, cTechypConsulateFrenchCoinCrates);
        xsArraySetInt(gConsulateTechs, 7, cTechypConsulateFrenchFoodCrates);
        xsArraySetInt(gConsulateTechs, 8, cTechypConsulateFrenchHotAirBalloonsPreq);
        xsArraySetInt(gConsulateTechs, 9, cTechypConsulateFrenchWoodCrates);
        xsArraySetInt(gConsulateTechs, 10, cTechypConsulateGermansBrigade);
        xsArraySetInt(gConsulateTechs, 11, cTechypConsulateGermansCoinTrickle);
        xsArraySetInt(gConsulateTechs, 12, cTechypConsulateGermansFoodTrickle);
        xsArraySetInt(gConsulateTechs, 13, cTechypConsulateGermansWoodTrickle);
        xsArraySetInt(gConsulateTechs, 14, cTechypConsulateJapaneseKoujou);        
        xsArraySetInt(gConsulateTechs, 15, cTechypConsulateJapaneseMilitaryRickshaw);
        xsArraySetInt(gConsulateTechs, 16, cTechypConsulateJapaneseMasterTraining);
        xsArraySetInt(gConsulateTechs, 17, cTechypConsulateOttomansBrigade);
        xsArraySetInt(gConsulateTechs, 18, cTechypConsulateOttomansGunpowderSiege);
        xsArraySetInt(gConsulateTechs, 19, cTechypConsulateOttomansInfantrySpeed);
        xsArraySetInt(gConsulateTechs, 20, cTechypConsulateOttomansSettlerCombat);
        xsArraySetInt(gConsulateTechs, 21, cTechypConsulatePortugueseBrigade);
        xsArraySetInt(gConsulateTechs, 22, cTechypConsulatePortugueseExpeditionaryFleet);
        xsArraySetInt(gConsulateTechs, 23, cTechypConsulatePortugueseExplorationFleet);
        xsArraySetInt(gConsulateTechs, 24, cTechypConsulatePortugueseFishingFleet);
        xsArraySetInt(gConsulateTechs, 25, cTechypConsulateRussianBrigade);
        xsArraySetInt(gConsulateTechs, 26, cTechypConsulateRussianFactoryWagon);
        xsArraySetInt(gConsulateTechs, 27, cTechypConsulateRussianFortWagon);
        xsArraySetInt(gConsulateTechs, 28, cTechypConsulateSpanishBrigade);
        xsArraySetInt(gConsulateTechs, 29, cTechypConsulateSpanishEnhancedProfits);
        xsArraySetInt(gConsulateTechs, 30, cTechypConsulateSpanishFasterShipments);
        xsArraySetInt(gConsulateTechs, 31, cTechypConsulateSpanishMercantilism);
        //BHG: JFR: if we are in deatmatch we dont want to research the consulate tech that takes us to age 5...
        if (aiGetGameMode() != cGameModeDeathmatch) {        
         xsArraySetInt(gConsulateTechs, 32, cTechypConsulateJapaneseMeijiRestoration);
        }
        //...BHG: JFR:
        
     gAsianWonders = xsArrayCreateInt(5, 0, "Wonder Age IDs");
     int wonderchoice = aiRandInt(4);
    
     if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy)) {
     //Giant Buddha, Golden Pavillion, Shogunate, Torii Gates, Toshogu Shrine 
        if (wonderchoice == 0) {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJGiantBuddha3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJGoldenPavillion4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJShogunate5);
        }
        else if (wonderchoice == 1) {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJGoldenPavillion3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJGiantBuddha4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJShogunate5);
        }
        else if (wonderchoice == 2) {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJToriiGates3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJShogunate4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJGoldenPavillion5);
        }
        else {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToshoguShrine2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJToriiGates3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJGoldenPavillion4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJShogunate5);
        }
     }
      if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese)) {
      //Confucian Academy, Porcelain Tower, Summer Palace, Temple of Heaven, White Pagoda
        if (wonderchoice == 0) {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCPorcelainTower2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCConfucianAcademy3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCSummerPalace4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCTempleOfHeaven5);
        }
        else if (wonderchoice == 1) {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCPorcelainTower2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCWhitePagoda3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCConfucianAcademy4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCSummerPalace5);
        }
        else if (wonderchoice == 2) {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCPorcelainTower2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCSummerPalace3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCTempleOfHeaven4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCConfucianAcademy5);
        }
        else {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCPorcelainTower2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCWhitePagoda3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCSummerPalace4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCConfucianAcademy5);
        }
     }
     if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians)) {
     //Agra Fort, Charminar Gate, Karni Mata, Taj Mahal, Tower of Victory
        if (wonderchoice == 0) {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWIAgraFort2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWICharminarGate3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWIKarniMata4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITajMahal5);
        }
        else if (wonderchoice == 1) {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWITowerOfVictory2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWIAgraFort3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWICharminarGate4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWIKarniMata5);
        }
        else if (wonderchoice == 2) {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWICharminarGate2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWIKarniMata3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWIAgraFort4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITowerOfVictory5);
        }
        else {
          xsArraySetInt(gAsianWonders, 0, cUnitTypeypWICharminarGate2);
          xsArraySetInt(gAsianWonders, 1, cUnitTypeypWIAgraFort3);
          xsArraySetInt(gAsianWonders, 2, cUnitTypeypWITajMahal4);
          xsArraySetInt(gAsianWonders, 3, cUnitTypeypWIKarniMata5);
        }
     }

   gAge2PoliticianList = xsArrayCreateInt(6, 0, "Age 2 Politician List");
      xsArraySetInt(gAge2PoliticianList, 0, cTechPoliticianGovernor);
      xsArraySetInt(gAge2PoliticianList, 1, cTechPoliticianQuartermaster);
      xsArraySetInt(gAge2PoliticianList, 2, cTechPoliticianNaturalist);
      xsArraySetInt(gAge2PoliticianList, 3, cTechPoliticianBishop);
      xsArraySetInt(gAge2PoliticianList, 4, cTechPoliticianPhilosopherPrince);
      xsArraySetInt(gAge2PoliticianList, 5, cTechPoliticianBishopGerman);

   gAge3PoliticianList = xsArrayCreateInt(16, 0, "Age 3 Politician List");
      xsArraySetInt(gAge3PoliticianList, 0, cTechPoliticianSergeantSpanish);
      xsArraySetInt(gAge3PoliticianList, 1, cTechPoliticianMohawk);
      xsArraySetInt(gAge3PoliticianList, 2, cTechPoliticianPirate);
      xsArraySetInt(gAge3PoliticianList, 3, cTechPoliticianAdventurerSpanish);
      xsArraySetInt(gAge3PoliticianList, 4, cTechPoliticianAdmiral);
      xsArraySetInt(gAge3PoliticianList, 5, cTechPoliticianExiledPrince);
      xsArraySetInt(gAge3PoliticianList, 6, cTechPoliticianMarksman);
      xsArraySetInt(gAge3PoliticianList, 7, cTechPoliticianAdmiralOttoman);
      xsArraySetInt(gAge3PoliticianList, 8, cTechPoliticianAdventurerBritish);
      xsArraySetInt(gAge3PoliticianList, 9, cTechPoliticianScout);
      xsArraySetInt(gAge3PoliticianList, 10, cTechPoliticianScoutRussian);
      xsArraySetInt(gAge3PoliticianList, 11, cTechPoliticianAdventurerRussian);
      xsArraySetInt(gAge3PoliticianList, 12, cTechPoliticianSergeantGerman);
      xsArraySetInt(gAge3PoliticianList, 13, cTechPoliticianMarksmanPortuguese);
      xsArraySetInt(gAge3PoliticianList, 14, cTechPoliticianMarksmanOttoman);
      xsArraySetInt(gAge3PoliticianList, 15, cTechPoliticianSergeantDutch);

   gAge4PoliticianList = xsArrayCreateInt(24, 0, "Age 4 Politician List");
      xsArraySetInt(gAge4PoliticianList, 0, cTechPoliticianEngineer);
      xsArraySetInt(gAge4PoliticianList, 1, cTechPoliticianTycoon);
      xsArraySetInt(gAge4PoliticianList, 2, cTechPoliticianMusketeerSpanish);
      xsArraySetInt(gAge4PoliticianList, 3, cTechPoliticianCavalierSpanish);
      xsArraySetInt(gAge4PoliticianList, 4, cTechPoliticianGrandVizier);
      xsArraySetInt(gAge4PoliticianList, 5, cTechPoliticianWarMinisterSpanish);
      xsArraySetInt(gAge4PoliticianList, 6, cTechPoliticianViceroyBritish);
      xsArraySetInt(gAge4PoliticianList, 7, cTechPoliticianMusketeerBritish);
      xsArraySetInt(gAge4PoliticianList, 8, cTechPoliticianCavalierFrench);
      xsArraySetInt(gAge4PoliticianList, 9, cTechPoliticianMusketeerFrench);
      xsArraySetInt(gAge4PoliticianList, 10, cTechPoliticianWarMinisterRussian);
      xsArraySetInt(gAge4PoliticianList, 11, cTechPoliticianCavalierRussian);
      xsArraySetInt(gAge4PoliticianList, 12, cTechPoliticianMusketeerRussian);
      xsArraySetInt(gAge4PoliticianList, 13, cTechPoliticianCavalierGerman);
      xsArraySetInt(gAge4PoliticianList, 14, cTechPoliticianViceroyGerman);
      xsArraySetInt(gAge4PoliticianList, 15, cTechPoliticianEngineerPortuguese);
      xsArraySetInt(gAge4PoliticianList, 16, cTechPoliticianViceroyPortuguese);
      xsArraySetInt(gAge4PoliticianList, 17, cTechPoliticianMusketeerPortuguese);
      xsArraySetInt(gAge4PoliticianList, 18, cTechPoliticianCavalierDutch);
      xsArraySetInt(gAge4PoliticianList, 19, cTechPoliticianCavalierOttoman);
      xsArraySetInt(gAge4PoliticianList, 20, cTechPoliticianMusketeerDutch);
      xsArraySetInt(gAge4PoliticianList, 21, cTechPoliticianViceroyDutch);
      xsArraySetInt(gAge4PoliticianList, 22, cTechPoliticianTycoonAct3);
      xsArraySetInt(gAge4PoliticianList, 23, cTechPoliticianWarMinisterAct3);

   gAge5PoliticianList = xsArrayCreateInt(5, 0, "Age 5 Politician List");
      xsArraySetInt(gAge5PoliticianList, 0, cTechPoliticianPresidente);
      xsArraySetInt(gAge5PoliticianList, 1, cTechPoliticianGeneral);
      xsArraySetInt(gAge5PoliticianList, 2, cTechPoliticianGeneralBritish);
      xsArraySetInt(gAge5PoliticianList, 3, cTechPoliticianGeneralOttoman);
      xsArraySetInt(gAge5PoliticianList, 4, cTechPoliticianGeneralSkirmisher);

   gAge2WonderList = xsArrayCreateInt(15, 0, "Age 2 Wonder List");
      xsArraySetInt(gAge2WonderList, 0, cUnitTypeypWCConfucianAcademy2);
      xsArraySetInt(gAge2WonderList, 1, cUnitTypeypWCPorcelainTower2);
      xsArraySetInt(gAge2WonderList, 2, cUnitTypeypWCSummerPalace2);
      xsArraySetInt(gAge2WonderList, 3, cUnitTypeypWCTempleOfHeaven2);
      xsArraySetInt(gAge2WonderList, 4, cUnitTypeypWCWhitePagoda2);
      xsArraySetInt(gAge2WonderList, 5, cUnitTypeypWIAgraFort2);
      xsArraySetInt(gAge2WonderList, 6, cUnitTypeypWICharminarGate2);
      xsArraySetInt(gAge2WonderList, 7, cUnitTypeypWIKarniMata2);
      xsArraySetInt(gAge2WonderList, 8, cUnitTypeypWITajMahal2);
      xsArraySetInt(gAge2WonderList, 9, cUnitTypeypWITowerOfVictory2);
      xsArraySetInt(gAge2WonderList, 10, cUnitTypeypWJGiantBuddha2);
      xsArraySetInt(gAge2WonderList, 11, cUnitTypeypWJGoldenPavillion2);
      xsArraySetInt(gAge2WonderList, 12, cUnitTypeypWJShogunate2);
      xsArraySetInt(gAge2WonderList, 13, cUnitTypeypWJToriiGates2);
      xsArraySetInt(gAge2WonderList, 14, cUnitTypeypWJToshoguShrine2);

   gAge3WonderList = xsArrayCreateInt(15, 0, "Age 3 Wonder List");
      xsArraySetInt(gAge3WonderList, 0, cUnitTypeypWCConfucianAcademy3);
      xsArraySetInt(gAge3WonderList, 1, cUnitTypeypWCPorcelainTower3);
      xsArraySetInt(gAge3WonderList, 2, cUnitTypeypWCSummerPalace3);
      xsArraySetInt(gAge3WonderList, 3, cUnitTypeypWCTempleOfHeaven3);
      xsArraySetInt(gAge3WonderList, 4, cUnitTypeypWCWhitePagoda3);
      xsArraySetInt(gAge3WonderList, 5, cUnitTypeypWIAgraFort3);
      xsArraySetInt(gAge3WonderList, 6, cUnitTypeypWICharminarGate3);
      xsArraySetInt(gAge3WonderList, 7, cUnitTypeypWIKarniMata3);
      xsArraySetInt(gAge3WonderList, 8, cUnitTypeypWITajMahal3);
      xsArraySetInt(gAge3WonderList, 9, cUnitTypeypWITowerOfVictory3);
      xsArraySetInt(gAge3WonderList, 10, cUnitTypeypWJGiantBuddha3);
      xsArraySetInt(gAge3WonderList, 11, cUnitTypeypWJGoldenPavillion3);
      xsArraySetInt(gAge3WonderList, 12, cUnitTypeypWJShogunate3);
      xsArraySetInt(gAge3WonderList, 13, cUnitTypeypWJToriiGates3);
      xsArraySetInt(gAge3WonderList, 14, cUnitTypeypWJToshoguShrine3);

   gAge4WonderList = xsArrayCreateInt(15, 0, "Age 4 Wonder List");
      xsArraySetInt(gAge4WonderList, 0, cUnitTypeypWCConfucianAcademy4);
      xsArraySetInt(gAge4WonderList, 1, cUnitTypeypWCPorcelainTower4);
      xsArraySetInt(gAge4WonderList, 2, cUnitTypeypWCSummerPalace4);
      xsArraySetInt(gAge4WonderList, 3, cUnitTypeypWCTempleOfHeaven4);
      xsArraySetInt(gAge4WonderList, 4, cUnitTypeypWCWhitePagoda4);
      xsArraySetInt(gAge4WonderList, 5, cUnitTypeypWIAgraFort4);
      xsArraySetInt(gAge4WonderList, 6, cUnitTypeypWICharminarGate4);
      xsArraySetInt(gAge4WonderList, 7, cUnitTypeypWIKarniMata4);
      xsArraySetInt(gAge4WonderList, 8, cUnitTypeypWITajMahal4);
      xsArraySetInt(gAge4WonderList, 9, cUnitTypeypWITowerOfVictory4);
      xsArraySetInt(gAge4WonderList, 10, cUnitTypeypWJGiantBuddha4);
      xsArraySetInt(gAge4WonderList, 11, cUnitTypeypWJGoldenPavillion4);
      xsArraySetInt(gAge4WonderList, 12, cUnitTypeypWJShogunate4);
      xsArraySetInt(gAge4WonderList, 13, cUnitTypeypWJToriiGates4);
      xsArraySetInt(gAge4WonderList, 14, cUnitTypeypWJToshoguShrine4);

   gAge5WonderList = xsArrayCreateInt(15, 0, "Age 5 Wonder List");
      xsArraySetInt(gAge5WonderList, 0, cUnitTypeypWCConfucianAcademy5);
      xsArraySetInt(gAge5WonderList, 1, cUnitTypeypWCPorcelainTower5);
      xsArraySetInt(gAge5WonderList, 2, cUnitTypeypWCSummerPalace5);
      xsArraySetInt(gAge5WonderList, 3, cUnitTypeypWCTempleOfHeaven5);
      xsArraySetInt(gAge5WonderList, 4, cUnitTypeypWCWhitePagoda5);
      xsArraySetInt(gAge5WonderList, 5, cUnitTypeypWIAgraFort5);
      xsArraySetInt(gAge5WonderList, 6, cUnitTypeypWICharminarGate5);
      xsArraySetInt(gAge5WonderList, 7, cUnitTypeypWIKarniMata5);
      xsArraySetInt(gAge5WonderList, 8, cUnitTypeypWITajMahal5);
      xsArraySetInt(gAge5WonderList, 9, cUnitTypeypWITowerOfVictory5);
      xsArraySetInt(gAge5WonderList, 10, cUnitTypeypWJGiantBuddha5);
      xsArraySetInt(gAge5WonderList, 11, cUnitTypeypWJGoldenPavillion5);
      xsArraySetInt(gAge5WonderList, 12, cUnitTypeypWJShogunate5);
      xsArraySetInt(gAge5WonderList, 13, cUnitTypeypWJToriiGates5);
      xsArraySetInt(gAge5WonderList, 14, cUnitTypeypWJToshoguShrine5);

   gAge2WonderTechList = xsArrayCreateInt(15, 0, "Age 2 WonderTech List");
      xsArraySetInt(gAge2WonderTechList, 0, cTechYPWonderChineseConfucianAcademy2);
      xsArraySetInt(gAge2WonderTechList, 1, cTechYPWonderChinesePorcelainTower2);
      xsArraySetInt(gAge2WonderTechList, 2, cTechYPWonderChineseSummerPalace2);
      xsArraySetInt(gAge2WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven2);
      xsArraySetInt(gAge2WonderTechList, 4, cTechYPWonderChineseWhitePagoda2);
      xsArraySetInt(gAge2WonderTechList, 5, cTechYPWonderIndianAgra2);
      xsArraySetInt(gAge2WonderTechList, 6, cTechYPWonderIndianCharminar2);
      xsArraySetInt(gAge2WonderTechList, 7, cTechYPWonderIndianKarniMata2);
      xsArraySetInt(gAge2WonderTechList, 8, cTechYPWonderIndianTajMahal2);
      xsArraySetInt(gAge2WonderTechList, 9, cTechYPWonderIndianTowerOfVictory2);
      xsArraySetInt(gAge2WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha2);
      xsArraySetInt(gAge2WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion2);
      xsArraySetInt(gAge2WonderTechList, 12, cTechYPWonderJapaneseShogunate2);
      xsArraySetInt(gAge2WonderTechList, 13, cTechYPWonderJapaneseToriiGates2);
      xsArraySetInt(gAge2WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine2);

   gAge3WonderTechList = xsArrayCreateInt(15, 0, "Age 3 WonderTech List");
      xsArraySetInt(gAge3WonderTechList, 0, cTechYPWonderChineseConfucianAcademy3);
      xsArraySetInt(gAge3WonderTechList, 1, cTechYPWonderChinesePorcelainTower3);
      xsArraySetInt(gAge3WonderTechList, 2, cTechYPWonderChineseSummerPalace3);
      xsArraySetInt(gAge3WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven3);
      xsArraySetInt(gAge3WonderTechList, 4, cTechYPWonderChineseWhitePagoda3);
      xsArraySetInt(gAge3WonderTechList, 5, cTechYPWonderIndianAgra3);
      xsArraySetInt(gAge3WonderTechList, 6, cTechYPWonderIndianCharminar3);
      xsArraySetInt(gAge3WonderTechList, 7, cTechYPWonderIndianKarniMata3);
      xsArraySetInt(gAge3WonderTechList, 8, cTechYPWonderIndianTajMahal3);
      xsArraySetInt(gAge3WonderTechList, 9, cTechYPWonderIndianTowerOfVictory3);
      xsArraySetInt(gAge3WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha3);
      xsArraySetInt(gAge3WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion3);
      xsArraySetInt(gAge3WonderTechList, 12, cTechYPWonderJapaneseShogunate3);
      xsArraySetInt(gAge3WonderTechList, 13, cTechYPWonderJapaneseToriiGates3);
      xsArraySetInt(gAge3WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine3);

   gAge4WonderTechList = xsArrayCreateInt(15, 0, "Age 4 WonderTech List");
      xsArraySetInt(gAge4WonderTechList, 0, cTechYPWonderChineseConfucianAcademy4);
      xsArraySetInt(gAge4WonderTechList, 1, cTechYPWonderChinesePorcelainTower4);
      xsArraySetInt(gAge4WonderTechList, 2, cTechYPWonderChineseSummerPalace4);
      xsArraySetInt(gAge4WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven4);
      xsArraySetInt(gAge4WonderTechList, 4, cTechYPWonderChineseWhitePagoda4);
      xsArraySetInt(gAge4WonderTechList, 5, cTechYPWonderIndianAgra4);
      xsArraySetInt(gAge4WonderTechList, 6, cTechYPWonderIndianCharminar4);
      xsArraySetInt(gAge4WonderTechList, 7, cTechYPWonderIndianKarniMata4);
      xsArraySetInt(gAge4WonderTechList, 8, cTechYPWonderIndianTajMahal4);
      xsArraySetInt(gAge4WonderTechList, 9, cTechYPWonderIndianTowerOfVictory4);
      xsArraySetInt(gAge4WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha4);
      xsArraySetInt(gAge4WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion4);
      xsArraySetInt(gAge4WonderTechList, 12, cTechYPWonderJapaneseShogunate4);
      xsArraySetInt(gAge4WonderTechList, 13, cTechYPWonderJapaneseToriiGates4);
      xsArraySetInt(gAge4WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine4);

   gAge5WonderTechList = xsArrayCreateInt(15, 0, "Age 5 WonderTech List");
      xsArraySetInt(gAge5WonderTechList, 0, cTechYPWonderChineseConfucianAcademy5);
      xsArraySetInt(gAge5WonderTechList, 1, cTechYPWonderChinesePorcelainTower5);
      xsArraySetInt(gAge5WonderTechList, 2, cTechYPWonderChineseSummerPalace5);
      xsArraySetInt(gAge5WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven5);
      xsArraySetInt(gAge5WonderTechList, 4, cTechYPWonderChineseWhitePagoda5);
      xsArraySetInt(gAge5WonderTechList, 5, cTechYPWonderIndianAgra5);
      xsArraySetInt(gAge5WonderTechList, 6, cTechYPWonderIndianCharminar5);
      xsArraySetInt(gAge5WonderTechList, 7, cTechYPWonderIndianKarniMata5);
      xsArraySetInt(gAge5WonderTechList, 8, cTechYPWonderIndianTajMahal5);
      xsArraySetInt(gAge5WonderTechList, 9, cTechYPWonderIndianTowerOfVictory5);
      xsArraySetInt(gAge5WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha5);
      xsArraySetInt(gAge5WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion5);
      xsArraySetInt(gAge5WonderTechList, 12, cTechYPWonderJapaneseShogunate5);
      xsArraySetInt(gAge5WonderTechList, 13, cTechYPWonderJapaneseToriiGates5);
      xsArraySetInt(gAge5WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine5);

   gRevolutionaryCards = xsArrayCreateString(4, "", "Revolution Deck");
      xsArraySetString(gRevolutionaryCards, 0, "Gatling Guns");
      xsArraySetString(gRevolutionaryCards, 1, "Colonial Militia");
      xsArraySetString(gRevolutionaryCards, 2, "Ironclads");
      xsArraySetString(gRevolutionaryCards, 3, "Fort Wagon");

   gAgeUpPoliticians = xsArrayCreateInt(6, 0, "Ageup Politicians");
   gPoliticianScores = xsArrayCreateInt(6, 0, "European Politicians");
   gNatCouncilScores = xsArrayCreateInt(6, 0, "Native Council");
   gAsianWonderScores = xsArrayCreateInt(6, 0, "Asian Wonders");
}


//==============================================================================
// echoMessage()
// Used to provide on-screen debug information.
//==============================================================================
void echoMessage(string message="DEFAULT")
{
   int player = -1;
   
   for (player = 0; <cNumberPlayers)
   {
      aiChat(player, message);
   }
}


//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Utility functions
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
void sendChatToAllies(string text="")
{
   int player = -1;
   
   for (player = 0; <cNumberPlayers)
   {
      if ( (player != cMyID) && (kbIsPlayerAlly(player) == true))
         aiChat(player, text);
   }
}

bool civIsNative(void)
{
   if ((cMyCiv == cCivXPAztec) || 
       (cMyCiv == cCivXPIroquois) || 
       (cMyCiv == cCivXPSioux))
      return(true);
   
   return(false);
}

bool civIsAsian(void)
{
   if ((cMyCiv == cCivJapanese) ||
       (cMyCiv == cCivChinese) || 
       (cMyCiv == cCivIndians) || 
       (cMyCiv == cCivSPCIndians) || 
       (cMyCiv == cCivSPCChinese) ||
       (cMyCiv == cCivSPCJapanese) ||
       (cMyCiv == cCivSPCJapaneseEnemy))
      return(true);
   
   return(false);
}

bool civIsEuropean(void)
{
   if ((cMyCiv == cCivBritish) || 
       (cMyCiv == cCivFrench) || 
       (cMyCiv == cCivDutch) || 
       (cMyCiv == cCivSpanish) || 
       (cMyCiv == cCivGermans) || 
       (cMyCiv == cCivRussians) || 
       (cMyCiv == cCivPortuguese) ||
       (cMyCiv == cCivOttomans))
      return(true);
   
   return(false);
}

bool civIsInAllyTeam(int civ=cCivSpanish)
{
   int numEnemy = 0;
   int numEnemyHuman = 0;   
   int player = -1;
   bool result = false;

   for (player=1; < cNumberPlayers)
   {
       if (player == cMyID)
	 continue;      
       if ((kbIsPlayerAlly(player) == true)&&(kbGetCivForPlayer(player) == civ))
       {
	  result = true;
	  break;
       }
   }
   return(result);
}

bool civIsInEnemyTeam(int civ=cCivSpanish)
{
   int numEnemy = 0;
   int numEnemyHuman = 0;   
   int player = -1;
   bool result = false;

   for (player=1; < cNumberPlayers)
   {
       if (player == cMyID)
	 continue;      
       if ((kbIsPlayerAlly(player) == true)&&(kbGetCivForPlayer(player) == civ))
       {
	  result = true;
	  break;
       }
   }
   return(result);
}


//==============================================================================
// mapPreventsWalls --
// some maps do not allow walls or it doesn't make sense to build walls there
//==============================================================================
bool mapPreventsWalls()
{    
    // set "false" maps do not allow walls
    if ( (cRandomMapName == "amazonia") ||  
	 (cRandomMapName == "caribbean") || 
	 (cRandomMapName == "Ceylon") || 
	 (cRandomMapName == "HonshuRegicide") ||
	 (cRandomMapName == "*") ||
         (cRandomMapName == "Honshu") )    
       return(true);
        
    return(false);
}

int getSettlerShortfall()
{  // How many more Settlers do we currently want?
   int retVal = 0;
   float villTarget = xsArrayGetInt(gTargetSettlerCounts, kbGetAge());  // How many we want to have this age
   float villCount = kbUnitCount(cMyID, gEconUnit, cUnitStateABQ);   // How many we have

   retVal = villTarget - villCount;

   return(retVal);
}

bool agingUp()
{
   bool retVal = false;
   if ((aiPlanGetState(gAgeUpResearchPlan) == cPlanStateResearch) || (aiPlanGetState(gAgeUpResearchPlan) == cPlanStateBuild))
      retVal = true;

   return(retVal);
}

bool agingUpTo(int nextAge = -1)
{
   bool retVal = false;
   if ((kbGetAge() + 1 == nextAge) && ((aiPlanGetState(gAgeUpResearchPlan) == cPlanStateResearch) || (aiPlanGetState(gAgeUpResearchPlan) == cPlanStateBuild)))
      retVal = true;
   return(retVal);
}

bool agingUpToOrAbove(int Age = -1)
{
   bool retVal = false;
   if ((kbGetAge() == Age - 1) && ((aiPlanGetState(gAgeUpResearchPlan) == cPlanStateResearch) || (aiPlanGetState(gAgeUpResearchPlan) == cPlanStateBuild)))
      retVal = true;
   if (kbGetAge() >= Age)
      retVal = true;

   return(retVal);
}

int getWonderToBuild(int the_age=-1)
{
  if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapanese)) {
    //Giant Buddha, Golden Pavillion, Shogunate, Torii Gates, Toshogu Shrine
    //age2
    if (the_age == cAge2) {
      return (cUnitTypeypWJGiantBuddha2);
    }
    //age3
    else if (the_age == cAge3) {
      return (cUnitTypeypWJToriiGates3);
    }
    //age4
    else if (the_age == cAge4) {
      return (cUnitTypeypWJShogunate4);
    }
    //age5
    else if (the_age == cAge5) {
      return (cUnitTypeypWJToshoguShrine5);
    }
  }
  if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese)) {
    //age2
    if (the_age == cAge2) {
      return (cUnitTypeypWCPorcelainTower2);
    }
    //age3
    else if (the_age == cAge3) {
      return (cUnitTypeypWCSummerPalace3);
    }
    //age4
    else if (the_age == cAge4) {
      return (cUnitTypeypWCTempleOfHeaven4);
    }
    //age5
    else if (the_age == cAge5) {
      return (cUnitTypeypWCWhitePagoda5);
    }
  }
  if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians)) {
    //age2
    if (the_age == cAge2) {
      return (cUnitTypeypWICharminarGate2);
    }
    //age3
    else if (the_age == cAge3) {
      return (cUnitTypeypWIKarniMata3);
    }
    //age4
    else if (the_age == cAge4) {
      return (cUnitTypeypWITajMahal4);
    }
    //age5
    else if (the_age == cAge5) {
      return (cUnitTypeypWIAgraFort5);
    }
  }
  
  return (-1);
}

int getPreferredWonderToBuild(int the_age=-1)
{
  if (the_age == cAge2) {
    return(xsArrayGetInt(gAsianWonders, 0));
  }
  //age3
  else if (the_age == cAge3) {
    return(xsArrayGetInt(gAsianWonders, 1));
  }
  //age4
  else if (the_age == cAge4) {
    return(xsArrayGetInt(gAsianWonders, 2));
  }
  //age5
  else if (the_age == cAge5) {
    if (aiGetGameMode() == cGameModeDeathmatch) {
      return(-1); //BHG:CGN: don't try to get to age 5 in a deathmatch game
    }
    return(xsArrayGetInt(gAsianWonders, 3));
  }
  return (-1);
}


//==============================================================================
/* createOpportunity(type, targetType, targetID, targetPlayerID, source)

   A wrapper function for aiCreateOpportunity(), to permit centralized tracking
   of the most recently created ally-generated and trigger-generated 
   opportunities.  This info is needed so that a cancel command can
   efficiently deactivate the previous (and possibly current) opportunity before
   creating the new one.
*/
//==============================================================================
int createOpportunity(int type = -1, int targetType = -1, int targetID = -1, int targetPlayerID = -1, int source = -1)
{
   int oppID = aiCreateOpportunity(type, targetType, targetID, targetPlayerID, source);
   if (source == cOpportunitySourceAllyRequest)
      gMostRecentAllyOpportunityID = oppID; // Remember which ally opp we're doing
   else if (source == cOpportunitySourceTrigger)
      gMostRecentTriggerOpportunityID = oppID;
   
   return(oppID);
}



//==============================================================================
/* sendStatement(player, commPromptID, vector)

  Sends a chat statement, but first checks the control variables and updates the
  "ok to chat" state.   This is a gateway for routine "ambience" personality chats.
  Another function will be written as a gateway for strategic communications, i.e.
  requests for defence, tribute, joint operations, etc.  That one will be controlled by 
  the cvOkToChat variable.
  
  If vector is not cInvalidVector, it will be added as a flare
*/
//==============================================================================
bool sendStatement(int playerIDorRelation = -1, int commPromptID = -1, vector vec = cInvalidVector)
{
   aiEcho("<<<<<SEND STATEMENT to player "+playerIDorRelation+", commPromptID = "+commPromptID+", vector "+vec+">>>>>");
   // Routine "ambience" chats are not allowed
	if (cvOkToTaunt == false)
   {
      // Failed, no chat sent
		// Make sure the C++ side knows about it
		aiCommsAllowChat(false);
      return(false);
   }
   
   // If we got this far, it's OK.
	aiCommsAllowChat(true);

   // It's a player ID, not a relation.
	if (playerIDorRelation < 100)
   {
      int playerID = playerIDorRelation;
      if (vec == cInvalidVector)
         aiCommsSendStatement(playerID, commPromptID);
      else
         aiCommsSendStatementWithVector(playerID, commPromptID, vec);
   }
   else  // Then it's a player relation
   {
      int player = -1;
      for (player = 1; < cNumberPlayers)
      {
         bool send = false;
         switch(playerIDorRelation)
         {
            case cPlayerRelationAny:
            {
               send = true;
               break;
            }
            case cPlayerRelationSelf:
            {
               if (player == cMyID)
                  send = true;
               break;
            }
            case cPlayerRelationAlly:
            {
               send = kbIsPlayerAlly(player);

					// Don't talk to myself, even though I am my ally.
               if (player == cMyID)
                  send = false;     
               break;
            }
            case cPlayerRelationEnemy:
            {
               send = kbIsPlayerEnemy(player);
               break;
            }
            case cPlayerRelationEnemyNotGaia:
            {
               send = kbIsPlayerEnemy(player);
               break;
            }
         }
         if (send == true)
         {
            aiEcho("<<<<<Sending chat prompt "+commPromptID+" to player "+player+" with vector "+vec+">>>>>");
            if (vec == cInvalidVector)
               aiCommsSendStatement(player, commPromptID);
            else
               aiCommsSendStatementWithVector(player, commPromptID, vec);
         }
      }
   }
   return(true);
}



//==============================================================================
// Plan Chat functions
//
//==============================================================================


// Set the attack plan to trigger a message and optional flare when the plan reaches the specified state.
// See the event handler below.
bool setPlanChat(int plan=-1, int state=-1, int prompt=-1, int player=-1, vector flare=cInvalidVector)
{
 
   // State -1 could be valid for action on plan termination
	if ( (plan < 0) || (prompt < 0) || (player < 0) )
      return(false);    

	aiPlanSetEventHandler(plan, cPlanEventStateChange, "planStateEventHandler");

   aiPlanAddUserVariableInt(plan, 0, "Key State", 1);
   aiPlanAddUserVariableInt(plan, 1, "Prompt ID", 1);
   aiPlanAddUserVariableInt(plan, 2, "Send To", 1);
   aiPlanAddUserVariableVector(plan, 3, "Flare Vector", 1);
   
   aiPlanSetUserVariableInt(plan, 0, 0, state);
   aiPlanSetUserVariableInt(plan, 1, 0, prompt);
   aiPlanSetUserVariableInt(plan, 2, 0, player);
   aiPlanSetUserVariableVector(plan, 3, 0, flare);
   
   return(true);
}


void  planStateEventHandler(int planID=-1)
{
   aiEcho("    Plan "+aiPlanGetName(planID)+" is now in state "+aiPlanGetState(planID));

   // Plan planID has changed states.  Get its state, compare to target, issue chat if it matches
   int state = aiPlanGetUserVariableInt(planID, 0, 0);
   int prompt = aiPlanGetUserVariableInt(planID, 1, 0);
   int player = aiPlanGetUserVariableInt(planID, 2, 0);
   vector flare = aiPlanGetUserVariableVector(planID, 3, 0);
   
   if ( aiPlanGetState(planID) == state )
   {
      // We have a winner, send the chat statement
      sendStatement(player, prompt, flare);
      //clearPlanChat(index);
   }
}


void tcPlacedEventHandler(int planID=-1)
{
   // Check the state of the TC build plan.
   // Fire an ally chat if the state is "build"
   if (aiPlanGetState(planID) == cPlanStateBuild)
   {
      vector loc = kbBuildingPlacementGetResultPosition(aiPlanGetVariableInt(planID,cBuildPlanBuildingPlacementID, 0) ); 
      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillBuildTC, loc);
      aiEcho("Sending TC placement chat at location "+loc);
   }
}

//==============================================================================
// distance
//
// Will return a float with the 3D distance between two vectors                     
//==============================================================================
float distance(vector v1=cInvalidVector, vector v2=cInvalidVector)
{
   vector delta = v1 - v2;
   return (xsVectorLength(delta));
}

//==============================================================================
// getUnit
//
// Will return a random unit matching the parameters
//==============================================================================
int getUnit(int unitTypeID=-1, int playerRelationOrID=cMyID, int state=cUnitStateAlive)
{
   int count=-1;
   static int unitQueryID=-1;

   //If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID=kbUnitQueryCreate("miscGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }

	//Define a query to get all matching units
	if (unitQueryID != -1)
	{
      if (playerRelationOrID > 1000)      // Too big for player ID number
      {
      	kbUnitQuerySetPlayerID(unitQueryID, -1);  // Clear the player ID, so playerRelation takes precedence.
         kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
      }
      else
      {
         kbUnitQuerySetPlayerRelation(unitQueryID, -1);
      	kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
      }
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetState(unitQueryID, state);
	}
	else
   	return(-1);

   kbUnitQueryResetResults(unitQueryID);
	int numberFound=kbUnitQueryExecute(unitQueryID);
   if (numberFound > 0)
      return(kbUnitQueryGetResult(unitQueryID, aiRandInt(numberFound)));   // Return a random dude(tte)
   return(-1);
}

//==============================================================================
// createSimpleAttackGoal
//==============================================================================
int createSimpleAttackGoal(string name="BUG", int attackPlayerID=-1,
int unitPickerID=-1, int repeat=-1, int minAge=-1, int maxAge=-1,
int baseID=-1, bool allowRetreat=false)
{
	aiEcho("CreateSimpleAttackGoal:  Name="+name+", AttackPlayerID="+attackPlayerID+".");
	aiEcho("  UnitPickerID="+unitPickerID+", Repeat="+repeat+", baseID="+baseID+".");
	aiEcho("  MinAge="+minAge+", maxAge="+maxAge+", allowRetreat="+allowRetreat+".");

	//Create the goal.
	int goalID=aiPlanCreate(name, cPlanGoal);
	if (goalID < 0)
		return(-1);

	//Priority.
	aiPlanSetDesiredPriority(goalID, 90);
	//Attack player ID.
	if (attackPlayerID >= 0)
	  aiPlanSetVariableInt(goalID, cGoalPlanAttackPlayerID, 0, attackPlayerID);
	else
	  aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateAttackPlayerID, 0, true);
	//Base.
	if (baseID >= 0)
	  aiPlanSetBaseID(goalID, baseID);
	else
	  aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateBase, 0, true);
	//Attack.
	aiPlanSetAttack(goalID, true);
	aiPlanSetVariableInt(goalID, cGoalPlanGoalType, 0, cGoalPlanGoalTypeAttack);
	aiPlanSetVariableInt(goalID, cGoalPlanAttackStartFrequency, 0, 1);
	
	//Military.
	aiPlanSetMilitary(goalID, true);
	aiPlanSetEscrowID(goalID, cMilitaryEscrowID);
	//Ages.
	aiPlanSetVariableInt(goalID, cGoalPlanMinAge, 0, minAge);
	aiPlanSetVariableInt(goalID, cGoalPlanMaxAge, 0, maxAge);
	//Repeat.
	aiPlanSetVariableInt(goalID, cGoalPlanRepeat, 0, repeat);
	//Unit Picker.
	aiPlanSetVariableInt(goalID, cGoalPlanUnitPickerID, 0, unitPickerID);
	//Retreat.
	if (kbGetAge() < cAge5)
	{
	aiPlanSetVariableBool(goalID, cGoalPlanAllowRetreat, 0, allowRetreat);     
	}
        //Upgrade unit prefs. 
        aiPlanSetNumberVariableValues(goalID, cGoalPlanTargetType, 2, true);
	aiPlanSetVariableInt(goalID, cGoalPlanTargetType, 0, cUnitTypeLogicalTypeLandMilitary);
	aiPlanSetVariableInt(goalID, cGoalPlanTargetType, 1, cUnitTypeValidIdleVillager);
        //Upgrade Building prefs.
        aiPlanSetNumberVariableValues(goalID, cGoalPlanUpgradeBuilding, 3, true);
        aiPlanSetVariableInt(goalID, cGoalPlanUpgradeBuilding, 0, cUnitTypeTownCenter);
        aiPlanSetVariableInt(goalID, cGoalPlanUpgradeBuilding, 1, gFarmUnit);       
        if (cMyCiv == cCivDutch)
           aiPlanSetVariableInt(goalID, cGoalPlanUpgradeBuilding, 2, cUnitTypeBank);
        else if (cMyCiv == cCivJapanese)
           aiPlanSetVariableInt(goalID, cGoalPlanUpgradeBuilding, 2, cUnitTypeypShrineJapanese);
        else
           aiPlanSetVariableInt(goalID, cGoalPlanUpgradeBuilding, 2, gPlantationUnit);
        
	//Handle maps where the enemy player is usually on a diff island.
	if ( (cRandomMapName == "amazonia") || (cRandomMapName == "caribbean") || (cRandomMapName == "Ceylon") )
	{
	   aiPlanSetVariableBool(goalID, cGoalPlanSetAreaGroups, 0, true);
	   aiPlanSetVariableInt(goalID, cGoalPlanAttackRoutePatternType, 0, cAttackPlanAttackRoutePatternRandom);
	}
        aiPlanSetUnitStance(goalID, cUnitStanceAggressive);
	//Done.
	return(goalID);
}


//==============================================================================
// getUnitByLocation
//
// Will return a random unit matching the parameters
//==============================================================================
int getUnitByLocation(int unitTypeID=-1, int playerRelationOrID=cMyID, int state=cUnitStateAlive, vector location = cInvalidVector, float radius = 20.0, int pos = 0)
{
   int count=-1;
   static int unitQueryID=-1;

   //If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID=kbUnitQueryCreate("miscGetUnitLocationQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }

	//Define a query to get all matching units
	if (unitQueryID != -1)
	{
      if (playerRelationOrID > 1000)      // Too big for player ID number
      {
      	kbUnitQuerySetPlayerID(unitQueryID, -1);
         kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
      }
      else
      {
         kbUnitQuerySetPlayerRelation(unitQueryID, -1);
      	kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
      }
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetState(unitQueryID, state);
      kbUnitQuerySetPosition(unitQueryID, location);
      kbUnitQuerySetMaximumDistance(unitQueryID, radius);
	}
	else
   	return(-1);

   kbUnitQueryResetResults(unitQueryID);
	int numberFound=kbUnitQueryExecute(unitQueryID);
   if (numberFound > 0)
      return(kbUnitQueryGetResult(unitQueryID, pos));   
   return(-1);
}

//==============================================================================
// getUnitCountByLocation
//
// Returns the number of matching units in the point/radius specified
//==============================================================================
int getUnitCountByLocation(int unitTypeID=-1, int playerRelationOrID=cMyID, int state=cUnitStateAlive, vector location = cInvalidVector, float radius = 20.0)
{
   int count=-1;
   static int unitQueryID=-1;
   
   //If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID=kbUnitQueryCreate("miscGetUnitLocationQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }

	//Define a query to get all matching units
	if (unitQueryID != -1)
	{
      if (playerRelationOrID > 1000)      // Too big for player ID number
      {
      	kbUnitQuerySetPlayerID(unitQueryID, -1);
         kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
      }
      else
      {
         kbUnitQuerySetPlayerRelation(unitQueryID, -1);
      	kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
      }
      kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
      kbUnitQuerySetState(unitQueryID, state);
      kbUnitQuerySetPosition(unitQueryID, location);
      kbUnitQuerySetMaximumDistance(unitQueryID, radius);
	}
	else
   	return(-1);

   kbUnitQueryResetResults(unitQueryID);
	return(kbUnitQueryExecute(unitQueryID));
}

//==============================================================================
// getPlayerArmyHPs
//
// Queries all land military units.  
// Totals hitpoints (ideal if considerHealth false, otherwise actual.)
// Returns total
//==============================================================================
float getPlayerArmyHPs(int playerID = -1, bool considerHealth = false)
{
   int queryID = -1;    // Will recreate each time, as changing player trashes existing query settings.
   
   if (playerID <= 0) 
      return(-1.0);
   
   queryID = kbUnitQueryCreate("getStrongestEnemyArmyHPs");
   kbUnitQuerySetIgnoreKnockedOutUnits(queryID, true);
   kbUnitQuerySetPlayerID(queryID, playerID, true);
   kbUnitQuerySetUnitType(queryID, cUnitTypeLogicalTypeLandMilitary);
   kbUnitQuerySetState(queryID, cUnitStateAlive);
   kbUnitQueryResetResults(queryID);
   kbUnitQueryExecute(queryID);
   
   return(kbUnitQueryGetUnitHitpoints(queryID, considerHealth));
}


//==============================================================================
/* sigmoid(float base, float adjustment, float floor, float ceiling)

   Used to adjust a number up or down in a sigmoid fashion, so that it
   grows very slowly at values near the bottom of the range, quickly near
   the center, and slowly near the upper limit.  

   Used with the many 0..1 range variables, this lets us adjust them up
   or down by arbitrary "percentages" while retaining the 0..1 boundaries.  
   That is, a 50% "boost" (1.5 adjustment) to a .9 score gives .933, while a


   Base is the number to be adjusted.
   Adjustment of 1.0 means 100%, i.e. stay where you are.
   Adjustment of 2.0 means to move it up by the LESSER movement of:
      Doubling the (base-floor) amount, or
      Cutting the (ceiling-base) in half (mul by 1/2.0).

   With a default floor of 0 and ceiling of 1, it gives these results:
      sigmoid(.1, 2.0) = .2
      sigmoid(.333, 2.0) = .667, upper and lower adjustments equal
      sigmoid(.8, 2.0) = .9, adjusted up 50% (1/2.0) of the headroom.
      sigmoid(.1, 5.0) = .50 (5x base, rather than moving up to .82)
      sigmoid(.333, 5.0) = .866, (leaving 1/5 of the .667 headroom)
      sigmoid(.8, 5.0) = .96 (leaving 1/5 of the .20 headroom)
      
   Adjustments of less than 1.0 (neutral) do the opposite...they move the 
   value DOWN by the lesser movement of:
      Increasing headroom by a factor of 1/adjustment, or
      Decreasing footroom by multiplying by adjustment.
      sigmoid(.1, .5) = .05   (footroom*adjustment)
      sigmoid(.667, .5) = .333  (footroom*adjustment) = (headroom doubled)
      sigmoid(.8, .2) = .16 (footroom*0.2)
      
   Not intended for base < 0.  Ceiling must be > floor.  Must have floor <= base <= ceiling.
*/
//==============================================================================
float sigmoid(float base=-1.0 /*required*/, float adjust=1.0, float floor=0.0, float ceiling=1.0)
{
   float retVal = -1.0;
   if (base < 0.0)
      return(retVal);
   if (ceiling <= floor)
      return(retVal);
   if (base < floor)
      return(retVal);
   if (base > ceiling)
      return(retVal);
   
   float footroom = base - floor;
   float headroom = ceiling - base;
   
   float footBasedNewValue = 0.0;   // This will be the value created by adjusting the footroom, i.e.
                                    // increasing a small value.
   float headBasedNewValue = 0.0;   // This will be the value created by adjusting the headroom, i.e.
                                    // increasing a value that's closer to ceiling than floor.
   
   if (adjust > 1.0) 
   {  // Increasing
      footBasedNewValue = floor + (footroom * adjust);
      headBasedNewValue = ceiling - (headroom / adjust);
      
      // Pick the value that resulted in the smaller net movement
      if ( (footBasedNewValue - base) < (headBasedNewValue - base) )
         retVal = footBasedNewValue;   // The foot adjustment gave the smaller move.
      else
         retVal = headBasedNewValue;   // The head adjustment gave the smaller move
   }
   else
   {  // Decreasing
      footBasedNewValue = floor + (footroom * adjust);
      headBasedNewValue = ceiling - (headroom / adjust);
      
      // Pick the value that resulted in the smaller net movement
      if ( (base - footBasedNewValue) < (base - headBasedNewValue) )
         retVal = footBasedNewValue;   // The foot adjustment gave the smaller move.
      else
         retVal = headBasedNewValue;   // The head adjustment gave the smaller move
   }
   
   aiEcho("sigmoid("+base+", "+adjust+", "+floor+", "+ceiling+") is "+retVal);
   return(retVal);
   
}

//==============================================================================
//createSimpleResearchPlan
//==============================================================================
int createSimpleResearchPlan(int techID=-1, int buildingID=-1, int escrowID=cRootEscrowID, int pri = 50)
{
	int planID=aiPlanCreate("Research "+kbGetTechName(techID), cPlanResearch);
	if (planID < 0)
		aiEcho("Failed to create simple research plan for "+techID);
   else
   {
	   aiPlanSetVariableInt(planID, cResearchPlanTechID, 0, techID);
      aiPlanSetVariableInt(planID, cResearchPlanBuildingID, 0, buildingID);
	   aiPlanSetDesiredPriority(planID, pri);
	   aiPlanSetEscrowID(planID, escrowID);
	   aiPlanSetActive(planID);
   }
   
   return(planID);
}

//==============================================================================
//createNativeResearchPlan
//==============================================================================
int createNativeResearchPlan(int tacticID=cTacticNormal, int pri=50, int need=1, int want=5, int max=10)
{
   int buildingID = getUnit(cUnitTypeFirePit);
   int planID = -1;

   if (buildingID == -1)
   {
      aiEcho("createNativeResearchPlan aborting: no fire pit.");
      return(-1);
   }

   aiEcho("Creating native research plan for tactic ID "+tacticID);
   planID=aiPlanCreate("NativeResearch "+tacticID, cPlanNativeResearch);

   if (planID < 0)
   {
      aiEcho("Failed to create simple research plan for "+tacticID);
      return(-1);
   }
   else
   {
      aiPlanSetVariableInt(planID, cNativeResearchPlanTacticID, 0, tacticID);
      aiPlanSetVariableInt(planID, cNativeResearchPlanBuildingID, 0, buildingID);
      aiPlanSetDesiredPriority(planID, pri);
      //aiPlanSetEscrowID(planID, escrowID);
      aiPlanAddUnitType(planID, gEconUnit, need, want, max);
      aiPlanSetActive(planID);
   }
   return(planID);
}

//==============================================================================
//chooseConsulateFlag
//==============================================================================
void chooseConsulateFlag()
{
   int consulatePlanID = -1;
   int randomizer = aiRandInt(100); // 0-99
   int flag_button_id = -1;

   // Chinese options: Germans, French, Russians (HC level >= 25) & British (HC level >= 40)
   // Choice biased towards Russians
   if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
   {
      if (kbGetHCLevel(cMyID) < 25)
      {
         if (randomizer < 70) // 70 % probability
         {
            flag_button_id = cTechypBigConsulateBritish;
            //cvOkToBuildForts = true;
         }
         else // 30 % probability
         {
            flag_button_id = cTechypBigConsulateFrench;
         }
      }
      else if (kbGetHCLevel(cMyID) < 40)
      {
         if (randomizer < 60) // 60 % probability
         {
            flag_button_id = cTechypBigConsulateBritish;
            //cvOkToBuildForts = true;
         }
         else if (randomizer < 80) // 20 % probability
         {
            flag_button_id = cTechypBigConsulateBritish;
         }
         else // 20 % probability
         {
            flag_button_id = cTechypBigConsulateFrench;
         }
      }
      else // HC level >= 40
      {
         if (randomizer < 52) // 52 % probability
         {
            flag_button_id = cTechypBigConsulateRussians;
            cvOkToBuildForts = true;
         }
         else if (randomizer < 68) // 16 % probability
         {
            flag_button_id = cTechypBigConsulateBritish;
         }
         else if (randomizer < 84) // 16 % probability
         {
            flag_button_id = cTechypBigConsulateFrench;
         }
         else // 16 % probability
         {
            flag_button_id = cTechypBigConsulateGermans;
         }
      }
   }

   // Indian options: British, Portuguese, French (HC level >= 25) & Ottomans (HC level >= 40)
   // Choice biased towards Portuguese, especially on water maps
   if ((kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians))
   {
      if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)
      {
         if (kbGetHCLevel(cMyID) < 25)
         {
            if (randomizer < 80) // 80 % probability
            {
               flag_button_id = cTechypBigConsulatePortuguese;
            }
            else // 20 % probability
            {
               flag_button_id = cTechypBigConsulateBritish;
            }
         }
         else if (kbGetHCLevel(cMyID) < 40)
         {
            if (randomizer < 60) // 60 % probability
            {
               flag_button_id = cTechypBigConsulatePortuguese;
            }
            else if (randomizer < 80) // 20 % probability
            {
               flag_button_id = cTechypBigConsulateBritish;
            }
            else // 20 % probability
            {
               flag_button_id = cTechypBigConsulateFrench;
            }
         }
         else // HC level >= 40
         {
            if (randomizer < 52) // 52 % probability
            {
              flag_button_id = cTechypBigConsulatePortuguese;
            }
            else if (randomizer < 68) // 16 % probability
            {
               flag_button_id = cTechypBigConsulateBritish;
            }
            else if (randomizer < 84) // 16 % probability
            {
               flag_button_id = cTechypBigConsulateFrench;
            }
            else // 16 % probability
            {
               flag_button_id = cTechypBigConsulateOttomans;
               xsEnableRule("consulateLevy");
            }
         }
      }
      else // land map
      {
         if (kbGetHCLevel(cMyID) < 25)
         {
            if (randomizer < 60) // 60 % probability
            {
               flag_button_id = cTechypBigConsulatePortuguese;
            }
            else // 40 % probability
            {
               flag_button_id = cTechypBigConsulateBritish;
            }
         }
         else if (kbGetHCLevel(cMyID) < 40)
         {
            if (randomizer < 40) // 40 % probability
            {
               flag_button_id = cTechypBigConsulatePortuguese;
            }
            else if (randomizer < 70) // 30 % probability
            {
               flag_button_id = cTechypBigConsulateBritish;
            }
            else // 30 % probability
            {
               flag_button_id = cTechypBigConsulateFrench;
            }
         }
         else // HC level >= 40
         {
           if (randomizer < 40) // 40 % probability
           {
              flag_button_id = cTechypBigConsulatePortuguese;
            }
            else if (randomizer < 60) // 20 % probability
            {
               flag_button_id = cTechypBigConsulateBritish;
            }
            else if (randomizer < 80) // 20 % probability
            {
               flag_button_id = cTechypBigConsulateFrench;
            }
            else // 20 % probability
            {
               flag_button_id = cTechypBigConsulateOttomans;
               xsEnableRule("consulateLevy");
            }
         }
      }
   }

   // Japanese options: Isolation, Portuguese, Dutch (HC level >= 25) & Spanish (HC level >= 40)
   // Choice biased towards Portuguese on water maps, towards Dutch on land maps
   if ((kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapanese))
   {
      if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)
      {
         if (kbGetHCLevel(cMyID) < 25)
         {
            if (randomizer < 80) // 80 % probability
            {
               flag_button_id = cTechypBigConsulatePortuguese;
            }
            else // 20 % probability
            {
               flag_button_id = cTechypBigConsulateJapanese;
            }
         }
         else if (kbGetHCLevel(cMyID) < 40)
         {
            if (randomizer < 60) // 60 % probability
            {
               flag_button_id = cTechypBigConsulatePortuguese;
            }
            else if (randomizer < 80) // 20 % probability
            {
               flag_button_id = cTechypBigConsulateJapanese;
            }
            else // 20 % probability
            {
               flag_button_id = cTechypBigConsulateDutch;
            }
         }
         else // HC level >= 40
         {
            if (randomizer < 50) // 50 % probability
            {
              flag_button_id = cTechypBigConsulatePortuguese;
            }
            else if (randomizer < 65) // 15 % probability
            {
               flag_button_id = cTechypBigConsulateJapanese;
            }
            else if (randomizer < 85) // 20 % probability
            {
               flag_button_id = cTechypBigConsulateDutch;
            }
            else // 15 % probability
            {
               flag_button_id = cTechypBigConsulateSpanish;
            }
         }
      }
      else // land map
      {
         if (kbGetHCLevel(cMyID) < 25)
         {
            if (randomizer < 30) // 30 % probability
            {
               flag_button_id = cTechypBigConsulatePortuguese;
            }
            else // 70 % probability
            {
               flag_button_id = cTechypBigConsulateJapanese;
            }
         }
         else if (kbGetHCLevel(cMyID) < 40)
         {
            if (randomizer < 20) // 20 % probability
            {
               flag_button_id = cTechypBigConsulatePortuguese;
            }
            else if (randomizer < 40) // 20 % probability
            {
               flag_button_id = cTechypBigConsulateJapanese;
            }
            else // 60 % probability
            {
               flag_button_id = cTechypBigConsulateDutch;
            }
         }
         else // HC level >= 40
         {
            if (randomizer < 10) // 10 % probability
            {
               flag_button_id = cTechypBigConsulatePortuguese;
            }
            else if (randomizer < 30) // 20 % probability
            {
               flag_button_id = cTechypBigConsulateJapanese;
            }
            else if (randomizer < 80) // 50 % probability
            {
               flag_button_id = cTechypBigConsulateDutch;
            }
            else // 20 % probability
            {
               flag_button_id = cTechypBigConsulateSpanish;
            }
         }
      }
   }

   if (kbTechGetStatus(flag_button_id) == cTechStatusObtainable)
   {
      consulatePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, flag_button_id);
      if (consulatePlanID < 0) 
      {
         aiEcho("************Consulate Flag************");
         aiEcho("Our Consulate flag is: "+kbGetTechName(flag_button_id));
         aiEcho("Randomizer value: "+randomizer);
         createSimpleResearchPlan(flag_button_id, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 40);
         gFlagChosen = true;
      }
   }
}


void setConsulateArmyPreference() 
{
  if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateAlive) < 1) 
  {  return;  }

  if (kbTechGetStatus(cTechypBigConsulatePortuguese) == cTechStatusActive) {
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese1, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese2, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese3, 1.0);
  }
  
  if (kbTechGetStatus(cTechypBigConsulateDutch) == cTechStatusActive) {
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch1, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch2, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch3, 1.0);
  }
  
  if (kbTechGetStatus(cTechypBigConsulateRussians) == cTechStatusActive) {
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian1, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian2, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian3, 1.0);
  }
  
  if (kbTechGetStatus(cTechypBigConsulateSpanish) == cTechStatusActive) {
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish1, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish2, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish3, 1.0);
  }
  
  if (kbTechGetStatus(cTechypBigConsulateBritish) == cTechStatusActive) {
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish1, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish2, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish3, 1.0);      
  }
  
  if (kbTechGetStatus(cTechypBigConsulateFrench) == cTechStatusActive) {
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench1, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench2, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench3, 1.0); 
  }
  
  if (kbTechGetStatus(cTechypBigConsulateGermans) == cTechStatusActive) {
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman1, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman2, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman3, 1.0); 
  }
  
  if (kbTechGetStatus(cTechypBigConsulateOttomans) == cTechStatusActive) {
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman1, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman2, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman3, 1.0);
  }
  if (kbTechGetStatus(cTechypBigConsulateJapanese) == cTechStatusActive) {
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateYamabushi, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateShinobi, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateNinja, 1.0);
    kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateRonin, 1.0);
  }
}

void setStandardArmyPreference() 
{ /*
   if ( (gInitialStrategy == 0) && (kbGetAge() < cAge4) )
      return;
   if ( (gInitialStrategy == 2) && (kbGetAge() < cAge3) )
      return;
   if ( (gInitialStrategy == 3) && (kbGetAge() < cAge2) )
      return;
 */
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpColonialMilitia, 1.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, gLandPrimaryArmyUnit, 1.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, gLandSecondaryArmyUnit, 1.0);
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, gLandTertiaryArmyUnit, 1.0);
   //if ((kbUnitCount(cMyID, cUnitTypeSaloon, cUnitStateAlive) < 1) && (civIsEuropean() == true) && (kbGetAge() >= 5) && (kbResourceGet(cResourceGold) < 4000))
   //{
   //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercenary, 0.1);
   //}
   //kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, 0.05);
   if (kbGetAge() == cAge4)
   {
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.25);
   }   
   if (kbGetAge() == cAge5)
   {
   kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 1.0);
   }   
}

//==============================================================================
//createSimpleTrainPlan
//==============================================================================
int createSimpleTrainPlan(int puid=-1, int number=1, int escrowID=-1, int baseID=-1, int batchSize=1)
{
   //Create a the plan name.
   string planName="Simple";
   planName=planName+kbGetProtoUnitName(puid)+"Train";
   int planID=aiPlanCreate(planName, cPlanTrain);
   if (planID < 0)
     return(-1);

   // Escrow.
   aiPlanSetEscrowID(planID, escrowID);
   //Unit type.
   aiPlanSetVariableInt(planID, cTrainPlanUnitType, 0, puid);
   //Number.
   aiPlanSetVariableInt(planID, cTrainPlanNumberToTrain, 0, number);
   // Batch size
   aiPlanSetVariableInt(planID, cTrainPlanBatchSize, 0, batchSize);
	
   //If we have a base ID, use it.
   if (baseID >= 0)
   {
      aiPlanSetBaseID(planID, baseID);
      aiPlanSetVariableVector(planID, cTrainPlanGatherPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, baseID));
   }

   aiPlanSetActive(planID);

   //Done.
   return(planID);
} 
   
   
//==============================================================================
//createSimpleMaintainPlan
//==============================================================================
int createSimpleMaintainPlan(int puid=-1, int number=1, bool economy=true, int baseID=-1, int batchSize=1)
{
   //Create a the plan name.
   string planName="Military";
   if (economy == true)
      planName="Economy";
   planName=planName+kbGetProtoUnitName(puid)+"Maintain";
   int planID=aiPlanCreate(planName, cPlanTrain);
   if (planID < 0)
      return(-1);

   //Economy or Military.
   if (economy == true)
      aiPlanSetEconomy(planID, true);
   else
      aiPlanSetMilitary(planID, true);
   //Unit type.
   aiPlanSetVariableInt(planID, cTrainPlanUnitType, 0, puid);
   //Number.
   aiPlanSetVariableInt(planID, cTrainPlanNumberToMaintain, 0, number);
   // Batch size
   aiPlanSetVariableInt(planID, cTrainPlanBatchSize, 0, batchSize);

   //If we have a base ID, use it.
   if (baseID >= 0)
   {
      aiPlanSetBaseID(planID, baseID);
      if  (economy == false)
         aiPlanSetVariableVector(planID, cTrainPlanGatherPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, baseID));
   }
   
// aiPlanSetVariableBool(planID, cTrainPlanUseHomeCityShipments, 0, true);

   aiPlanSetActive(planID);

   //Done.
   return(planID);
} 

//==============================================================================
//int createSimpleMaintainPlanGivenBuilding
//==============================================================================
int createSimpleMaintainPlanGivenBuilding(int puid=-1, int number=1, bool economy=true, int baseID=-1, int batchSize=1, int buildingID=-1)
{
   //Create the plan name.
   string planName="Military";
   if (economy == true)
      planName="Economy";
   planName=planName+kbGetProtoUnitName(puid)+"Maintain";
   int planID=aiPlanCreate(planName, cPlanTrain);
   if (planID < 0)
      return(-1);

   //Economy or Military.
   if (economy == true)
      aiPlanSetEconomy(planID, true);
   else
      aiPlanSetMilitary(planID, true);
   //Unit type.
   aiPlanSetVariableInt(planID, cTrainPlanUnitType, 0, puid);
   //Number.
   aiPlanSetVariableInt(planID, cTrainPlanNumberToMaintain, 0, number);
   // Batch size
   aiPlanSetVariableInt(planID, cTrainPlanBatchSize, 0, batchSize);
	//Building
   aiPlanSetVariableInt(planID, cTrainPlanBuildingID, 0, buildingID);

   //If we have a base ID, use it.
   if (baseID >= 0)
   {
      aiPlanSetBaseID(planID, baseID);
      if  (economy == false)
         aiPlanSetVariableVector(planID, cTrainPlanGatherPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, baseID));
   }
   
   //aiPlanSetVariableBool(planID, cTrainPlanUseHomeCityShipments, 0, true);

   aiPlanSetActive(planID);

   //Done.
   return(planID);
} 
//==============================================================================
//int createSimpleLocationQuery
//==============================================================================
int createSimpleLocationQuery(int playerRelationOrID=cMyID, int unitTypeID=-1, int state=cUnitStateAlive, vector location=cInvalidVector, float radius=20.0)
{
    static int unitQueryID=-1;
    //If we don't have the query yet, create one.
    if (unitQueryID < 0)
    {
	unitQueryID=kbUnitQueryCreate("miscGetUnitQuery");
	kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
    }

    //Define a query to get all matching units
    if (unitQueryID != -1)  //if unitQueryID=-1, query creation fails.
    {
        if (playerRelationOrID > 1000)      // Too big for player ID number
	{
	  kbUnitQuerySetPlayerID(unitQueryID, -1);  // Clear the player ID, so playerRelation takes precedence.
	  kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
	}
	else
	{
	  kbUnitQuerySetPlayerRelation(unitQueryID, -1);
	  kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
	}
	kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
	kbUnitQuerySetState(unitQueryID, state);
	if ( (location != cInvalidVector) && (radius > 0.0) )
	{
	   kbUnitQuerySetPosition(unitQueryID, location);
	   kbUnitQuerySetMaximumDistance(unitQueryID, radius);
	}
		
    }

    return(unitQueryID);
}

//==============================================================================
//int createSimpleQuery
//==============================================================================
int createSimpleQuery(int playerRelationOrID=cMyID, int unitTypeID=-1, int state=cUnitStateAlive)
{
   static int unitQueryID=-1;
   //If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID=kbUnitQueryCreate("miscGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }

   //Define a query to get all matching units
   if (unitQueryID != -1)  //if unitQueryID=-1, query creation fails.
   {
     if (playerRelationOrID > 1000)      // Too big for player ID number
     {
	kbUnitQuerySetPlayerID(unitQueryID, -1);  // Clear the player ID, so playerRelation takes precedence.
	kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
     }
     else
     {
	kbUnitQuerySetPlayerRelation(unitQueryID, -1);
        kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
     }
     kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
     kbUnitQuerySetState(unitQueryID, state);
   }
   return(unitQueryID);
}
//==============================================================================
//createSimpleBuildPlan
//==============================================================================
int createSimpleBuildPlan(int puid=-1, int number=1, int pri=100, bool economy=true, int escrowID=-1, int baseID=-1, int numberBuilders=1)
{
   if (cvOkToBuild == false)
      return(-1);

   int builderType = gEconUnit;
   //Create the right number of plans.
   for (i=0; < number)
   {
	   int planID=aiPlanCreate("Simple Build Plan, "+number+" "+kbGetUnitTypeName(puid), cPlanBuild);
      if (planID < 0)
         return(-1);
      // What to build
      aiPlanSetVariableInt(planID, cBuildPlanBuildingTypeID, 0, puid);

      // 6 meter separation
      aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 6.0);
      if (puid == gFarmUnit)
         aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 1.0);       
      if (puid == gPlantationUnit)
         aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 1.0);
      if (puid == cUnitTypeBank)
         aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 1.0);
      if (puid  == cUnitTypeypShrineJapanese)
         aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 1.0);
      //Priority.
      aiPlanSetDesiredPriority(planID, pri);
      //Mil vs. Econ.
      if (economy == true)
         aiPlanSetMilitary(planID, false);
      else
         aiPlanSetMilitary(planID, true);
      aiPlanSetEconomy(planID, economy);
      //Escrow.
      aiPlanSetEscrowID(planID, escrowID);
      //Builders.
      if (civIsAsian() == true) 
      {
        if (puid  == gFarmUnit)
        {
             if (kbUnitCount(cMyID, cUnitTypeYPRicePaddyWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPRicePaddyWagon;
        }
        if (puid  == gMarketUnit)
        {
             if (kbUnitCount(cMyID, cUnitTypeypMarketWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeypMarketWagon;
        }
        if (puid  == cUnitTypeypShrineJapanese)
        {
             if (kbUnitCount(cMyID, cUnitTypeypShrineWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeypShrineWagon;
        }
        if (puid  == cUnitTypeypMonastery) 
        {
             if (kbUnitCount(cMyID, cUnitTypeYPMonasteryWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPMonasteryWagon;
        }
        if (puid  == cUnitTypeypBerryBuilding) 
        {
            builderType = cUnitTypeYPBerryWagon1;
        }
        if (puid  == cUnitTypeTradingPost) 
        {
             if (kbUnitCount(cMyID, cUnitTypeypTradingPostWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeypTradingPostWagon;
             if (kbUnitCount(cMyID, cUnitTypeTradingPostTravois, cUnitStateAlive) > 0)
                builderType = cUnitTypeTradingPostTravois;
        }
        if (puid  == cUnitTypeypBarracksJapanese)
        {
             if (kbUnitCount(cMyID, cUnitTypeYPMilitaryRickshaw, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPMilitaryRickshaw;
        }
        if (puid  == cUnitTypeypStableJapanese) 
        {
             if (kbUnitCount(cMyID, cUnitTypeYPMilitaryRickshaw, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPMilitaryRickshaw;
        }
        if (puid  == cUnitTypeypDojo) 
        {
             if (kbUnitCount(cMyID, cUnitTypeYPDojoWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPDojoWagon;
        }
        if (puid  == cUnitTypeypTradeMarketAsian) 
        {
             if (kbUnitCount(cMyID, cUnitTypeypMarketWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeypMarketWagon;
        }
        if (puid  == cUnitTypeypSacredField) 
        {
             if (kbUnitCount(cMyID, cUnitTypeYPSacredFieldWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPSacredFieldWagon;
        }
      }
      if (puid == gDockUnit)
      {
        if (kbUnitCount(cMyID, cUnitTypeYPDockWagon, cUnitStateAlive) > 0)
          builderType = cUnitTypeYPDockWagon;
      }
      // Dutch can use bank wagon
      if ((kbGetCiv() == cCivDutch) && (puid == cUnitTypeBank))
      {
        if (kbUnitCount(cMyID, cUnitTypeBankWagon, cUnitStateAlive) > 0)
          builderType = cUnitTypeBankWagon;
      }
    
      // Germans use settler wagons if there are no settlers or builder wagons available
      if ((kbGetCiv() == cCivGermans) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) < 1) && (builderType == gEconUnit))
      {  aiPlanAddUnitType(planID, cUnitTypeSettlerWagon, numberBuilders, numberBuilders, numberBuilders);  }
      else
      {  aiPlanAddUnitType(planID, builderType, numberBuilders, numberBuilders, numberBuilders);  }
      
      //Base ID.
      aiPlanSetBaseID(planID, baseID);

      //Go.
      aiPlanSetActive(planID);
   }
   return(planID);   // Only really useful if number == 1, otherwise returns last value.
}

//==============================================================================
// createBuildBuildingGoal
//==============================================================================
int createBuildBuildingGoal(string name="BUG", int buildingTypeID=-1, int repeat=-1,
    int minAge=-1, int maxAge=-1, int baseID=-1, int numberUnits=1, int builderUnitTypeID=-1,
    bool autoUpdate=true, int pri=90, int buildingPlacementID = -1)
{
    aiEcho("CreateBuildBuildingGoal:  Name="+name+", BuildingType="+kbGetUnitTypeName(buildingTypeID)+".");
    aiEcho("  Repeat="+repeat+", MinAge="+minAge+", maxAge="+maxAge+".");

    //Create the goal.
    int goalID=aiPlanCreate(name, cPlanGoal);
    if (goalID < 0)
        return(-1);

    //Goal Type.
    aiPlanSetVariableInt(goalID, cGoalPlanGoalType, 0, cGoalPlanGoalTypeBuilding);
    //Base ID.    
    aiPlanSetBaseID(goalID, baseID);    
    //Auto update.
    aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateState, 0, autoUpdate);
    //Building Type ID.
    aiPlanSetVariableInt(goalID, cGoalPlanBuildingTypeID, 0, buildingTypeID);
    //Building Placement ID.
    aiPlanSetVariableInt(goalID, cGoalPlanBuildingPlacementID, 0, buildingPlacementID);
    //Set the builder parms.
    aiPlanSetVariableInt(goalID, cGoalPlanMinUnitNumber, 0, 1);
    aiPlanSetVariableInt(goalID, cGoalPlanMaxUnitNumber, 0, numberUnits);
    aiPlanSetVariableInt(goalID, cGoalPlanUnitTypeID, 0, builderUnitTypeID);
   
    //Priority.
    aiPlanSetDesiredPriority(goalID, pri);
    //Ages.
    aiPlanSetVariableInt(goalID, cGoalPlanMinAge, 0, minAge);
    aiPlanSetVariableInt(goalID, cGoalPlanMaxAge, 0, maxAge);
    //Repeat.
    aiPlanSetVariableInt(goalID, cGoalPlanRepeat, 0, repeat);

    //Done.
    return(goalID);
}


//==============================================================================
//createLocationBuildPlan
//==============================================================================
int createLocationBuildPlan(int puid=-1, int number=1, int pri=100, bool economy=true, int escrowID=-1, vector position=cInvalidVector, int numberBuilders=1)
{
   if (cvOkToBuild == false)
      return(-1);

   int builderType = gEconUnit;
   //Create the right number of plans.
   for (i=0; < number)
   {
      int planID=aiPlanCreate("Location Build Plan, "+number+" "+kbGetUnitTypeName(puid), cPlanBuild);
      if (planID < 0)
         return(-1);
      // What to build
      aiPlanSetVariableInt(planID, cBuildPlanBuildingTypeID, 0, puid);

      aiPlanSetVariableVector(planID, cBuildPlanCenterPosition, 0, position);
      aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 100.0);
      
      // 6 meter separation
      aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 3.0);
      if (puid == gFarmUnit)
         aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 8.0);  

      //Priority.
      aiPlanSetDesiredPriority(planID, pri);
      //Mil vs. Econ.
      if (economy == true)
         aiPlanSetMilitary(planID, false);
      else
         aiPlanSetMilitary(planID, true);
      aiPlanSetEconomy(planID, economy);
      //Escrow.
      aiPlanSetEscrowID(planID, escrowID);
      //Builders.
      if (puid  == cUnitTypeTradingPost)
      {
         if (kbUnitCount(cMyID, cUnitTypeypTradingPostWagon, cUnitStateAlive) > 0)
           builderType = cUnitTypeypTradingPostWagon;
         if (kbUnitCount(cMyID, cUnitTypeTradingPostTravois, cUnitStateAlive) > 0)
           builderType = cUnitTypeTradingPostTravois;
      }
      // Explorers, war chiefs and monks build town centers
      if (puid == cUnitTypeTownCenter)
      {
         switch(kbGetCiv())
         {
            case cCivXPAztec:
            {
               aiPlanAddUnitType(planID, cUnitTypexpAztecWarchief, 1, 1, 1);
               aiPlanAddUnitType(planID, builderType, 1, 2, 4);
               break;
            }
            case cCivXPIroquois:
            {
               aiPlanAddUnitType(planID, cUnitTypexpIroquoisWarChief, 1, 1, 1);
               aiPlanAddUnitType(planID, builderType, 1, 2, 4);
               break;
            }
            case cCivXPSioux:
            {
               aiPlanAddUnitType(planID, cUnitTypexpLakotaWarchief, 1, 1, 1);
               aiPlanAddUnitType(planID, builderType, 1, 2, 4);
               break;
            }
            case cCivChinese:
            {
               aiPlanAddUnitType(planID, cUnitTypeypMonkChinese, 1, 1, 1);
               aiPlanAddUnitType(planID, builderType, 1, 2, 4);
               break;
            }
            case cCivIndians:
            {
               aiPlanAddUnitType(planID, cUnitTypeypMonkIndian, 1, 1, 1);
               aiPlanAddUnitType(planID, cUnitTypeypMonkIndian2, 1, 1, 1);
               aiPlanAddUnitType(planID, builderType, 1, 2, 4);
               break;
            }
            case cCivJapanese:
            {
               aiPlanAddUnitType(planID, cUnitTypeypMonkJapanese, 1, 1, 1);
               aiPlanAddUnitType(planID, cUnitTypeypMonkJapanese2, 1, 1, 1);
               aiPlanAddUnitType(planID, builderType, 1, 2, 4);
               break;
            }
            default:
            {
               aiPlanAddUnitType(planID, cUnitTypeExplorer, 1, 1, 1);
               break;
            }
         }
      }
      else
      {
         // Germans use settler wagons if there are no settlers or builder wagons available
         if ((kbGetCiv() == cCivGermans) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) < 1) && (builderType == gEconUnit))
         {
            aiPlanAddUnitType(planID, cUnitTypeSettlerWagon, numberBuilders, numberBuilders, numberBuilders);
         }
         else
         {
	     aiPlanAddUnitType(planID, builderType, numberBuilders, numberBuilders, numberBuilders);
         }
      }
      aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0, position);    // Influence toward position
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 100.0);     // 100m range.
      aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 200.0);        // 200 points max
      aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff

      //Go.
      aiPlanSetActive(planID);
   }
   return(planID);   // Only really useful if number == 1, otherwise returns last value.
}

//==============================================================================
// createMainBase
//==============================================================================
int createMainBase(vector mainVec=cInvalidVector)
{
   aiEcho("Creating main base at "+mainVec);
   if (mainVec == cInvalidVector)  
      return(-1);
   
   int oldMainID = kbBaseGetMainID(cMyID);
   int i = 0;
   
   int count=-1;
   static int unitQueryID=-1;
   int buildingID = -1;
   string buildingName = "";
   if (unitQueryID < 0)
   {
      unitQueryID=kbUnitQueryCreate("NewMainBaseBuildingQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
   }

	//Define a query to get all matching units
	if (unitQueryID != -1)
	{
      kbUnitQuerySetPlayerRelation(unitQueryID, -1);
   	kbUnitQuerySetPlayerID(unitQueryID, cMyID);

      kbUnitQuerySetUnitType(unitQueryID, cUnitTypeBuilding);
      kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
      kbUnitQuerySetPosition(unitQueryID, mainVec);      // Checking new base vector
      kbUnitQuerySetMaximumDistance(unitQueryID, 200.0);
	}
   
   kbUnitQueryResetResults(unitQueryID);
   count = kbUnitQueryExecute(unitQueryID);

     

   while (oldMainID >= 0)
   {
      aiEcho("Old main base was "+oldMainID+" at "+kbBaseGetLocation(cMyID, oldMainID));
      kbUnitQuerySetPosition(unitQueryID,kbBaseGetLocation(cMyID, oldMainID));      // Checking old base location
      kbUnitQueryResetResults(unitQueryID);
      count = kbUnitQueryExecute(unitQueryID);
      int unitID = -1;
      
     
      // Remove old base's resource breakdowns
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, oldMainID);
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, oldMainID);
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, oldMainID);
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHuntAggressive, oldMainID);
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, oldMainID);
      aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, oldMainID);
      aiRemoveResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, oldMainID);
      aiRemoveResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, oldMainID);

      kbBaseDestroy(cMyID, oldMainID);
      oldMainID = kbBaseGetMainID(cMyID);
   }


   int newBaseID=kbBaseCreate(cMyID, "Base"+kbBaseGetNextID(), mainVec, 200.0);
   aiEcho("New main base ID is "+newBaseID);
   if (newBaseID > -1)
   {
      //Figure out the front vector.
      vector baseFront=xsVectorNormalize(kbGetMapCenter()-mainVec);
      kbBaseSetFrontVector(cMyID, newBaseID, baseFront);
      aiEcho("Setting front vector to "+baseFront);
      //Military gather point.
      float milDist = 40.0;
      while (  kbAreaGroupGetIDByPosition(mainVec+(baseFront*milDist)) != kbAreaGroupGetIDByPosition(mainVec) )
      {
         milDist = milDist - 5.0;
         if (milDist < 6.0)
            break;
      }
      vector militaryGatherPoint = mainVec + (baseFront * milDist);
      
      kbBaseSetMilitaryGatherPoint(cMyID, newBaseID, militaryGatherPoint);
      //Set the other flags.
      kbBaseSetMilitary(cMyID, newBaseID, true);
      kbBaseSetEconomy(cMyID, newBaseID, true);
      //Set the resource distance limit.
      

      // 200m x 200m map, assume I'm 25 meters in, I'm 150m from enemy base.  This sets the range at 80m.
      //(cMyID, newBaseID, (kbGetMapXSize() + kbGetMapZSize())/5);   // 40% of average of map x and z dimensions.
      kbBaseSetMaximumResourceDistance(cMyID, newBaseID, 100.0); // 100 led to age-2 gold starvation
      kbBaseSetSettlement(cMyID, newBaseID, true);
      //Set the main-ness of the base.
      kbBaseSetMain(cMyID, newBaseID, true);
      
      // Add the TC, if any.
      if (getUnit(cUnitTypeTownCenter, cMyID, cUnitStateABQ) >= 0)
         kbBaseAddUnit(cMyID, newBaseID, getUnit(cUnitTypeTownCenter, cMyID, cUnitStateABQ));
   }
   
   
   // Move the defend plan and reserve plan
   xsEnableRule("endDefenseReflexDelay"); // Delay so that new base ID will exist
   
//   xsEnableRule("populateMainBase");   // Can't add units yet, they still appear to be owned by deleted base.  This rule adds a slight delay.

   return(newBaseID);
}
 

//==============================================================================
// getAllyCount() // Returns number of allies EXCLUDING self
//==============================================================================
int getAllyCount()
{
   int retVal = 0;
   
   int player = 0;
   for (player=1; < cNumberPlayers)
   {
      if (player == cMyID)
         continue;
      
      if (kbIsPlayerAlly(player) == true)
         retVal = retVal + 1;
   }
   
   return(retVal);
}
 


//==============================================================================
// getEnemyCount() // Returns number of enemies excluding gaia
//==============================================================================
int getEnemyCount()
{
   int retVal = 0;
   
   int player = 0;
   for (player=1; < cNumberPlayers)
   {
      if (player == cMyID)
         continue;
      
      if (kbIsPlayerEnemy(player) == true)
         retVal = retVal + 1;
   }
   
   return(retVal);
}

//==============================================================================
// arraySortFloat
/*
   Takes two arrays, the source and the target.
   Source has the original values, and is a float array.
   Target (int array) will receive the indexes into source in descending order.  For example,
   if the highest value in source is source[17] with a value of 91, then
   arraySort(source, target) will assign target[0] the value of 17, and 
   source[target[0]] will be 91.

*/
//==============================================================================
bool arraySortFloat(int sourceArray=-1, int targetArray=-1)
{
   int pass = 0;
   int i = 0; 
   int size = xsArrayGetSize(sourceArray);
   if (size != xsArrayGetSize(targetArray))
   {
      aiEcho("ArraySort error, source and target are not of same size.");
      return(false);
   }
   
   float highestScore = 1000000.0;  // Highest score found on previous pass
   float highScore = -1000000.0;    // Highest score found on this pass
   int highestScoreIndex = -1;      // Which element had the high score last pass?
   int highScoreIndex = -1;         // Which element has the highest score so far this pass?
   for (pass=0; < size)             // Sort the array
   {
      highScore = -1000000.0;
      highScoreIndex = -1;
      for (i=0; < size)   // Look for highest remaining value
      {
         if ( xsArrayGetFloat(sourceArray, i) > highestScore ) // We're over the highest score, already been selected.  Skip.
            continue;

         if ( (xsArrayGetFloat(sourceArray, i) == highestScore) && (highestScoreIndex >= i) ) // Tie with a later one, we've been selected.  Skip.
            continue;

         if ( xsArrayGetFloat(sourceArray, i) <= highScore ) // We're not the highest so far on this pass, skip.
            continue;
         
         highScore = xsArrayGetFloat(sourceArray, i);    // This is the highest score this pass
         highScoreIndex = i;                                // So remember this index
      }
//      if(xsArrayGetString(gMissionStrings, highScoreIndex) != " ")
//         aiEcho("        "+highScoreIndex+" "+highScore+" "+xsArrayGetString(gMissionStrings,highScoreIndex));
      xsArraySetInt(targetArray, pass, highScoreIndex);
      highestScore = highScore;           // Save this for next pass
      highestScoreIndex = highScoreIndex;
   }
   return(true);
}









//==============================================================================
// getRandomPlayerByRelation
/*
   Returns a randomly selected ally or enemy.

*/
//==============================================================================
int getRandomPlayerByRelation(int playerRelation = -1)
{
   int retVal = -1;
   int matchCount = -1;    // I.e. there are 3 matching players
   int matchIndex = -1;    // Used for traversal
   int playerToGet = -1;   // i.e. get the 2nd matching player
   
   
   // Get a count of matching players
   matchCount = 0;
   for (matchIndex = 1; < cNumberPlayers)
   {
      if ( (playerRelation == cPlayerRelationAlly) && (kbIsPlayerAlly(matchIndex) == true) && (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
      if ( ( (playerRelation == cPlayerRelationEnemy) || (playerRelation == cPlayerRelationEnemyNotGaia) ) && (kbIsPlayerEnemy(matchIndex) == true) && (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
      if ( (playerRelation == cPlayerRelationSelf) && (cMyID == matchIndex) && (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
   }
   
   if (matchCount < 1)
      return(-1);
   
   playerToGet = aiRandInt(matchCount) + 1;  // If there are 3 matches, return 1, 2 or 3
   
   // Traverse the list again, and get the matching player.
   matchCount = 0;
   for (matchIndex = 1; < cNumberPlayers)
   {
      if ( (playerRelation == cPlayerRelationAlly) && (kbIsPlayerAlly(matchIndex) == true) && (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
      if ( ( (playerRelation == cPlayerRelationEnemy) || (playerRelation == cPlayerRelationEnemyNotGaia) )&& (kbIsPlayerEnemy(matchIndex) == true) && (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
      if ( (playerRelation == cPlayerRelationSelf) && (cMyID == matchIndex) && (kbHasPlayerLost(matchIndex) == false))
         matchCount = matchCount + 1;
      
      if (matchCount == playerToGet)
      {
         retVal = matchIndex;    // Save this player's number
         break;
      }
   }
   
   return(retVal);
}


//==============================================================================
// getTeamPosition
/*
   Returns the player's position in his/her team, i.e. in a 123 vs 456 game, 
   player 5's team position is 2, player 3 is 3, player 4 is 1.

   Excludes resigned players.

*/
//==============================================================================
int getTeamPosition(int playerID = -1)
{
   int index = -1;    // Used for traversal
   int playerToGet = -1;   // i.e. get the 2nd matching playe
   
   // Traverse list of players, increment when we find a teammate, return when we find my number.
   int retVal = 0;      // Zero if I don't exist...
   for (index = 1; < cNumberPlayers)
   {
      if ( (kbHasPlayerLost(index) == false) && (kbGetPlayerTeam(playerID) == kbGetPlayerTeam(index)) )
         retVal = retVal + 1; // That's another match
      
      if ( index == playerID )
         return(retVal);
   }
   return(-1);
}


//==============================================================================
// getEnemyPlayerByTeamPosition
/*
   Returns the ID of the Nth player on the enemy team, returns -1 if 
   there aren't that many players.

   Excludes resigned players.
*/

int getEnemyPlayerByTeamPosition(int position = -1)
{

   int matchCount = 0;
   int index = -1;    // Used for traversal
   int playerToGet = -1;   // i.e. get the 2nd matching playe
   
   // Traverse list of players, return when we find the matching player
   for (index = 1; < cNumberPlayers)
   {
      if ( (kbHasPlayerLost(index) == false) && (kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(index)) )
         matchCount = matchCount + 1; // Enemy player, add to the count
      
      if ( matchCount == position )
         return(index);
   }
   return(-1);
}



//==============================================================================
// getClosestVPSite
/*
   Returns the VPSiteID of the closest VP Site that matches the parms.
   -1 means don't care, everything matches.
   To get the closest site that has been claimed (building or complete) by an enemy,
   use cVPStateAny with playerRelationOrID set to cPlayerRelationEnemy.  (Unbuilt ones have gaia ownership)
*/
//==============================================================================
int getClosestVPSite(vector location=cInvalidVector, int type=cVPAll, int state=cVPStateAny, int playerRelationOrID=-1)
{
   int retVal = -1;
   int vpList = kbVPSiteQuery(type, playerRelationOrID, state);
   vector siteLocation = cInvalidVector;
   int count = xsArrayGetSize(vpList);
   int index = 0;
   int siteID = 0;
   float dist = 0.0;
   float minDist = 100000.0;
   
   for (index = 0; < count)
   {
      siteID = xsArrayGetInt(vpList, index);
      siteLocation = kbVPSiteGetLocation(siteID);
      dist = distance(location, siteLocation);
      if (dist < minDist)
      {
         retVal = siteID;  // Remember this one.
         minDist = dist;
      }
   }
  
   return(retVal);
}

//==============================================================================
// chooseAttackPlayerID
/*
   Given a point/radius, look for enemy units, and choose the owner of one
   as an appropriate player to attack.

   If none found, return mostHatedEnemy.
*/
//==============================================================================
int chooseAttackPlayerID(vector point=cInvalidVector, float radius = 50.0)
{
   int retVal = aiGetMostHatedPlayerID();
   static int queryID = -1;
   
   if (point == cInvalidVector)
      return(retVal);
   
   if (queryID < 0)
   {
      queryID = kbUnitQueryCreate("Choose attack player");
      kbUnitQuerySetPlayerRelation(queryID, cPlayerRelationEnemyNotGaia);   // Any enemy units in point/radius
      kbUnitQuerySetIgnoreKnockedOutUnits(queryID, true);
      kbUnitQuerySetUnitType(queryID, cUnitTypeUnit);
      kbUnitQuerySetState(queryID, cUnitStateAlive);
   }
   kbUnitQuerySetPosition(queryID, point);
   kbUnitQuerySetMaximumDistance(queryID, radius);
   kbUnitQueryResetResults(queryID);
   int count = kbUnitQueryExecute(queryID);
   int index = 0;
   int unitID = 0;
   for (index = 0; < count)
   {
      unitID = kbUnitQueryGetResult(queryID, index);
      if (kbUnitGetPlayerID(unitID) > 0)  // Not Gaia
      {
         retVal = kbUnitGetPlayerID(unitID);  // Owner of first (random) non-gaia unit
         break;
      }
   }
   
   return(retVal);
}


//==============================================================================
// New functions for the Draugur AI
//==============================================================================

//==============================================================================
// chooseEuropeanPolitician()
// Chooses non-revolutionary age-up politicians for European civilizations
//==============================================================================
int chooseEuropeanPolitician()
{
   int position = 0;
   int randomizer = -1;
   int numChoices = -1;
   int politician = -1;
   int bestChoice = 0;
   int bestScore = 0;

   // Reset score array
   for (i=0; <6)
      xsArraySetInt(gPoliticianScores, i, 0);

   // Choose politician
   switch (kbGetAge())
   {
      case cAge1:
      {  // Governor for turtler, resources or settlers for rusher, biased against the Naturalist
         randomizer = aiRandInt(10); // 0-9

         // Create array of politicians to choose from
         for (i=0; <6)
         {
             politician = xsArrayGetInt(gAge2PoliticianList, i);
             if (kbTechGetStatus(politician) == cTechStatusObtainable)
             {
                xsArraySetInt(gAgeUpPoliticians, position, politician);
                position = position + 1;
             }
         }

         // Weight politicians as appropriate
         numChoices = position;
         for (i=0; <numChoices)
         {
            politician = xsArrayGetInt(gAgeUpPoliticians, i);
            if ((gInitialStrategy == 0) || (gInitialStrategy >=2))
            {
               if (politician == cTechPoliticianQuartermaster)
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 100);
               }
            }
            if (gInitialStrategy == 1)
            {
               if (politician == cTechPoliticianQuartermaster)
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 100);
               }
            }     
            if (randomizer < 100)
            {
               if (politician == cTechPoliticianNaturalist)
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) - 100);
               }
            }
         }
         // Add random bonus
         randomizer = aiRandInt(numChoices);
         xsArraySetInt(gPoliticianScores, randomizer, xsArrayGetInt(gPoliticianScores, randomizer) + 5);

         // Choose politician with best score
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gPoliticianScores, i);
               bestChoice = i;
            }
         }
         politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
         break;
      }
      case cAge2:
      {  // Randomized, but biased towards Admiral or Pirate for water maps
         randomizer = aiRandInt(10); // 0-9

         // Create array of politicians to choose from
         for (i=0; <16)
         {
             politician = xsArrayGetInt(gAge3PoliticianList, i);
             if (kbTechGetStatus(politician) == cTechStatusObtainable)
             {
                xsArraySetInt(gAgeUpPoliticians, position, politician);
                position = position + 1;
             }
         }

         // Weight politicians as appropriate
         numChoices = position;
         for (i=0; <numChoices)
         {
            politician = xsArrayGetInt(gAgeUpPoliticians, i);
            if ((gInitialStrategy == 0) || (gInitialStrategy >=2))
            {
               if (politician == cTechPoliticianExiledPrince)
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 20);
               }
            }
            if ((cRandomMapName == "amazonia") ||
                (cRandomMapName == "caribbean") ||
                (cRandomMapName == "Ceylon") ||
                ((randomizer < 5) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)))
            {
               if ((politician == cTechPoliticianAdmiral) ||
                   (politician == cTechPoliticianAdmiralOttoman) ||
                   (politician == cTechPoliticianPirate))
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
               }
            }
            if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) == 0)
            {
               if ((politician == cTechPoliticianAdmiral) ||
                   (politician == cTechPoliticianAdmiralOttoman) ||
                   (politician == cTechPoliticianPirate))
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) - 10);
               }
            }
         }
         // Add random bonus
         randomizer = aiRandInt(numChoices);
         xsArraySetInt(gPoliticianScores, randomizer, xsArrayGetInt(gPoliticianScores, randomizer) + 5);

         // Choose politician with best score
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gPoliticianScores, i);
               bestChoice = i;
            }
         }
         politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
         break;
      }
      case cAge3:
      {  // Randomized, but biased towards the Engineer
         randomizer = aiRandInt(10); // 0-9

         // Create array of politicians to choose from
         for (i=0; <24)
         {
             politician = xsArrayGetInt(gAge4PoliticianList, i);
             if (kbTechGetStatus(politician) == cTechStatusObtainable)
             {
                xsArraySetInt(gAgeUpPoliticians, position, politician);
                position = position + 1;
             }
         }

         // Weight politicians as appropriate
         numChoices = position;
         for (i=0; <numChoices)
         {
            politician = xsArrayGetInt(gAgeUpPoliticians, i);
            if (politician == cTechPoliticianTycoon)
            {
               xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 15);
            }
            if (randomizer < 3)
            {
               if ((politician == cTechPoliticianEngineer) ||
                   (politician == cTechPoliticianGrandVizier) ||
                   (politician == cTechPoliticianEngineerPortuguese))
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
               }
            }
         }
         // Add random bonus
         randomizer = aiRandInt(numChoices);
         xsArraySetInt(gPoliticianScores, randomizer, xsArrayGetInt(gPoliticianScores, randomizer) + 5);

         // Choose politician with best score
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gPoliticianScores, i);
               bestChoice = i;
            }
         }
         politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
         break;
      }
      case cAge4:
      {  // Randomized, but heavily biased towards the General
         randomizer = aiRandInt(10); // 0-9

         // Create array of politicians to choose from
         for (i=0; <5)
         {
             politician = xsArrayGetInt(gAge5PoliticianList, i);
             if (kbTechGetStatus(politician) == cTechStatusObtainable)
             {
                xsArraySetInt(gAgeUpPoliticians, position, politician);
                position = position + 1;
             }
         }

         // Weight politicians as appropriate
         numChoices = position;
         for (i=0; <numChoices)
         {
            politician = xsArrayGetInt(gAgeUpPoliticians, i);
            if (randomizer < 3)
            {
               if ((politician == cTechPoliticianGeneral) ||
                   (politician == cTechPoliticianGeneralBritish) ||
                   (politician == cTechPoliticianGeneralOttoman) ||
                   (politician == cTechPoliticianGeneralSkirmisher))
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
               }
            }
            else
            {
               if (politician == cTechPoliticianPresidente)
               {
                  xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
               }
            }
         }

         // Choose politician with best score
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gPoliticianScores, i);
               bestChoice = i;
            }
         }
         politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
         break;
      }
   }

   aiEcho("Chosen age-up politician: "+kbGetTechName(politician));
   return(politician);
}


//==============================================================================
// chooseNativeCouncilMember()
// Chooses age-up council members for native civilizations
//==============================================================================
int chooseNativeCouncilMember()
{
   int randomizer = -1;
   int numChoices = -1;
   int politician = -1;
   int bestChoice = 0;
   int bestScore = 0;

   for (i=0; <6)
      xsArraySetInt(gNatCouncilScores, i, 0);   // reset array

   switch (kbGetAge())
   {
      case cAge1:
      {  // Iroquois chief, Sioux wise woman, Aztec shaman, and all messengers to be avoided if possible
         numChoices = aiGetPoliticianListCount(cAge2);
         for (i=0; <numChoices)
         {  
            politician = aiGetPoliticianListByIndex(cAge2, i);
            if (((politician == cTechTribalSiouxShaman2) ||                 
                 (politician == cTechTribalIroquoisWisewoman2)) && 
                ((gInitialStrategy == 0) || (gInitialStrategy >= 2)) )
            {
               xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + 10);
            }
                       
            if (((politician == cTechTribalSiouxChief2) ||
                 (politician == cTechTribalAztecShaman2)) && (gInitialStrategy == 1))
            {
               xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + 10);
            }                        
         }        
         randomizer = aiRandInt(numChoices);
         xsArraySetInt(gNatCouncilScores, randomizer, xsArrayGetInt(gNatCouncilScores, randomizer) + 5);
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gNatCouncilScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge2, bestChoice);
         break;
      }
      case cAge2:
      {  // Iroquois chief, Sioux wise woman, Aztec shaman, and all messengers to be avoided if possible
         numChoices = aiGetPoliticianListCount(cAge3);
         for (i=0; <numChoices)
         {
            politician = aiGetPoliticianListByIndex(cAge3, i);
            if (((politician == cTechTribalSiouxYouth3) ||
                (politician == cTechTribalAztecYouth3) ||
                (politician == cTechTribalIroquoisYouth3)) && 
               ((gInitialStrategy == 0)||(gInitialStrategy >= 2)) )
            {
               xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + 10);
            }
            xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + aiRandInt(10));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gNatCouncilScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge3, bestChoice);
         break;
      }
      case cAge3:
      {  // Iroquois chief, Sioux wise woman, Aztec shaman, and all messengers to be avoided if possible
         numChoices = aiGetPoliticianListCount(cAge4);
         for (i=0; <numChoices)
         {
            politician = aiGetPoliticianListByIndex(cAge4, i);
            if ((politician == cTechTribalIroquoisChief4) ||
                //(politician == cTechTribalSiouxWisewoman4) ||
                (politician == cTechTribalAztecShaman4) ||
                (politician == cTechTribalIroquoisYouth4) ||
                (politician == cTechTribalSiouxYouth4) ||
                (politician == cTechTribalAztecYouth4))
            {
               xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 10);
            }
            if ((politician == cTechTribalAztecWisewoman4) || (politician == cTechTribalSiouxWisewoman4))
            {
	       xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + 20);			    
            }
            if (kbTechGetStatus(politician) != cTechStatusObtainable)
            {
               xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 50);
            }
            xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + aiRandInt(10));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gNatCouncilScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge4, bestChoice);
         break;
      }
      case cAge4:
      {  // All messengers to be avoided if possible
         numChoices = aiGetPoliticianListCount(cAge5);
         for (i=0; <numChoices)
         {
            politician = aiGetPoliticianListByIndex(cAge5, i);
            if ((politician == cTechTribalIroquoisYouth5) ||
                (politician == cTechTribalSiouxYouth5) ||
                (politician == cTechTribalAztecYouth5))
            {
               xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 10);
            }
            if (politician == cTechTribalIroquoisChief5)
            {
               xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + 20);
            }
            if (kbTechGetStatus(politician) != cTechStatusObtainable)
            {
               xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 50);
            }
            xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + aiRandInt(10));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gNatCouncilScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge5, bestChoice);
         break;
      }
   }

   aiEcho("Chosen age-up council member: "+kbGetTechName(politician));
   return(politician);
}

//==============================================================================
//bool allyIsAI(void)
//==============================================================================
bool allyIsAI(void)
{
    bool retVal = false;
	for (player=1; < cNumberPlayers)
	{
		if (player == cMyID)
			continue;
		if ((kbIsPlayerAlly(player) == true)&&(kbHasPlayerLost(player) == false)&&(kbIsPlayerHuman(player) == false))
		{
			retVal = true;
			break;
		}
	}

	return(retVal);
}

//==============================================================================
// chooseAsianWonder()
// Chooses age-up wonders for Asian civilizations
//==============================================================================
int chooseAsianWonder()
{
   int numChoices = -1;
   int politician = -1;
   int ageUpWonder = -1;
   int bestChoice = 0;
   int bestScore = 0;

   for (i=0; <6)
      xsArraySetInt(gAsianWonderScores, i, 0);   // reset array

   switch (kbGetAge())
   {
      case cAge1:
      {
         numChoices = aiGetPoliticianListCount(cAge2);
         for (i=0; <numChoices)
         {
            politician = aiGetPoliticianListByIndex(cAge2, i);
            if (politician == cTechYPWonderChinesePorcelainTower2) // slight bias against porcelain tower
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
            }
            if (politician == cTechYPWonderChineseSummerPalace2)  //boom or rush.
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            if ((politician == cTechYPWonderChineseConfucianAcademy2) && (gInitialStrategy == 3)) 
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }

            if (politician == cTechYPWonderIndianAgra2) // slight bias towards agra fort
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
			
            if (politician == cTechYPWonderIndianTajMahal2) // avoid Taj Mahal
            {
			 if ((gInitialStrategy == 0) || (gInitialStrategy >= 2)) //FF or FI
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
			 else
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 10);			   
            }

            if ((politician == cTechYPWonderJapaneseGiantBuddha2)||(politician == cTechYPWonderJapaneseShogunate2)) // slight bias against giant buddha
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 25);
            }
            if (politician == cTechYPWonderJapaneseToshoguShrine2)
            {
				if (allyIsAI() == false)
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				else
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
            }
            if (politician == cTechYPWonderJapaneseToriiGates2)
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 25);
            }
           
            xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(5));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gAsianWonderScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge2, bestChoice);
         aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));

         // Find building corresponding to chosen tech (i.e. "politician")
         for (i=0; <15)
         {
            if (xsArrayGetInt(gAge2WonderTechList, i) == politician)
            {
               ageUpWonder = xsArrayGetInt(gAge2WonderList, i);
            }
         }
         break;
      }
      case cAge2:
      {
         numChoices = aiGetPoliticianListCount(cAge3);
         for (i=0; <numChoices)
         {
            politician = aiGetPoliticianListByIndex(cAge3, i);
            if (politician == cTechYPWonderChinesePorcelainTower3) // slight bias against porcelain tower
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
            }
            if ((politician == cTechYPWonderChineseSummerPalace3) && (gInitialStrategy == 3)) // FI
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            if (politician == cTechYPWonderChineseTempleOfHeaven3) //bias against Temple Of Heaven
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
            }
            if (politician == cTechYPWonderChineseConfucianAcademy3)
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }

            if (politician == cTechYPWonderIndianAgra3) // slight bias towards agra fort
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }

            if (politician == cTechYPWonderIndianTajMahal3) // avoid Taj Mahal
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 10);
            }
            if (politician == cTechYPWonderIndianKarniMata3)
            {
			  if (gInitialStrategy == 3)
                xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            if (politician == cTechYPWonderIndianCharminar3)
            {
			  if (gInitialStrategy <= 1)
                xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }

            if ((politician == cTechYPWonderJapaneseGiantBuddha3)||(politician == cTechYPWonderJapaneseShogunate3))
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 25);
            }
            if (politician == cTechYPWonderJapaneseGoldenPavillion3) // strong bias towards golden pavillion
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 25);
            }

            if (kbTechGetStatus(politician) != cTechStatusObtainable)
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 50);
            }
            xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gAsianWonderScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge3, bestChoice);
         aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));

         // Find building corresponding to chosen tech (i.e. "politician")
         for (i=0; <15)
         {
            if (xsArrayGetInt(gAge3WonderTechList, i) == politician)
            {
               ageUpWonder = xsArrayGetInt(gAge3WonderList, i);
            }
         }
         break;
      }
      case cAge3:
      {
         numChoices = aiGetPoliticianListCount(cAge4);
         for (i=0; <numChoices)
         {
            politician = aiGetPoliticianListByIndex(cAge4, i);
            if (politician == cTechYPWonderChinesePorcelainTower4) // strong bias towards porcelain tower
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            if (politician == cTechYPWonderChineseTempleOfHeaven4) //bias against Temple Of Heaven
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
            }

            if (politician == cTechYPWonderIndianCharminar4) // strong bias towards charminar gate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            if (politician == cTechYPWonderIndianTajMahal4) // avoid Taj Mahal
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 10);
            }

            if (politician == cTechYPWonderJapaneseGiantBuddha4) // slight bias against giant buddha
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 25);
            }
            if (politician == cTechYPWonderJapaneseGoldenPavillion4) // strong bias towards golden pavillion
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
            }
            if (politician == cTechYPWonderJapaneseShogunate4) // strong bias towards shogunate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            if (politician == cTechYPWonderJapaneseToshoguShrine2)
            {
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 25);
            }

            if (kbTechGetStatus(politician) != cTechStatusObtainable)
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 50);
            }
            xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gAsianWonderScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge4, bestChoice);
         aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));

         // Find building corresponding to chosen tech (i.e. "politician")
         for (i=0; <15)
         {
            if (xsArrayGetInt(gAge4WonderTechList, i) == politician)
            {
               ageUpWonder = xsArrayGetInt(gAge4WonderList, i);
            }
         }
         break;
      }
      case cAge4:
      {
         numChoices = aiGetPoliticianListCount(cAge5);
         for (i=0; <numChoices)
         {
             politician = aiGetPoliticianListByIndex(cAge5, i);
            if (politician == cTechYPWonderChinesePorcelainTower5) // strong bias towards porcelain tower
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            if (politician == cTechYPWonderChineseTempleOfHeaven5) // avoid temple of heaven
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 10);
            }
            if (politician == cTechYPWonderIndianCharminar5) // strong bias towards charminar gate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            if (politician == cTechYPWonderIndianTajMahal5) // avoid Taj Mahal
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 10);
            }
            if (politician == cTechYPWonderJapaneseGiantBuddha5) // slight bias against giant buddha
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 25);
            }
            if (politician == cTechYPWonderJapaneseGoldenPavillion5) // strong bias towards golden pavillion
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
            }
            if (politician == cTechYPWonderJapaneseShogunate5) // strong bias towards shogunate
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 25);
            }
            if (kbTechGetStatus(politician) != cTechStatusObtainable)
            {
               xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 50);
            }
            xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
         }
         for (i=0; <numChoices)
         {
            if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
            {
               bestScore = xsArrayGetInt(gAsianWonderScores, i);
               bestChoice = i;
            }
         }
         politician = aiGetPoliticianListByIndex(cAge5, bestChoice);
         aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));

         // Find building corresponding to chosen tech (i.e. "politician")
         for (i=0; <15)
         {
            if (xsArrayGetInt(gAge5WonderTechList, i) == politician)
            {
               ageUpWonder = xsArrayGetInt(gAge5WonderList, i);
            }
         }
         break;
      }
   }

   aiEcho("Chosen age-up wonder: "+kbGetProtoUnitName(ageUpWonder));
   return(ageUpWonder);
}


//==============================================================================
// chooseRevolutionary()
// Chooses revolutionary politicians
//==============================================================================
int chooseRevolutionary(bool emergency = false)
{
   int randomizer = -1;
   int politician = -1;

   // Choose revolutionary based on civilization
   switch (kbGetCiv())
   {
      case cCivBritish: // 50 % chance each for L'Ouverture and Washington
      { 
         randomizer = aiRandInt(10); // 0-9
         if (randomizer < 5)
         {
            politician = cTechXPRevolutionLouverture;
         }
         else
         {
            politician = cTechXPRevolutionWashington;
         }
         break;
      }
      case cCivDutch: // 80 % chance for Bonifacio (100 % in an emergency), 20 % for Washington
      {
         randomizer = aiRandInt(10); // 0-9
         if ((randomizer < 8) || (emergency == true))
         {
            politician = cTechXPRevolutionBonifacio;
         }
         else
         {
            politician = cTechXPRevolutionWashington;
         }
         break;
      }
      case cCivFrench: // Santander on water maps, otherwise (or in an emergency) L'Ouverture
      {
         if ((kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0) && (emergency == false))
         {
            politician = cTechXPRevolutionSantander;
         }
         else
         {
            politician = cTechXPRevolutionLouverture;
         }
         break;
      }
      case cCivGermans: // 80 % chance for Bolivar (100 % in an emergency), 20 % for San Martin
      {
         randomizer = aiRandInt(10); // 0-9
         if ((randomizer < 8) || (emergency == true))
         {
            politician = cTechXPRevolutionBolivar;
         }
         else
         {
            politician = cTechXPRevolutionSanMartin;
         }
         break;
      }
      case cCivOttomans: // 100 % chance for Santander on island maps and 80 % on water maps, otherwise (or in an emergency) O'Higgins
      {
         randomizer = aiRandInt(10); // 0-9
         if ((cRandomMapName == "amazonia") ||
             (cRandomMapName == "caribbean") ||
             (cRandomMapName == "Ceylon") ||
             ((randomizer < 8) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)))
         {
            politician = cTechXPRevolutionSantander;
         }
         else
         {
            politician = cTechXPRevolutionOHiggins;
         }
         if (emergency == true)
         {
            politician = cTechXPRevolutionOHiggins;
         }
         break;
      }
      case cCivPortuguese: // 50 % chance each for Bonifacio and Hidalgo
      { 
         randomizer = aiRandInt(10); // 0-9
         if (randomizer < 5)
         {
            politician = cTechXPRevolutionBonifacio;
         }
         else
         {
            politician = cTechXPRevolutionHidalgo;
         }
         break;
      }
      case cCivRussians: // Santander on water maps, otherwise (or in an emergency) Bolivar
      {
         if ((kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0) && (emergency == false))
         {
            politician = cTechXPRevolutionSantander;
         }
         else
         {
            politician = cTechXPRevolutionBolivar;
         }
         break;
      }
      case cCivSpanish: // 50 % chance each for Hidalgo and O'Higgins
      { 
         randomizer = aiRandInt(10); // 0-9
         if (randomizer < 5)
         {
            politician = cTechXPRevolutionHidalgo;
         }
         else
         {
            politician = cTechXPRevolutionOHiggins;
         }
         break;
      }
   }

   aiEcho("Chosen revolutionary: "+kbGetTechName(politician));
   return(politician);
}


//==============================================================================
// checkRevolutionLastStand()
// Checks feasibility of a revolution aimed at delaying defeat
//==============================================================================
bool checkRevolutionLastStand()
{
   int player = -1;
   int numAllies = 0;
   int numEliminatedAllies = 0;
   int numSurvivingAllies = 0;
   bool freeForAll = false;

   // Don't revolt if there are no surviving allies in a team game
   // Note that the AI player itself counts as its own ally
   for (player = 0; < cNumberPlayers)
   {
      if (kbIsPlayerAlly(player) == true) 
      {
         numAllies = numAllies + 1;
         if (kbHasPlayerLost(player) == false)
         {
            numSurvivingAllies = numSurvivingAllies + 1;
         }
         else
         {
            numEliminatedAllies = numEliminatedAllies + 1;
         }
      }
      if (kbGetPlayerTeam(player) > 2) 
      {
         freeForAll = true;
      }
   }
   if ((numSurvivingAllies < 2) && (numEliminatedAllies > 0))
      return(false);

   // Don't revolt in a non-Free-For-All game without teammates
   // Note that the AI player itself counts as its own ally
   if ((numAllies < 2) && (freeForAll == false))
      return(false);

   // Don't revolt if there are 10 or more military units left
   if (kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive) > 9) 
      return(false);

   // Don't revolt if there are not at least 20 setttlers etc. available to become militia
   if (kbUnitCount(cMyID, cUnitTypeSettler, cUnitStateAlive) + 
       kbUnitCount(cMyID, cUnitTypeSettlerNative, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeCoureur, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeCoureurCree, cUnitStateAlive) < 20)
      return(false);

   // Don't revolt if there are not at least 25 enemy units in our own main base
   vector mainBaseVec = cInvalidVector;
   mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, mainBaseVec, 40.0);
   if (enemyCount < 25) 
      return(false);

   // Revolution is feasible if all preconditions are fulfilled
   return(true);
}


//==============================================================================
// checkRevolutionMegaLevy()
// Checks feasibility of a revolution aimed at defending an overrun base
//==============================================================================
bool checkRevolutionMegaLevy()
{
   int player = -1;
   int numEliminatedAllies = 0;
   int numSurvivingAllies = 0;

   // Don't revolt if there are no surviving allies
   // Note that the AI player itself counts as its own ally
   for (player = 0; < cNumberPlayers)
   {
      if ((kbIsPlayerAlly(player) == true) && (kbHasPlayerLost(player) == false))
      {
         numSurvivingAllies = numSurvivingAllies + 1;
      }
   }
   if (numSurvivingAllies < 2)
      return(false);

   // Don't revolt if there are not at least 2 factories or 4 banks available
   if ((kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) < 2) &&
       (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 4) &&
       (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 3))
      return(false);

   // Don't revolt if there are not at least 40 setttlers etc. available to become militia
   if (kbUnitCount(cMyID, cUnitTypeSettler, cUnitStateAlive) + 
       kbUnitCount(cMyID, cUnitTypeSettlerNative, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeCoureur, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeCoureurCree, cUnitStateAlive) < 40)
      return(false);

   // Don't revolt if there are not at least 25 enemy units in our own main base
   vector mainBaseVec = cInvalidVector;
   mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, mainBaseVec, 40.0);
   if (enemyCount < 25) 
      return(false);

   // Don't revolt if there are more than 10 own or allied units in our own main base
   int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive, mainBaseVec, 40.0);
   if (allyCount > 10) 
      return(false);

   // Revolution is feasible if all preconditions are fulfilled
   return(true);
}


//==============================================================================
// checkRevolutionMonopolyBreaker()
// Checks feasibility of a revolution aimed at breaking a trade monopoly
//==============================================================================
bool checkRevolutionMonopolyBreaker()
{
   int player = -1;
   int numEliminatedAllies = 0;
   int numSurvivingAllies = 0;

   // Don't revolt if there are no surviving allies
   // Note that the AI player itself counts as its own ally
   for (player = 0; < cNumberPlayers)
   {
      if ((kbIsPlayerAlly(player) == true) && (kbHasPlayerLost(player) == false))
      {
         numSurvivingAllies = numSurvivingAllies + 1;
      }
   }
   if (numSurvivingAllies < 2)
      return(false);

   // Don't revolt if there are not at least 40 setttlers etc. available to become militia
   if (kbUnitCount(cMyID, cUnitTypeSettler, cUnitStateAlive) + 
       kbUnitCount(cMyID, cUnitTypeSettlerNative, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeCoureur, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeCoureurCree, cUnitStateAlive) < 40)
      return(false);

   // Don't revolt if enemy trade monopoly timer is not running
   if ((gIsMonopolyRunning == false) || (gMonopolyTeam == kbGetPlayerTeam(cMyID)))
      return(false);

   // Don't revolt if there are more than two minutes left until trade monopoly timer expires
   if (gMonopolyEndTime - xsGetTime() > 120000)
      return(false);

   // Revolution is feasible if all preconditions are fulfilled
   return(true);
}

//==============================================================================
// checkRevolutionLastPush()
// Checks feasibility of a revolution aimed at econ Bias
//==============================================================================
/*bool checkRevolutionLastPush()
{
   // Don't revolt if there are not at least 2 factories or 4 banks available
   if ((kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) < 2) &&
       (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 4) &&
       (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 3))
      return(false);

   // Don't revolt if there are not at least 40 setttlers etc. available to become militia
   if (kbUnitCount(cMyID, cUnitTypeSettler, cUnitStateAlive) + 
       kbUnitCount(cMyID, cUnitTypeSettlerNative, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeCoureur, cUnitStateAlive) +
       kbUnitCount(cMyID, cUnitTypeCoureurCree, cUnitStateAlive) < 40)
      return(false);

   // Don't revolt if under treaty!!
   if (aiTreatyActive() == true)
      return(false);

   // Revolution is feasible if all preconditions are fulfilled
   return(true);
}*/

//==============================================================================
// revolutionaryShipmentHandler()
// Chooses appropriate revolutionary shipments
//==============================================================================
void revolutionaryShipmentHandler()
{
   int bestCard = -1;
   int cardRandomizer = 0;

   const int shipGatlings  = 0;
   const int shipMilitia   = 1;
   const int shipIronclads = 2;
   const int shipFortWagon = 3;

   // Ironclads are chosen whenever we expect naval action, unless we already have more than one
   // Otherwise, probability is 80 % gatling guns / 20 % militia; fort wagons are always ignored

   if ((kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0) &&
       (kbUnitCount(cMyID, cUnitTypexpIronclad) < 2) &&
       (aiPlanGetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0) > 0))
   {
      bestCard = shipIronclads;
   }
   else
   {
      cardRandomizer = aiRandInt(10);
      if (cardRandomizer < 8)
      {
         bestCard = shipGatlings;
      }
      else
      {
         bestCard = shipMilitia;
      }
   }
   if (bestCard >= 0)
   {
      aiEcho("Choosing card "+bestCard+", "+xsArrayGetString(gRevolutionaryCards, bestCard));
      aiHCDeckPlayCard(bestCard);
   }
}


//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Economy
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================

void startTCBuildPlan(vector location=cInvalidVector)
{
   if (cvOkToBuild == false)
      return;
   aiEcho("Creating a TC build plan.");
  
   // Make a town center, pri 100, econ, main base, 1 builder.
   int buildPlan=aiPlanCreate("TC Build plan ", cPlanBuild);
   // What to build
   aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeTownCenter);
   // Priority.
   aiPlanSetDesiredPriority(buildPlan, 100);
   // Mil vs. Econ.
   aiPlanSetMilitary(buildPlan, false);
   aiPlanSetEconomy(buildPlan, true);
   // Escrow.
   aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
   // Builders.
   if (kbUnitCount(cMyID, gCoveredWagonUnit, cUnitStateAlive) > 0)
      aiPlanAddUnitType(buildPlan, gCoveredWagonUnit, 1, 1, 1);
   else if ( (civIsEuropean() == false) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 0) )
      aiPlanAddUnitType(buildPlan, gEconUnit, 2, 4, 6); 
   else 
      aiPlanAddUnitType(buildPlan, gExplorerUnit, 1, 1, 1);


   // Instead of base ID or areas, use a center position and falloff.
   aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, location);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 100.00);

   // Add position influences for trees, gold, TCs.
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitTypeID, 5, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitDistance, 5, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitValue, 5, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitFalloff, 5, true);
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeWood);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 10.0);     // 30m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, 10.0);        // 10 points per tree
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
   
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 4, cUnitTypeHuntable);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 4, 10.0);     // 30m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 4, 40.0);        // 10 points per tree
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 4, cBPIFalloffLinear);  // Linear slope falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeMine);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 1,  12.0);              // 40 meter range for gold
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 1, 500.0);                // 300 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear);  // Linear slope falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeMine);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 2, 6.0);              // 10 meter inhibition to keep some space
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 2, -300.0);                // -300 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone);      // Cliff falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 3, cUnitTypeTownCenter);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 3, 40.0);              // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 3, -500.0);                // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 3, cBPIFalloffNone);      // Cliff falloff
      
   // Weight it to prefer the general starting neighborhood
   aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, location);    // Position influence for landing position
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, 100.0);     // 100m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 300.0);        // 300 points max
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
   
   
   aiPlanSetActive(buildPlan);
   aiPlanSetEventHandler(buildPlan, cPlanEventStateChange, "tcPlacedEventHandler");
   GTowerBuildPlanID = buildPlan;
   gTCBuildPlanID = buildPlan; // Save in a global var so the rule can access it.

}


void addGTowerBuildPlan(vector location=cInvalidVector)
{

/*
   float exclusionRadius = spacingDistance / 2.0;

     // We have found a location (success == true) or we need to just do a brute force placement around the TC.
     if (success == false)
      testVec = cInvalidVector;
	  
	 if (cvOkToBuild == false)
	 return;
	  
     //if (kbCanAffordUnit(gTowerUnit, cMilitaryEscrowID) == false)
     //  return; */
	  
   aiEcho("Creating a TC build plan.");
  
   // Make a town center, pri 100, econ, main base, 1 builder.
   int buildPlan=aiPlanCreate("Tower build plan ", cPlanBuild);
   // What to build
   aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
   // Priority.
   aiPlanSetDesiredPriority(buildPlan, 100);
   // Mil vs. Econ.
   aiPlanSetMilitary(buildPlan, false);
   aiPlanSetEconomy(buildPlan, true);
   // Escrow.
   aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
   // Builders.
   if (kbUnitCount(cMyID, gTowerWagonUnit, cUnitStateAlive) > 0)
      aiPlanAddUnitType(buildPlan, gTowerWagonUnit, 1, 1, 1);
   if  (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 0)
      aiPlanAddUnitType(buildPlan, gEconUnit, 1, 1, 2); 
   //else 
   //   aiPlanAddUnitType(buildPlan, gExplorerUnit, 1, 1, 1);


   // Instead of base ID or areas, use a center position and falloff.
   aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, location);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 100.00);

   // Add position influences for trees, gold, TCs.
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitTypeID, 7, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitDistance, 7, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitValue, 7, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitFalloff, 7, true);
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeWood);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 10.0);     // 30m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, 10.0);        // 10 points per tree
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeMine);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 1,  12.0);              // 40 meter range for gold
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 1, 400.0);                // 300 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear);  // Linear slope falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeMine);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 2, 6.0);              // 10 meter inhibition to keep some space
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 2, -600.0);                // -300 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone);      // Cliff falloff
   
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 3, cUnitTypeTownCenter);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 3, 40.0);              // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 3, -600.0);                // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 3, cBPIFalloffNone);      // Cliff falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 4, cUnitTypeHuntable);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 4, 10.0);     // 30m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 4, 25.0);        // 10 points per tree
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 4, cBPIFalloffLinear);  // Linear slope falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 5, cUnitTypeAbstractDock);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 5, 20.0);              // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 5, 250.0);                // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 5, cBPIFalloffNone);      // Cliff falloff
      
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 6, gTowerUnit);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 6, 40.0);              // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 6, -600.0);                // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 6, cBPIFalloffNone);      // Cliff falloff
   
   // Weight it to prefer the general starting neighborhood
   aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, location);    // Position influence for landing position
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, 100.0);     // 100m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 300.0);        // 300 points max
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
   
   
   aiPlanSetActive(buildPlan);
   aiPlanSetEventHandler(buildPlan, cPlanEventStateChange, "tcPlacedEventHandler");
   GTowerBuildPlanID = buildPlan;
   gTCBuildPlanID = buildPlan;  // Save in a global var so the rule can access it.

}

void startGTowerBuildPlan(vector location=cInvalidVector)
{

/*
   float exclusionRadius = spacingDistance / 2.0;

     // We have found a location (success == true) or we need to just do a brute force placement around the TC.
     if (success == false)
      testVec = cInvalidVector;
	  
	 if (cvOkToBuild == false)
	 return;
	  
     //if (kbCanAffordUnit(gTowerUnit, cMilitaryEscrowID) == false)
     //  return; */
	  
   aiEcho("Creating a TC build plan.");
  
   // Make a town center, pri 100, econ, main base, 1 builder.
   int buildPlan=aiPlanCreate("Tower build plan ", cPlanBuild);
   // What to build
   aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
   // Priority.
   aiPlanSetDesiredPriority(buildPlan, 100);
   // Mil vs. Econ.
   aiPlanSetMilitary(buildPlan, false);
   aiPlanSetEconomy(buildPlan, true);
   // Escrow.
   aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
   // Builders.
   if (kbUnitCount(cMyID, gTowerWagonUnit, cUnitStateAlive) > 0)
      aiPlanAddUnitType(buildPlan, gTowerWagonUnit, 1, 1, 1);
   if  (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 0)
      aiPlanAddUnitType(buildPlan, gEconUnit, 1, 1, 2); 
   //else 
   //   aiPlanAddUnitType(buildPlan, gExplorerUnit, 1, 1, 1);


   // Instead of base ID or areas, use a center position and falloff.
   aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, location);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 100.00);

   // Add position influences for trees, gold, TCs.
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitTypeID, 7, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitDistance, 7, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitValue, 7, true);
   aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitFalloff, 7, true);
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeWood);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 10.0);     // 30m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, 10.0);        // 10 points per tree
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeMine);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 1,  12.0);              // 40 meter range for gold
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 1, 400.0);                // 300 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear);  // Linear slope falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeMine);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 2, 6.0);              // 10 meter inhibition to keep some space
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 2, -600.0);                // -300 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone);      // Cliff falloff
   
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 3, cUnitTypeTownCenter);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 3, 40.0);              // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 3, -600.0);                // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 3, cBPIFalloffNone);      // Cliff falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 4, cUnitTypeHuntable);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 4, 10.0);     // 30m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 4, 25.0);        // 10 points per tree
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 4, cBPIFalloffLinear);  // Linear slope falloff
   
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 5, cUnitTypeAbstractDock);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 5, 20.0);              // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 5, 250.0);                // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 5, cBPIFalloffNone);      // Cliff falloff
      
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 6, gTowerUnit);
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 6, 40.0);              // 40 meter inhibition around TCs.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 6, -600.0);                // -500 points each
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 6, cBPIFalloffNone);      // Cliff falloff
   
   // Weight it to prefer the general starting neighborhood
   aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, location);    // Position influence for landing position
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, 100.0);     // 100m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 300.0);        // 300 points max
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
   
   
   aiPlanSetActive(buildPlan);
   aiPlanSetEventHandler(buildPlan, cPlanEventStateChange, "tcPlacedEventHandler");
   GTowerBuildPlanID = buildPlan;
   gTCBuildPlanID = buildPlan;  // Save in a global var so the rule can access it.

}

//==============================================================================
/* rule econUpgrades
   
   Make sure we always have an econ upgrade plan running.  Go cheapest first.
*/
//==============================================================================
rule econUpgrades
inactive
group tcComplete
minInterval 30
{
   int planState = -1;
   int techToGet = -1;
   float lowestCost = 1000000.0;
   static int gatherTargets = -1;   // Array to hold the list of things we gather from, i.e. mill, tree, etc.
   static int gatherTargetTypes = -1;  // Array.  If gatherTargets(x) == mill, then gatherTargetTypes(x) = cResourceFood.
   int target = -1;  // Index used to step through arrays
   static int startTime = -1;       // Time last plan was started, to make sure we're not waiting on an obsolete tech.
   
   if (gatherTargets < 0)  // Array not initialized
   {  // Set up our list of target units (what we gather from) and their resource categories.
      gatherTargets = xsArrayCreateInt(10, -1, "Gather Targets");
      gatherTargetTypes = xsArrayCreateInt(10, -1, "Gather Target Types");
      
      xsArraySetInt(gatherTargets, 0, gFarmUnit); // Mills and farms generate food
      xsArraySetInt(gatherTargetTypes, 0, cResourceFood);
      
      xsArraySetInt(gatherTargets, 1, cUnitTypeTree); // Trees generate wood
      xsArraySetInt(gatherTargetTypes, 1, cResourceWood);
      
	  
	  if (xsGetTime() < 40*60*1000)
	  {
      xsArraySetInt(gatherTargets, 2, cUnitTypeAbstractMine); // Mines generate gold
      xsArraySetInt(gatherTargetTypes, 2, cResourceGold);
	  }
      
      if ( (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) {
        xsArraySetInt(gatherTargets, 3, cUnitTypeHuntable);   // Huntables generate food, BHG: not for the japanese!
      }
      xsArraySetInt(gatherTargetTypes, 3, cResourceFood);
      
      xsArraySetInt(gatherTargets, 4, cUnitTypeFish);       // Fish generate food
      xsArraySetInt(gatherTargetTypes, 4, cResourceFood);
      
      xsArraySetInt(gatherTargets, 5, gPlantationUnit);       // Plantations generate gold
      xsArraySetInt(gatherTargetTypes, 5, cResourceGold);
	  
	  if (xsGetTime() > 40*60*1000)
	  {
      xsArraySetInt(gatherTargets, 5, gPlantationUnit);       // Plantations generate gold
      xsArraySetInt(gatherTargetTypes, 5, cResourceWood);
	  }
   }
 
   planState = aiPlanGetState(gEconUpgradePlan);

   if ( planState < 0 )
   {  // Plan is done or doesn't exist
      aiPlanDestroy(gEconUpgradePlan); // Nuke the old one, if it exists
      startTime = -1;

      int techID = -1;        // The cheapest tech for the current target unit type      
      float rawCost = -1.0;   // The cost of the upgrade
      float relCost = -1.0;   // The cost, relative to some estimate of the number of gatherers
      float numGatherers = -1.0;  // Number of gatherers assigned to the resource type (i.e food)
      
      /*
         Step through the array of gather targets.  For each, calculate the cost of the upgrade
         relative to the number of gatherers that would benefit.  Choose the one with the best 
         payoff.
      */
      for (target=0; < 10)    
      {
         if (xsArrayGetInt(gatherTargets, target) < 0)   // No target specified
            continue;
         techID =  kbTechTreeGetCheapestEconUpgrade(xsArrayGetInt(gatherTargets, target));
         if (techID < 0)   // No tech available for this target type
            continue;
         rawCost = kbGetTechAICost(techID);
         if (rawCost == 0.0)
            rawCost = -1.0;
         
         // Percent of gatherers assigned to this resource, times the number of econ units.
         numGatherers = aiGetResourceGathererPercentage( xsArrayGetInt(gatherTargetTypes, target), cRGPActual ) *  kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
         
         // Calculate the relative cost
         switch( xsArrayGetInt(gatherTargets, target) )
         {
            case cUnitTypeHuntable:
            {
               // Assume all food gatherers are hunting unless we have a mill.
               relCost = rawCost / numGatherers;
                if (kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive) > 0)
                  relCost = -1.0;   // Do NOT get hunting dogs once we're farming
               break;
            }
            case cUnitTypeFish:
            {
               numGatherers = kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive);
               if ( numGatherers > 0.0)
                  relCost = rawCost / numGatherers;
               else
                  relCost = -1.0;
               break;
            }
            default: // All other resources
            {
               if (numGatherers > 0.0)
                  relCost = rawCost / numGatherers;
               else
                  relCost = -1.0;                  
               break;
            }
         }
         
         // We now have the relative cost for the cheapest tech that gathers from this target type.
         // See if it's > 0, and the cheapest so far.  If so, save the stats, as long as it's obtainable.
         
         if ( (techID >= 0) && (relCost < lowestCost) && (relCost > 0.0) && (kbTechGetStatus(techID) == cTechStatusObtainable) )
         {
            lowestCost = relCost;
            techToGet = techID;
         }
      }
      
      
      if ( (techToGet >= 0) && (lowestCost < 40.0) ) // We have a tech
      {
    
         // If a plan has been running for 2 minutes...
         if ( (startTime > 0) && (xsGetTime() > (startTime + 120000)) )
         {
            // If it's still the tech we want, reset the start time counter and quit out.  Otherwise, kill it.
            if (aiPlanGetVariableInt(gEconUpgradePlan, cProgressionPlanGoalTechID, 0) == techToGet)
            {
               startTime = xsGetTime();
               return;
            }
            else
            {
               aiEcho("***** Destroying econ upgrade plan # "+gEconUpgradePlan+" because it has been running more than 3 minutes.");
               aiPlanDestroy(gEconUpgradePlan);
            }
         }
         // Plan doesn't exist, or we just killed it due to timeout....
         gEconUpgradePlan = aiPlanCreate("Econ upgrade tech "+techToGet, cPlanProgression);
         aiPlanSetVariableInt(gEconUpgradePlan, cProgressionPlanGoalTechID, 0, techToGet);
         aiPlanSetDesiredPriority(gEconUpgradePlan, 92);
         aiPlanSetEscrowID(gEconUpgradePlan, cEconomyEscrowID);
         aiPlanSetBaseID(gEconUpgradePlan, kbBaseGetMainID(cMyID));
         aiPlanSetActive(gEconUpgradePlan);
         startTime = xsGetTime();

         aiEcho("**** Creating upgrade plan for "+kbGetTechName(techToGet)+" is "+gEconUpgradePlan);
         //aiEcho("**** Status for tech "+kbGetTechName(techToGet)+" is "+kbTechGetStatus(techToGet));
         //aiEcho("**** Relative cost (score) was lowest at "+lowestCost);
      }
   }
   // Otherwise, if a plan already existed, let it run...
}

rule crateMonitor
inactive
group tcComplete
minInterval 15
{
   static int cratePlanID = -1;
   int numCrates = -1;
   int gatherersWanted = -1;
   
   // If we have a main base, count the number of crates in it
   if (kbBaseGetMainID(cMyID) < 0)
      return;
   
   // We have a main base, count the crates
   numCrates = kbUnitCount(cMyID, cUnitTypeAbstractResourceCrate,cUnitStateAlive) + kbUnitCount(0, cUnitTypeAbstractResourceCrate,cUnitStateAlive);
   if (numCrates <= 0)
     return;

   gatherersWanted = numCrates+1;  // At least 2, plus one for each crate over 1.

   //if (kbGetAge() < cAge2)
   //   gatherersWanted = 2; 

   if ( (kbGetAge() >= cAge2) && (gatherersWanted > 4) )
      gatherersWanted = 4;  //At most 4.
   
   if (aiPlanGetState(cratePlanID) == -1)
   {
      aiEcho("Crate gather plan "+cratePlanID+" is invalid.");
      aiPlanDestroy(cratePlanID);
      cratePlanID = -1;
   }
   if (cratePlanID < 0)
   {  // Initialize the plan
      cratePlanID = aiPlanCreate("Main Base Crate", cPlanGather);
      aiPlanSetBaseID(cratePlanID, kbBaseGetMainID(cMyID));
      aiPlanSetVariableInt(cratePlanID, cGatherPlanResourceUnitTypeFilter, 0, cUnitTypeAbstractResourceCrate);
      aiPlanSetVariableInt(cratePlanID, cGatherPlanResourceType, 0, cAllResources);
      aiPlanSetVariableInt(cratePlanID, cGatherPlanFindNewResourceTimeOut, 0, 30000);
      aiPlanAddUnitType(cratePlanID, gEconUnit, gatherersWanted, gatherersWanted, gatherersWanted);
      aiPlanSetDesiredPriority(cratePlanID, 99);
      aiPlanSetActive(cratePlanID);
      aiEcho("Activated crate gather plan "+cratePlanID);
   }
   
   aiPlanAddUnitType(cratePlanID, gEconUnit, gatherersWanted, gatherersWanted, gatherersWanted);
}

//==============================================================================
// getLowestResourceAmount
/*
   Returns the amount of the resource that's in shortest supply.
   Note:  It does not identify WHICH resource, it just returns the lowest amount.
   Food, wood and gold/coin are considered, others are not.
*/
//==============================================================================

float getLowestResourceAmount()
{
   float retVal = 1000000.0;
   if (kbResourceGet(cResourceWood) < retVal)
      retVal = kbResourceGet(cResourceWood);
   if (kbResourceGet(cResourceFood) < retVal)
      retVal = kbResourceGet(cResourceFood);
   if (kbResourceGet(cResourceGold) < retVal)
      retVal = kbResourceGet(cResourceGold);
   return(retVal);   
}

//==============================================================================
// getHighestResourceAmount
/*
   Returns the amount of the resource that's in shortest supply.
   Note:  It does not identify WHICH resource, it just returns the highest amount.
   Food, wood and gold/coin are considered, others are not.
*/
//==============================================================================

float getHighestResourceAmount()
{
   float retVal = 0.0;
   if (kbResourceGet(cResourceWood) > retVal)
      retVal = kbResourceGet(cResourceWood);
   if (kbResourceGet(cResourceFood) > retVal)
      retVal = kbResourceGet(cResourceFood);
   if (kbResourceGet(cResourceGold) > retVal)
      retVal = kbResourceGet(cResourceGold);
   return(retVal);   
}

//==============================================================================
// updateSettlerCounts
/*
   Set the settler maintain plan according to age and our behavior traits  
*/
//==============================================================================
void updateSettlerCounts(void)
{
   int normalTarget = xsArrayGetInt(gTargetSettlerCounts, kbGetAge());
   if (kbGetAge() == cvMaxAge)   // If we're capped at this age, build our full complement of villagers.
      normalTarget = xsArrayGetInt(gTargetSettlerCounts, cAge5);
   int modifiedTarget = normalTarget;
   
   switch (kbGetAge())
   {
      case cAge1:
      {
         modifiedTarget = normalTarget; // - (5.0 * btRushBoom);   // Rushers five less, boomers 5 more
         break;
      }
      case cAge2:
      {
         modifiedTarget = normalTarget; //  + (5.0 * btRushBoom);  //  Rushers 5 more (stay in age 2 longer), boomers 5 less (go to age 3 ASAP)
         break;
      }
      case cAge3:
      {
         modifiedTarget = normalTarget; // - (10.0 * btRushBoom);  //  Boomers 10 more, i.e. boom now means 'more econ'.
         break;
      }
      case cAge4:
      {
         modifiedTarget = normalTarget; // - (10.0 * btRushBoom);  //  Boomers 10 more, i.e. boom now means 'more econ'.
         break;
      }
      case cAge5:
      {
         modifiedTarget = normalTarget; // - (10.0 * btRushBoom);  //  Boomers 10 more, i.e. boom now means 'more econ'.
         break;
      }
   }
   if (kbGetCiv() != cCivOttomans)
      aiPlanSetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0, modifiedTarget);
   else
      aiPlanSetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0, 0);
}


//==============================================================================
// updateEscrows
/*
   Set the econ/mil escrow balances based on age, personality and our current
   settler pop compared to what we want to have.

   When we lose a lot of settlers, the economy escrow is expanded and the 
   military escrow is reduced until the econ recovers.  
*/
//==============================================================================
void updateEscrows(void)
{
   float econPercent = 0.0; 
   float milPercent = 0.0;
   //float villTarget = xsArrayGetInt(gTargetSettlerCounts, kbGetAge());  // How many we want to have this age
   float villTarget = aiPlanGetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0);   // How many do we want?
   float villCount = kbUnitCount(cMyID, gEconUnit, cUnitStateABQ);   // How many do we have?
   float villRatio = 1.00;   
   if (villTarget > 0.0)
      villRatio = villCount / villTarget;  // Actual over desired.
   float villShortfall = 1.0 - villRatio;  // 0.0 means at target, 0.3 means 30% short of target
   
   
   switch(kbGetAge())
   {
      case cAge1:
      {
         econPercent = 1.0;
		 milPercent = 0.0;
         break;
      }
	  
      case cAge2:
      {
	      /*if (xsGetTime() < 10*60*1000)
		 {
         econPercent = 1.0;
		 milPercent = 1.0;
		 }
		 else*/
	      if (xsGetTime() > 10*60*1000)
		 {
      kbEscrowFlush(cMilitaryEscrowID, cResourceWood, true);
      kbEscrowFlush(cMilitaryEscrowID, cResourceGold, true);
      kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
         econPercent = 1.0;
		 milPercent = 0.0;
		 }
		 else
		 if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
		 {
         econPercent = 1.0;
		 milPercent = 0.5;
		 }
		 else
		 {
         econPercent = 1.0;
		 milPercent = 1.0;
		 }
         break;
      }
	  
      case cAge3:
      {
	      if (xsGetTime() > 16*60*1000)
		 {
      kbEscrowFlush(cMilitaryEscrowID, cResourceWood, true);
      kbEscrowFlush(cMilitaryEscrowID, cResourceGold, true);
      kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
         econPercent = 1.0;
		 milPercent = 0.1;
		 }
		 else
		 if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
		 {
         econPercent = 1.0;
		 milPercent = 0.5;
		 }
		 else
		 {
         econPercent = 1.0;
		 milPercent = 1.0;
		 }
         break;
      }
	  
      case cAge4:
       {
	      if (xsGetTime() > 20*60*1000)
		 {
      kbEscrowFlush(cMilitaryEscrowID, cResourceWood, true);
      kbEscrowFlush(cMilitaryEscrowID, cResourceGold, true);
      kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
         econPercent = 1.0;
		 milPercent = 0.1;
		 }
		 else
		 if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
		 {
         econPercent = 1.0;
		 milPercent = 0.5;
      //kbEscrowFlush(cMilitaryEscrowID, cResourceWood, true);
      //kbEscrowFlush(cMilitaryEscrowID, cResourceGold, true);
      //kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
		 }
		 else
		 {
         econPercent = 1.0;
		 milPercent = 1.0;
		 }
         break;
      }
	  
      case cAge5:
      {
		 if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
		 {
         econPercent = 1.0;
		 milPercent = 1.0;
		 }
		 else
         econPercent = 1.0;
		 milPercent = 1.0;
         break;
      }
   } 
   
   
   if (econPercent < .50)
    
      econPercent = 0.50;
	
	
   if (econPercent > 1.0)
    
      econPercent = 1.0;
	
	
   if (milPercent < 0.0)
    
      milPercent = 0.0;
	
	
   if (milPercent > 1.0)
    
      milPercent = 1.0;
	
	
	
	
	
    
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceFood, econPercent);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceWood, econPercent); ///2.0);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceGold, econPercent);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceFame, 0.0);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceSkillPoints, 0.0);/*
   if ((kbGetAge() < cAge3) && (xsGetTime() > 15*60*1000)) 
   {
   kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 1200);    // Save for age upgrades
   kbEscrowSetCap(cEconomyEscrowID, cResourceGold, 1000);   // Save for age upgrades
   }
   else if ((kbGetAge() < cAge4) && (xsGetTime() > 20*60*1000)) 
   {
   kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 2000);    // Save for age upgrades
   kbEscrowSetCap(cEconomyEscrowID, cResourceGold, 1200);   // Save for age upgrades
   }
   else if ((kbGetAge() < cAge5) && (xsGetTime() > 25*60*1000)) 
   {
   kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 40000);    // Save for age upgrades
   kbEscrowSetCap(cEconomyEscrowID, cResourceGold, 40000);   // Save for age upgrades
   }
   else  if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)) && (kbGetAge() > cAge1))
   {
      kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 10000); // Needed for banks
      kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 10000);
   } 
   else*/
   kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 000);    // Save for age upgrades
   kbEscrowSetCap(cEconomyEscrowID, cResourceGold, 000);   // Save for age upgrades
   kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 000);
   //if (kbGetAge() >= cAge3)
   //   kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 0); // Needed for mills, plantations
   
   /*if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)) && (kbGetAge() > cAge1))
   {
      kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 00); // Needed for banks
      kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 00);
   } */
   
   /*else if ( (cvMaxAge > -1) && (kbGetAge() >= cvMaxAge) )
   {  // Not dutch, and not facing age upgrade, so reduce food/gold withholding
      kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 0); 
      kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 0);      
   }*/
  
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFood, milPercent);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceWood, milPercent); ///2.0);  
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceGold, milPercent);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFame, 0.0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceSkillPoints, 0.0);
   /* if ((kbGetAge() == cAge2) && (xsGetTime() < 12*60*1000) && ( agingUp() == false ))
   {
   kbEscrowSetCap(cMilitaryEscrowID, cResourceFood, 00);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceWood, 00);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceGold, 00);
   }
   if ((kbGetAge() == cAge3) && (xsGetTime() < 18*60*1000) && ( agingUp() == false ))
   {
   kbEscrowSetCap(cMilitaryEscrowID, cResourceFood, 00);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceWood, 00);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceGold, 00);
   }
   if ((kbGetAge() == cAge4) && (xsGetTime() < 24*60*1000) && ( agingUp() == false ))
   {
   kbEscrowSetCap(cMilitaryEscrowID, cResourceFood, 00);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceWood, 00);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceGold, 00);
   }
   else if ( (cvMaxAge > -1) && (kbGetAge() >= cvMaxAge) )
   {  // Not dutch, and not facing age upgrade, so reduce food/gold withholding
   kbEscrowSetCap(cMilitaryEscrowID, cResourceFood, 000);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceWood, 000);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceGold, 000);
   }
   else*/
   kbEscrowSetCap(cMilitaryEscrowID, cResourceFood, 000);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceWood, 000);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceGold, 000);
  
   kbEscrowSetPercentage(gVPEscrowID, cResourceFood, 0.0);        
   kbEscrowSetPercentage(gVPEscrowID, cResourceWood, 0.0);        
   kbEscrowSetPercentage(gVPEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(gVPEscrowID, cResourceFame, 0.0);
   kbEscrowSetPercentage(gVPEscrowID, cResourceSkillPoints, 0.0);
   kbEscrowSetCap(gVPEscrowID, cResourceFood, 00);
   kbEscrowSetCap(gVPEscrowID, cResourceWood, 000);
   kbEscrowSetCap(gVPEscrowID, cResourceGold, 00);
   
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceFood, 0.0);
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceWood, 0.0);
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceShips, 0.0);
}

//==============================================================================
// updateGatherers
/*
   Given the desired allocation of gatherers, set the desired number
   of gatherers for each active econ base, and the breakdown between
   resources for each base.
*/
//==============================================================================
void updateGatherers(void)
{   
   int i = 0;
   int effectiveAge = kbGetAge();
   /*
   if (agingUp() == true) // Politician is en route
      effectiveAge = effectiveAge + 1;
   
   if ( (effectiveAge < cAge2) && (gEarlyEconPhase == false) )
      effectiveAge = cAge2;   // Pretend we're in age 2 for gathering purposes
   */
   static int resourcePriorities = -1;    // An array that holds our priorities for cResourceFood, etc.
   if (resourcePriorities < 0)            // Initialize if needed
      resourcePriorities = xsArrayCreateFloat(cNumResourceTypes, 0.0, "resourcePriorities");

  
   if  (kbGetAge() == cAge1)
   {
   aiSetResourceGathererPercentageWeight(cRGPScript, 1.0);
   aiSetResourceGathererPercentageWeight(cRGPCost, 0.0);
   }
   
   
   if  (kbGetAge() == cAge2)
   {
   aiSetResourceGathererPercentageWeight(cRGPScript, 1.0);
   aiSetResourceGathererPercentageWeight(cRGPCost, 0.0);
   }
   
   
   if  (kbGetAge() == cAge3)
   {
   aiSetResourceGathererPercentageWeight(cRGPScript, 1.0);
   aiSetResourceGathererPercentageWeight(cRGPCost, 0.0);
   }
   
   
   if  (kbGetAge() == cAge4)
   {
   aiSetResourceGathererPercentageWeight(cRGPScript, 1.0);
   aiSetResourceGathererPercentageWeight(cRGPCost, 0.0);
   }
   
   if  (kbGetAge() == cAge5)
   {
   aiSetResourceGathererPercentageWeight(cRGPScript, 1.0);
   aiSetResourceGathererPercentageWeight(cRGPCost, 0.0);
   }
   
   for (i=0; < cNumResourceTypes)     // Process the forecast for each resource
   {
      float resourceAmount = kbResourceGet(i);
      if (resourceAmount < 1.0)
         resourceAmount = 1.0;

   // Measure ratio of supply to demand, check for div 0
      if (xsArrayGetFloat(gForecasts, i) <= 1.0)
         xsArraySetFloat(gForecasts, i, 1.0);

      float resourceRatio = resourceAmount / xsArrayGetFloat(gForecasts, i);  // What's the ratio of my inventory to projected needs?  High ratio means surplus, i.e. we don't need this.
      
      xsArraySetFloat(resourcePriorities, i, 1.0 / resourceRatio);   // If all resources were at 3.0 resourceRatios, they would all be 0.33 priorities.
      if (xsArrayGetFloat(resourcePriorities, i) > 3.0)              // Cap priorities at 3.0, range is 0..3
         xsArraySetFloat(resourcePriorities, i, 3.0);

   }
   // Each resourcePriority setting is the forecast / inventory, i.e. 1.0 means we have about 3 minutes demand.  
   // 3.0 means we're running fairly low, 0.5 means we have a glut.  So, the higher the resource priority is, 
   // the more we want to base gathering on the forecast, as we have no buffer.  When the resource priority is low,
   // we want to discount the forecast amount so we can use up some of the glut and gather more needed resources.  
   
   // Now, convert resource priorities the relative percentages of gatherers needed, i.e. the percent of total forecasted needs
   // adjust downward when the glut is large.
   float totalForecast = 0.0;
   float percentOfTotal = 0.0;
   totalForecast = xsArrayGetFloat(gForecasts, 0) + xsArrayGetFloat(gForecasts, 1) + xsArrayGetFloat(gForecasts, 2); 
   for (i=0; < 3)
   {
      percentOfTotal = xsArrayGetFloat(gForecasts, i) / totalForecast;  // How much of our total forecast is this resource?
      // Adjust it to the wanted percent based on the resource priority.  Priority 3.0 means we have no surplus, lower ratings
      // indicate a higher surplus.  So, we'll multiply the percentOfTotal by (priority/3) so it gets adjusted down only if a 
      // surplus exists.
      percentOfTotal =  percentOfTotal * (xsArrayGetFloat(resourcePriorities, i) / 3.0);
      
      // And store the new percent in the prioriites array
      xsArraySetFloat(resourcePriorities, i, percentOfTotal); // NOT normalized yet.
   }
   
   float totalPriority = 0.0;
   totalPriority = xsArrayGetFloat(resourcePriorities, 0) + xsArrayGetFloat(resourcePriorities, 1) + xsArrayGetFloat(resourcePriorities, 2);
   // Normalize
   for (i=0; <3)
   {
      if (totalPriority > 0)
         xsArraySetFloat(resourcePriorities, i, xsArrayGetFloat(resourcePriorities, i) / totalPriority);
      else
         xsArraySetFloat(resourcePriorities, i, 0.33);
   }
 
   int numCrates = -1;
   
   
   numCrates = kbUnitCount(cMyID, cUnitTypeAbstractResourceCrate,cUnitStateAlive) + kbUnitCount(0, cUnitTypeAbstractResourceCrate,cUnitStateAlive);
   if ((numCrates > 0) && (effectiveAge < cAge2))
   {  // Early game, go food crazy
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.20);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.60);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);

      if ( (kbGetCiv() == cCivDutch)) //&& (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 1) )
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.20);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.20);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.60);
      }
	  }
	 else
   if ( (effectiveAge < cAge2) && (cvOkToGatherFood == true) )
   {  // Early game, go food crazy
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.90);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);

      if ( (kbGetCiv() == cCivDutch)) //&& (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 1) )
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.60);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.30);
      }
      if (kbGetCiv() == cCivIndians)
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.60);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);
      } /*
      if (kbGetCiv() == cCivJapanese)
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.00);
         xsArraySetFloat(resourcePriorities, cResourceFood, 1.00);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);
      }
      if (kbGetCiv() == cCivBritish)
      {  // Need extra wood early
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.00);
         xsArraySetFloat(resourcePriorities, cResourceFood, 1.00);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);
      } */
   }

   if (((gInitialStrategy == 1)||(gInitialStrategy == 3)) && (effectiveAge > cAge1) && (aiGetGameMode() != cGameModeDeathmatch))
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.20);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.50);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.30);

   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }
		if ((cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPAztec) || (cMyCiv == cCivBritish) || (cMyCiv == cCivJapanese) || (cMyCiv == cCivChinese)) 
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.30);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.50);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }      
		if (cMyCiv == cCivIndians) 
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }  
   }
   
	if (((gInitialStrategy == 1)||(gInitialStrategy == 3))  && (effectiveAge < cAge2) && (agingUp() == true) && (aiGetGameMode() != cGameModeDeathmatch))
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.90);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.10);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);

   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.90);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.00);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.10);
      }
	if ((cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPAztec) || (cMyCiv == cCivBritish)) 
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.90);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.10);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);
      }      
	if ((cMyCiv == cCivChinese) || (cMyCiv == cCivIndians) || (cMyCiv == cCivJapanese)) 
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.70);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.30);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);
      }      
	if ((cMyCiv == cCivIndians)) 
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 1.00);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.00);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);
      }      
   }
	if ( ((gInitialStrategy == 0)||(gInitialStrategy == 2)) && (effectiveAge < cAge2) && (gEarlyEconPhase == false) && (agingUp() == true) && (aiGetGameMode() != cGameModeDeathmatch))
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.90);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);

   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.80);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.10);
      }
      if ( (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivIndians) )
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.90);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);
      }      
   }
   
   if (((gInitialStrategy == 0)||(gInitialStrategy == 2)) && (effectiveAge > cAge1) && (effectiveAge < cAge3) && (agingUp() == false) && (aiGetGameMode() != cGameModeDeathmatch))
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.30);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.60);

   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.20);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.60);
      }          
   }
   
   if ( (gInitialStrategy == 2) && (effectiveAge < cAge3) && (effectiveAge > cAge1) && (agingUp() == true) && (aiGetGameMode() != cGameModeDeathmatch) )
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.90);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.10);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);

   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }          
   }
   
   if ( (gInitialStrategy == 2) && (effectiveAge > cAge2) && (aiGetGameMode() != cGameModeDeathmatch) )
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.50);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.40);

   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }          
      if ( (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivIndians) )
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.20);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.60);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }      
   }
   
   if ( (gInitialStrategy == 0) && (effectiveAge > cAge1) && (effectiveAge < cAge3) && (agingUp() == true) && (aiGetGameMode() != cGameModeDeathmatch) )
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.50);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.40);

      if ( (kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) >= 4) )
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.50);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.40);
      }          
   }
   
   
   if ( (gInitialStrategy == 0) && (effectiveAge < cAge4) && (effectiveAge > cAge2) && (agingUp() == true) &&  (aiGetGameMode() != cGameModeDeathmatch))
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.90);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.10);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.00);

      if ( (kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 4) )
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }          
   }
   
   if ( (gInitialStrategy == 0) && (effectiveAge > cAge3) && (aiGetGameMode() != cGameModeDeathmatch) )
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.50);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.40);

      if ( (kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 4) )
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }          
      if ( (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivIndians) )
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.20);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.60);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }      
   }
/*
   if ( ((gInitialStrategy == 1)||(gInitialStrategy == 3)) && (effectiveAge < cAge4) && (aiGetGameMode() != cGameModeDeathmatch) && (agingUpToOrAbove(cAge2)==true) )
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.20);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.40);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.40);

      if ( (kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 4) )
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }
		if ((cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPAztec) || (cMyCiv == cCivBritish) || (cMyCiv == cCivIndians) || (cMyCiv == cCivJapanese) || (cMyCiv == cCivChinese)) 
      {
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.30);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.30);
      }      
   }
   
   if ( (gInitialStrategy == 2) && (agingUpToOrAbove(cAge2)==true) && (aiGetGameMode() != cGameModeDeathmatch) && (effectiveAge < cAge3) )
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.20);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.50);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.30);

      if ( (kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 4) )
      {  // Need bank early.
         xsArraySetFloat(resourcePriorities, cResourceWood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceFood, 0.40);
         xsArraySetFloat(resourcePriorities, cResourceGold, 0.20);
      }
	}
   if ((kbGetCiv() == cCivDutch) && (gInitialStrategy == 0)||(gInitialStrategy == 2)||(gInitialStrategy == 3)  && (aiGetGameMode() != cGameModeDeathmatch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) >= 4) )
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.10);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.50);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.40);
   }
   */

   if (cvOkToGatherFood == false)
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.0);
   
   if (cvOkToGatherWood == false)
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.0);

   if (cvOkToGatherGold == false)
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.0);
   
   if ( (cvOkToGatherFood == false) && (cvOkToGatherWood == false) && (cvOkToGatherGold == false) )
   {  // Can't set them ALL to zero percent...so leave them at 1/3 and turn off gathering somewhere else
      xsArraySetFloat(resourcePriorities, cResourceWood, 0.33);
      xsArraySetFloat(resourcePriorities, cResourceFood, 0.34);
      xsArraySetFloat(resourcePriorities, cResourceGold, 0.33);
   }

   float totalResources = kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);
   /*if ( (kbResourceGet(cResourceWood) > (totalResources / 10.0)) && (kbResourceGet(cResourceWood) > 5500) && (xsGetTime() > 60*1000*25) )
         if ((kbGetAge() == cAge1) && (agingUp() == false))
   {
      xsArraySetFloat(resourcePriorities, cResourceWood, xsArrayGetFloat(resourcePriorities, cResourceWood) * 0.10);
      xsArraySetFloat(resourcePriorities, cResourceFood, xsArrayGetFloat(resourcePriorities, cResourceFood) * 0.90);
      xsArraySetFloat(resourcePriorities, cResourceGold, xsArrayGetFloat(resourcePriorities, cResourceGold) * 0.00);
   }
	*/
	
   // Set the new values, ignore that they might not total 1.0 for now...
   for (i=0; <cNumResourceTypes)
     aiSetResourceGathererPercentage(i, xsArrayGetFloat(resourcePriorities, i), false, cRGPScript); 
	
   aiNormalizeResourceGathererPercentages(cRGPScript);   // Set them to 1.0 total.
}


//==============================================================================
// rule resourceManager
/*
   Watch the resource balance, buy/sell imbalanced resources as needed
   
   In initial build phase (first 5 houses?) sell all food, buy wood with 
   any gold.  Later, look for imbalances.
*/
//==============================================================================
rule resourceManager
inactive
minInterval 30
group startup
{
   bool goAgain = false;         // Set this flag if we do a buy or sell and want to quickly evaluate
   static bool fastMode = false; // Set this flag if we enter high-speed mode, clear it on leaving
   static int lastTributeRequestTime = 0;
   
   if (aiResourceIsLocked(cResourceGold) == true)
   {
      aiEcho("Gold is locked.");
      if (fastMode == true)
      {
         // We need to slow down.
         xsSetRuleMinIntervalSelf(34);
         aiEcho("Resource manager going to slow mode.");
         fastMode = false;
      }
      return;
   }

   if ( ((xsGetTime() - lastTributeRequestTime) > 300000) && ((xsGetTime() - gLastTribSentTime) > 120000) )    // Don't request too often, and don't request right after sending.
   {  // See if we have a critical shortage of anything
      float totalResources = kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);
      if ( (totalResources > 1000.0) && (kbGetAge() > cAge1) )
      {  // Don't request tribute if we're short on everything, just for imbalances.  And skip age 1, since we'll have zero gold and mucho food.
         if (kbResourceGet(cResourceFood) < (totalResources / 10.0) )
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyRequestFood);
            lastTributeRequestTime = xsGetTime();
         }
         if (kbResourceGet(cResourceGold) < (totalResources / 10.0) )
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyRequestCoin);
            lastTributeRequestTime = xsGetTime();
         }
         if (kbResourceGet(cResourceWood) < (totalResources / 10.0) )
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyRequestWood);
            lastTributeRequestTime = xsGetTime();
         }
      }
   }
   
   // Normal imbalance rules apply
   if ( (kbUnitCount(cMyID, gMarketUnit, cUnitStateAlive) > 0) && (aiResourceIsLocked(cResourceGold) == false))
   {
      if ( (kbResourceGet(cResourceFood) > (2 * getLowestResourceAmount())) && (kbResourceGet(cResourceFood) > 6000) && (aiResourceIsLocked(cResourceFood) == false) )
      {  // Sell food!  We have much, and it's 5x min
         aiSellResourceOnMarket(cResourceFood);
         aiEcho("Selling 100 food.");
         goAgain = true;
      }         
      if ( (kbResourceGet(cResourceWood) > (2 * getLowestResourceAmount())) && (kbResourceGet(cResourceWood) > 6000) && (aiResourceIsLocked(cResourceWood) == false)  )
      {  // Sell wood!  We have much, and it's 5x min
         aiSellResourceOnMarket(cResourceWood);
         aiEcho("Selling 100 wood.");
         goAgain = true;
      }         
      if ( (kbResourceGet(cResourceGold) > (1.5 * getLowestResourceAmount())) && (kbResourceGet(cResourceGold) > 6000) )
      {  // Buy something!  We have much gold, and it's 5x min
         if (kbResourceGet(cResourceFood) < kbResourceGet(cResourceWood))
         {
            if ( aiResourceIsLocked(cResourceFood) == false )
            {
               aiBuyResourceOnMarket(cResourceFood);
               aiEcho("Buying 100 food.");
               goAgain = true;
            }
         }
         else
         {
            if ( aiResourceIsLocked(cResourceWood) == false )
            {
               aiBuyResourceOnMarket(cResourceWood);
               aiEcho("Buying 100 wood.");
               goAgain = true;
            }
         }
      }
   }

   if ( (goAgain == true) && (fastMode == false) )
   {
      // We need to set fast mode
      xsSetRuleMinIntervalSelf(1);
      aiEcho("Going to fast mode.");
      fastMode = true;
   }
   if ( (goAgain == false) && (fastMode == true) )
   {
      // We need to slow down.
      xsSetRuleMinIntervalSelf(10);
      aiEcho("Resource manager going to slow mode.");
      fastMode = false;
   }
}


void findEnemyBase(void)
{
   if ( (cRandomMapName == "amazonia") || (cRandomMapName == "caribbean") || (cRandomMapName == "Ceylon") )   
      return();   // No sense trying that on these standard maps
   
   if (cvOkToExplore == false)
      return();
   
   //Create an explore plan to go there.
   vector myBaseLocation=kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)); // Main base location...need to find reflection.
   vector centerOffset = kbGetMapCenter() - myBaseLocation;
   vector targetLocation = kbGetMapCenter() + centerOffset;
   // TargetLocation is now a mirror image of my base.
   aiEcho("My base is at "+myBaseLocation+", enemy base should be near "+targetLocation);
   int exploreID=aiPlanCreate("Probe Enemy Base", cPlanExplore);
   if (exploreID >= 0)
   {
      aiPlanAddUnitType(exploreID, cUnitTypeAbstractRangedInfantry, 1, 1, 1); // Infantry or cavalry only, no explorer!
      aiPlanAddWaypoint(exploreID, targetLocation);
      aiPlanSetVariableBool(exploreID, cExplorePlanDoLoops, 0, false);
      aiPlanSetVariableBool(exploreID, cExplorePlanQuitWhenPointIsVisible, 0, true);
      aiPlanSetVariableBool(exploreID, cExplorePlanAvoidingAttackedAreas, 0, false);
      aiPlanSetVariableInt(exploreID, cExplorePlanNumberOfLoops, 0, -1);
      aiPlanSetRequiresAllNeedUnits(exploreID, true);
      aiPlanSetVariableVector(exploreID, cExplorePlanQuitWhenPointIsVisiblePt, 0, targetLocation);
      aiPlanSetDesiredPriority(exploreID, 100);
      aiPlanSetActive(exploreID);
   }
}

vector selectForwardBaseLocation(void)
{
   vector retVal = cInvalidVector;
   vector mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   vector v = cInvalidVector; // Scratch variable for intermediate calcs.
   
   aiEcho("Selecting forward base location.");
   float distanceMultiplier = 0.5;  // Will be used to determine how far out we should put the fort on the line from our base to enemy TC.
   float dist = 0.0;
   
   int enemyTC = getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationEnemy, cUnitStateABQ, mainBaseVec, 500.0);
   if (enemyTC < 0)
   {  
      retVal = kbGetMapCenter();   // Start with map center
      aiEcho("    No enemy TC found, using map center at "+retVal);
   }
   else  // enemy TC found
   {
      v = kbUnitGetPosition(enemyTC) - mainBaseVec;   // Vector from main base to enemy TC
      dist = distance(mainBaseVec, kbUnitGetPosition(enemyTC));
      if (dist > 200.0)
         distanceMultiplier = (dist-80.0) / dist; // I.e. take halfway point, or 80m from enemy TC, whichever is farther from my base.
      v = v * distanceMultiplier;   // Halfway there, or 100 meters away from enemy, whichever is closer to enemy.
      retVal = mainBaseVec + v;  // retval is midpoint between main base and nearest enemy TC.
      aiEcho("Enemy TC ("+enemyTC+") found at "+kbUnitGetPosition(enemyTC));
      aiEcho("Using midpoint of "+retVal);
   }
   // Now, make sure it's on the same areagroup, back up if it isn't.
   dist = distance(mainBaseVec, retVal);
   int mainAreaGroup = kbAreaGroupGetIDByPosition(mainBaseVec);
   vector delta = (mainBaseVec - retVal) * 0.1;
   int step = 0;
   bool siteFound = false;
   if (dist > 0.0)
   {
      for (step = 0; < 9)
      {
         aiEcho("    "+retVal+" is in area group "+kbAreaGroupGetIDByPosition(retVal));
         if ( getUnitByLocation(cUnitTypeFortFrontier, cPlayerRelationEnemy, cUnitStateABQ, retVal, 60.0) >= 0 ) //cUnitTypeFortFrontier
            continue;   // DO NOT build anywhere near an enemy fort!
         if ( getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationEnemy, cUnitStateABQ, retVal, 60.0) >= 0 )
            continue;   // Ditto enemy TCs.
         if (mainAreaGroup == kbAreaGroupGetIDByPosition(retVal)) 
         {  // DONE!
            aiEcho("Good location found.");
            siteFound = true;
            break;
         }
         retVal = retVal + delta;   // Move 1/10 of way back to main base, try again.
      }
   }
   if (siteFound == false)
      retVal = mainBaseVec;
   if (aiGetWorldDifficulty() < cDifficultyModerate)
      retVal = mainBaseVec;   // Easy and Sandbox will never forward build.
   aiEcho("New forward base location will be "+retVal);
   return(retVal);
}

vector selectTowerLocation(void)
{
    int attempt = 0;
    vector testVec = cInvalidVector;
    float spacingDistance = 10.0; // Mid- and corner-spots on a square with 'radius' spacingDistance, i.e. each side is 2 * spacingDistance.
    if ( (civIsNative() == true) || (kbGetCiv() == cCivRussians) )
       spacingDistance = 50.0;
    float exclusionRadius = spacingDistance / 2.0;
    float dx = spacingDistance;
    float dz = spacingDistance;
    static int towerSearch = -1;
    bool success = false;

    for (attempt = 0; < 10) // Take ten tries to place it
    {
       testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)); // Start with base location
      
       switch(aiRandInt(8)) // 0..7
       {  // Use 0.8 * on corners to "round them" a bit
          case 0:
          {  // W
             dx = -0.8 * dx;
             dz = 0.8 * dz;
             aiEcho("West...");
             break;
          }
          case 1:
          {  // NW
             dx = 0.0;
             aiEcho("Northwest...");
             break;
          }
          case 2:
          {  // N
             dx = 0.8 * dx;
             dz = 0.8 * dz;
             aiEcho("North...");
             break;
          }
          case 3:
          {  // NE
             dz = 0.0;
             aiEcho("NorthEast...");
             break;
          }
          case 4:
          {  // E
             dx = 0.8 * dx;
             dz = -0.8 * dz;
             aiEcho("East...");
             break;
          }
          case 5:
          {  // SE
             dx = 0.0;
             dz = -1.0 * dz;
             aiEcho("SouthEast...");
             break;
          }
          case 6:
          {  // S
             dx = -0.8 * dx;
             dz = -0.8 * dz;
             aiEcho("South...");
             break;
          }
          case 7:
          {  // SW
             dx = -1.0 * dx;
             dz = 0;
             aiEcho("SouthWest...");
             break;
          }
       }
       testVec = xsVectorSetX(testVec, xsVectorGetX(testVec) + dx);
       testVec = xsVectorSetZ(testVec, xsVectorGetZ(testVec) + dz);
       aiEcho("Testing tower location "+testVec);
       if (towerSearch < 0)
       {  // init
          towerSearch = kbUnitQueryCreate("Tower placement search");
          kbUnitQuerySetPlayerRelation(towerSearch, cPlayerRelationAny);
          kbUnitQuerySetUnitType(towerSearch, gTowerUnit);
          kbUnitQuerySetState(towerSearch, cUnitStateABQ);
       }
       kbUnitQuerySetPosition(towerSearch, testVec);
       kbUnitQuerySetMaximumDistance(towerSearch, exclusionRadius);
       kbUnitQueryResetResults(towerSearch);
       if (kbUnitQueryExecute(towerSearch) < 1)
       {  // Site is clear, use it
          if (kbAreaGroupGetIDByPosition(testVec) == kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) )
          {  // Make sure it's in same areagroup.
             success = true;
             break;
          }
       }
    }

    if (success == false)
      testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));

    return(testVec);   
}

//==============================================================================
/*
   Start Tower Build Plan
   
   Tries to maintain gNumTowers for the number of towers near the main base.

   If there are idle outpost wagons, use them.  If not, use villagers to build outposts.
   Russians use blockhouses via gTowerUnit. Natives build war huts (Iroquois), 
   nobles huts (Aztecs) and teepees (Sioux), and Asians build castles, again 
   selected via gTowerUnit.

   Placement algorithm is brain-dead simple.  Check a point that is mid-edge or a 
   corner of a square around the base center.  Look for a nearby tower.  If none, 
   do a tight build plan.  If there is one, try again.    If no luck, try a build
   plan that just avoids other towers.
*/
//==============================================================================
void startTowerBuildPlan(vector testVec=cInvalidVector, bool success=false, float spacingDistance=10.0)
{      
   float exclusionRadius = spacingDistance / 2.0;

   // We have found a location (success == true) or we need to just do a brute force placement around the TC.
   if (success == false)
      testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   
   int buildPlan=aiPlanCreate("Tower build plan ", cPlanBuild);
   // What to build
   aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
   // Priority.
   aiPlanSetDesiredPriority(buildPlan, 85);
   // Econ, because mil doesn't get enough wood.
   aiPlanSetMilitary(buildPlan, false);
   aiPlanSetEconomy(buildPlan, true);
   // Escrow.
   aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
   // Builders.
   if (kbUnitCount(cMyID, gTowerWagonUnit, cUnitStateAlive) > 0)
      aiPlanAddUnitType(buildPlan, gTowerWagonUnit, 1, 1, 1);
   else
      aiPlanAddUnitType(buildPlan, gEconUnit, 1, 1, 1);
   
   // Instead of base ID or areas, use a center position and falloff.
   aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, testVec);
   if (success == true)
      aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, exclusionRadius);
   else
      aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 60.0);

   // Add position influence for nearby towers
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);   // Russian's won't notice ally towers and vice versa...oh well.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 10.0);    
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, -20.0);        // -20 points per tower
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff

   // Weight it to stay very close to center point.
   aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, testVec);    // Position influence for landing position
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, exclusionRadius);     // 100m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 10.0);        // 10 points for center
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff

   aiEcho("Starting building plan ("+buildPlan+") for tower at location "+testVec);
   aiEcho("Cheapest tech for tower buildings is "+ kbGetTechName(kbTechTreeGetCheapestUnitUpgrade(gTowerUnit)) );
   aiEcho("Cheapest tech ID is "+kbTechTreeGetCheapestUnitUpgrade(gTowerUnit));
   aiPlanSetActive(buildPlan);
}

rule useTowerWagons
inactive
group tcComplete
minInterval 30
{
   // tower upgrade
   static int towerUpgradePlan = -1;
   int towerUpgrade1 = cTechFrontierOutpost;
   int towerUpgrade2 = cTechFortifiedOutpost;
   int aztecNoblesHutUpgradePlan = -1;

   if (kbGetCiv() == cCivRussians)
   {
      towerUpgrade1 = cTechFrontierBlockhouse;
      towerUpgrade2 = cTechFortifiedBlockhouse;
   }
   if (kbGetCiv() == cCivXPIroquois)
   {
      towerUpgrade1 = cTechStrongWarHut;
      towerUpgrade2 = cTechMightyWarHut;
   }
   if (kbGetCiv() == cCivXPAztec)
   {
      towerUpgrade1 = cTechStrongWarHut;
      towerUpgrade2 = cTechMightyWarHut;
   }
   if (kbGetCiv() == cCivXPSioux)
   {
      towerUpgrade1 = cTechStrongWarHut;
      towerUpgrade2 = cTechMightyWarHut;
   }
   if (civIsAsian() == true)
   {
      towerUpgrade1 = cTechypFrontierCastle;
      towerUpgrade2 = cTechypFortifiedCastle;
   }
  
   if (towerUpgradePlan >= 0)
   {
      if ((aiPlanGetState(towerUpgradePlan) < 0) || (aiPlanGetVariableInt(towerUpgradePlan, cResearchPlanBuildingID, 0) < 0))
      {
         aiPlanDestroy(towerUpgradePlan);
         towerUpgradePlan = -1;
         aiEcho("Invalid tower upgrade plan destroyed.");
      }
   }

   if ( (kbTechGetStatus(towerUpgrade1) == cTechStatusObtainable) && (towerUpgradePlan == -1) ) // The first upgrade is available, and I'm not researching it. 
   {
      if (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) >= 2)
      {  // I have at least 2 towers
         towerUpgradePlan = createSimpleResearchPlan(towerUpgrade1, -1, cMilitaryEscrowID, 75);
         aiEcho("Starting research plan for first tower upgrade in plan # "+towerUpgradePlan);
      }
   }
   
   if ( (kbTechGetStatus(towerUpgrade2) == cTechStatusObtainable) && (towerUpgradePlan == -1) ) // The second upgrade is available, and I'm not researching it. 
   {
      if (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) >= 2)
      {  // I have at least 2 towers
         towerUpgradePlan = createSimpleResearchPlan(towerUpgrade2, -1, cMilitaryEscrowID, 75);
         aiEcho("Starting research plan for second tower upgrade in plan # "+towerUpgradePlan);
      }
   }   
   
   // Research both upgrades as they become available, but only if there are enough nobles huts around
   if ( (kbGetCiv() == cCivXPAztec) && (kbTechGetStatus(cTechStrongNoblesHut) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNoblesHut, cUnitStateABQ) >= 3) )
   {
      aztecNoblesHutUpgradePlan = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechStrongNoblesHut);
      if (aztecNoblesHutUpgradePlan >= 0)
         aiPlanDestroy(aztecNoblesHutUpgradePlan);
      createSimpleResearchPlan(cTechStrongNoblesHut, -1, cMilitaryEscrowID, 50);
      return;
   }
   if ( (kbGetCiv() == cCivXPAztec) && (kbTechGetStatus(cTechMightyNoblesHut) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNoblesHut, cUnitStateABQ) >= 5) )
   {
      aztecNoblesHutUpgradePlan = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechMightyNoblesHut);
      if (aztecNoblesHutUpgradePlan >= 0)
         aiPlanDestroy(aztecNoblesHutUpgradePlan);
      createSimpleResearchPlan(cTechMightyNoblesHut, -1, cMilitaryEscrowID, 50);
      return;
   }

   int towerWagon = -1;
   //find out how many tower wagon we have.
   static int towerWagonQuery = -1;
   towerWagonQuery = createSimpleQuery(cMyID, gTowerWagonUnit, cUnitStateAlive);
   kbUnitQueryResetResults(towerWagonQuery);
   int wagonCount = kbUnitQueryExecute(towerWagonQuery);   
   static vector loc = cInvalidVector;
   int j = 0;
   for (j=0; <wagonCount)
   {   
       towerWagon = kbUnitQueryGetResult(towerWagonQuery, j);
       int attempt = 0;
       vector testVec = cInvalidVector;
       float spacingDistance = 10.0; // Mid- and corner-spots on a square with 'radius' spacingDistance, i.e. each side is 2 * spacingDistance.
       if ( (civIsNative() == true) || (kbGetCiv() == cCivRussians) )
         spacingDistance = 50.0;
       float exclusionRadius = spacingDistance / 2.0;
       float dx = spacingDistance;
       float dz = spacingDistance;
       static int towerSearch = -1;
       bool success = false;

       for (attempt = 0; < 10) // Take ten tries to place it
       {
          testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)); // Start with base location
      
          switch(aiRandInt(8)) // 0..7
          {  // Use 0.9 * on corners to "round them" a bit
             case 0:
             {  // W
                dx = -0.9 * dx;
                dz = 0.9 * dz;
                aiEcho("West...");
                break;
             }
             case 1:
             {  // NW
                dx = 0.0;
                aiEcho("Northwest...");
                break;
             }
             case 2:
             {  // N
                dx = 0.9 * dx;
                dz = 0.9 * dz;
                aiEcho("North...");
                break;
             }
             case 3:
             {  // NE
                dz = 0.0;
                aiEcho("NorthEast...");
                break;
             }
             case 4:
             {  // E
                dx = 0.9 * dx;
                dz = -0.9 * dz;
                aiEcho("East...");
                break;
             }
             case 5:
             {  // SE
                dx = 0.0;
                dz = -1.0 * dz;
                aiEcho("SouthEast...");
                break;
             }
             case 6:
             {  // S
                dx = -0.9 * dx;
                dz = -0.9 * dz;
                aiEcho("South...");
                break;
             }
             case 7:
             {  // SW
                dx = -1.0 * dx;
                dz = 0;
                aiEcho("SouthWest...");
                break;
             }
          }
          testVec = xsVectorSetX(testVec, xsVectorGetX(testVec) + dx);
          testVec = xsVectorSetZ(testVec, xsVectorGetZ(testVec) + dz);
          aiEcho("Testing tower location "+testVec);

          if (towerSearch < 0)
          {  // init
             towerSearch = kbUnitQueryCreate("Tower placement search");
             kbUnitQuerySetPlayerRelation(towerSearch, cPlayerRelationAny);
             kbUnitQuerySetUnitType(towerSearch, gTowerUnit);
             kbUnitQuerySetState(towerSearch, cUnitStateABQ);
          }
          kbUnitQuerySetPosition(towerSearch, testVec);
          kbUnitQuerySetMaximumDistance(towerSearch, exclusionRadius);
          kbUnitQueryResetResults(towerSearch);
          if (kbUnitQueryExecute(towerSearch) < 1)
          {  // Site is clear, use it
             if ( kbAreaGroupGetIDByPosition(testVec) == kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) )
             {  // Make sure it's in same areagroup.
                success = true;
                break;
             }
          }
       }
       startTowerBuildPlan(testVec, success, spacingDistance);
    }
}

void addTowerBuildPlan(void)
{
    if (kbCanAffordUnit(gTowerUnit, cMilitaryEscrowID) == false)
      return;
                		
    int attempt = 0;
    vector testVec = cInvalidVector;
    float spacingDistance = 10.0; // Mid- and corner-spots on a square with 'radius' spacingDistance, i.e. each side is 2 * spacingDistance.
    if ( (civIsNative() == true) || (kbGetCiv() == cCivRussians) )
       spacingDistance = 50.0;
    float exclusionRadius = spacingDistance / 2.0;
    float dx = spacingDistance;
    float dz = spacingDistance;
    static int towerSearch = -1;
    bool success = false;

    for (attempt = 0; < 10) // Take ten tries to place it
    {
       testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)); // Start with base location
      
       switch(aiRandInt(8)) // 0..7
       {  // Use 0.8 * on corners to "round them" a bit
          case 0:
          {  // W
             dx = -0.8 * dx;
             dz = 0.8 * dz;
             aiEcho("West...");
             break;
          }
          case 1:
          {  // NW
             dx = 0.0;
             aiEcho("Northwest...");
             break;
          }
          case 2:
          {  // N
             dx = 0.8 * dx;
             dz = 0.8 * dz;
             aiEcho("North...");
             break;
          }
          case 3:
          {  // NE
             dz = 0.0;
             aiEcho("NorthEast...");
             break;
          }
          case 4:
          {  // E
             dx = 0.8 * dx;
             dz = -0.8 * dz;
             aiEcho("East...");
             break;
          }
          case 5:
          {  // SE
             dx = 0.0;
             dz = -1.0 * dz;
             aiEcho("SouthEast...");
             break;
          }
          case 6:
          {  // S
             dx = -0.8 * dx;
             dz = -0.8 * dz;
             aiEcho("South...");
             break;
          }
          case 7:
          {  // SW
             dx = -1.0 * dx;
             dz = 0;
             aiEcho("SouthWest...");
             break;
          }
       }
       testVec = xsVectorSetX(testVec, xsVectorGetX(testVec) + dx);
       testVec = xsVectorSetZ(testVec, xsVectorGetZ(testVec) + dz);
       aiEcho("Testing tower location "+testVec);
       if (towerSearch < 0)
       {  // init
          towerSearch = kbUnitQueryCreate("Tower placement search");
          kbUnitQuerySetPlayerRelation(towerSearch, cPlayerRelationAny);
          kbUnitQuerySetUnitType(towerSearch, gTowerUnit);
          kbUnitQuerySetState(towerSearch, cUnitStateABQ);
       }
       kbUnitQuerySetPosition(towerSearch, testVec);
       kbUnitQuerySetMaximumDistance(towerSearch, exclusionRadius);
       kbUnitQueryResetResults(towerSearch);
       if (kbUnitQueryExecute(towerSearch) < 1)
       {  // Site is clear, use it
          if (kbAreaGroupGetIDByPosition(testVec) == kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) )
          {  // Make sure it's in same areagroup.
             success = true;
             break;
          }
       }
    }
    startTowerBuildPlan(testVec, success, spacingDistance);
}
/*
//==============================================================================
// forwardBaseCallback
//==============================================================================
void forwardBaseCallback(int parm=-1)
{  
   int numBases=kbBaseGetNumber(cMyID);
   int forwBase=-1;
   for ( i = 0; < numBases )
   {
      forwBase=kbBaseGetIDByIndex(cMyID, i);
      if (kbBaseGetForward(cMyID, forwBase) == true)
         break;
   }

   if (forwBase < 0)
   {      
      return;
   }

   kbBaseSetMilitaryGatherPoint(cMyID, forwBase, kbBaseGetLocation(cMyID, forwBase));

   int goalNum=aiGoalGetNumber(cGoalPlanGoalTypeAttack, -1, true);
   int goalID=-1;
   
   for(j=0; < goalNum)
   {
      goalID=aiGoalGetIDByIndex(cGoalPlanGoalTypeAttack, -1, true, j);
      if (aiPlanGetVariableBool(goalID, cGoalPlanIdleAttack, 0) == true)      
      {
         aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateBase, 0, false);
         aiPlanSetBaseID(goalID, kbBaseGetMainID(cMyID));
         aiPlanSetVariableInt(goalID, cGoalPlanBaseID, 0, kbBaseGetMainID(cMyID));
	 continue;
      }      
      aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateBase, 0, false);
      // TODO: dunno which one is correct
      aiPlanSetBaseID(goalID, forwBase);
      aiPlanSetVariableInt(goalID, cGoalPlanBaseID, 0, forwBase);
      aiPlanSetInitialPosition(goalID, kbBaseGetLocation(cMyID, forwBase));
   }
   goalNum=aiGoalGetNumber(cGoalPlanGoalTypeAttack, -1, false);
   
   for(j=0; < goalNum)
   {
      goalID=aiGoalGetIDByIndex(cGoalPlanGoalTypeAttack, -1, false, j);
      if (aiPlanGetVariableBool(goalID, cGoalPlanIdleAttack, 0) == true)
      {
         aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateBase, 0, false);
         aiPlanSetBaseID(goalID, kbBaseGetMainID(cMyID));
         aiPlanSetVariableInt(goalID, cGoalPlanBaseID, 0, kbBaseGetMainID(cMyID));
	 continue;
      }      
      aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateBase, 0, false);
      // TODO: dunno which one is correct
      aiPlanSetBaseID(goalID, forwBase);
      aiPlanSetVariableInt(goalID, cGoalPlanBaseID, 0, forwBase);
      aiPlanSetInitialPosition(goalID, kbBaseGetLocation(cMyID, forwBase));
   }
   gForwBaseID=forwBase;
}
*/
//==============================================================================
/*
   Forward base manager
   
Handles the planning, construction, defense and maintenance of a forward military base.

The steps involved:
1)  Choose a location
2)  Defend it and send a fort wagon to build a fort.
3)  Define it as the military base, move defend plans there, move military production there.
4)  Undo those settings if it needs to be abandoned.

*/
//==============================================================================

rule forwardBaseManager
inactive
group tcComplete
minInterval 46
{
   
   if ( (cvOkToBuild == false) || (cvOkToBuildForts == false) || (aiTreatyActive() == true) )
      return;
	  if (kbGetAge() > cAge2)
	  {
       xsDisableSelf();
       return;
	  }

//   if ((kbGetAge() < cAge3) && (gInitialStrategy == 0)||(gInitialStrategy == 2)||(gInitialStrategy == 3))
//      return;   
   
   switch(gForwardBaseState)
   {
      case cForwardBaseStateNone:
      {
         int i=0;
	 i= aiRandInt(3);
	 while(i<3)
	 {
	    if (kbGetAge() >= cAge2)
            {  // Start a new forward base build plan               
               gForwardBaseLocation = selectForwardBaseLocation();
               gForwardBaseBuildPlan = aiPlanCreate("Forward Base plan ", cPlanBuild);
               if (kbGetCiv() == cCivRussians)          
               {
		  //if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  //else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gArtilleryDepotUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
               if( (kbGetCiv() == cCivGermans) || (kbGetCiv() == cCivDutch) || (kbGetCiv() == cCivOttomans) || (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivFrench) || (kbGetCiv() == cCivSpanish) || (kbGetCiv() == cCivPortuguese) )
	       {
            //      if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  //else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gArtilleryDepotUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if( kbGetCiv() == cCivXPAztec )
	       {
		  //if ( (i==0) || (i==1) )
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeNoblesHut);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if( kbGetCiv() == cCivXPIroquois )
	       {
		  //if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  //else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gArtilleryDepotUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if( kbGetCiv() == cCivXPSioux )
	       {
		  //if ( (i==0)||(i==1) )
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
	       {
		  //if ( (i==0)||(i==1) )
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
	       {
		  //if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  //else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) )
	       {
		  //if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  //else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
            //aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeFortFrontier);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
			aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeNoblesHut);
            aiPlanSetDesiredPriority(gForwardBaseBuildPlan, 87);
            // Military
            aiPlanSetMilitary(gForwardBaseBuildPlan, true);
            // Escrow.
            aiPlanSetEscrowID(gForwardBaseBuildPlan, cMilitaryEscrowID);                    
            // Builders.
            aiPlanAddUnitType(gForwardBaseBuildPlan, gEconUnit, 2, 2, 2);
            
            // Instead of base ID or areas, use a center position
            aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanCenterPosition, 0, gForwardBaseLocation);
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanCenterPositionDistance, 0, 150.0);
     
            // Weight it to stay very close to center point.
            aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanInfluencePosition, 0, gForwardBaseLocation);    // Position influence for center
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionDistance, 0,  150.0);     // 100m range.
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionValue, 0, 100.0);        // 100 points for center
            aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
                    
            // Add position influence for nearby towers   
	    if (kbGetCiv() == cCivRussians)          
            {
	       //if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	       //else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	       //else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gArtilleryDepotUnit);
	    }
            if ( (kbGetCiv() == cCivGermans) || (kbGetCiv() == cCivDutch) || (kbGetCiv() == cCivOttomans) || (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivFrench) || (kbGetCiv() == cCivSpanish) || (kbGetCiv() == cCivPortuguese) )
	    {
               //if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	      // else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gArtilleryDepotUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	    }
	    if( kbGetCiv() == cCivXPAztec )
	    {
	      // if ( (i==0)||(i==1) )
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeNoblesHut);
	    }
	    if ( kbGetCiv() == cCivXPIroquois )
	    {
	      // if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	     //  else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gArtilleryDepotUnit);
	    }
	    if ( kbGetCiv() == cCivXPSioux )
	    {
	      // if ((i==0)||(i==1))
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
            }
	    if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
	    {
	     //  if ((i==0)||(i==1))
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	    }
	    if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
	    {
	    //   if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	      // else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	    }
	    if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) )
	    {
	      // if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	      // else if(i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	    }
            
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitDistance, 0, 10.0);    
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitValue, 0, 200.0);        
            aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffNone);
		 
            aiPlanSetActive(gForwardBaseBuildPlan);
			
	    sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillBuildMilitaryBase, gForwardBaseLocation);
            
            gForwardBaseState = cForwardBaseStateBuilding;               
            aiEcho("BUILDING FORWARD BASE, MOVING DEFEND PLANS TO COVER.");
            aiEcho("PLANNED LOCATION IS "+gForwardBaseLocation);              
           
            if (gDefenseReflex == false)
               endDefenseReflex();  // Causes it to move to the new location
            }
            break;
         }
      }
      case cForwardBaseStateBuilding:
      {
         int fortUnitID = getUnitByLocation(cUnitTypeFortFrontier, cMyID, cUnitStateAlive, gForwardBaseLocation, 300.0);
         int militaryBuildingID = getUnitByLocation(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive, gForwardBaseLocation, 300.0);
         if ( (fortUnitID >= 0) || (militaryBuildingID >= 0) )
         {  // Building exists and is complete, go to state Active
            if (kbUnitGetBaseID(fortUnitID) >= 0)
            {  // Base has been created for it.
               gForwardBaseState = cForwardBaseStateActive;
               gForwardBaseID = kbUnitGetBaseID(fortUnitID);
               gForwardBaseLocation = kbUnitGetPosition(fortUnitID);  
               aiEcho("Forward base location is "+gForwardBaseLocation+", Base ID is "+gForwardBaseID+", Unit ID is "+fortUnitID);
               // Tell the attack goal where to go.
               aiPlanSetBaseID(gMainAttackGoal, gForwardBaseID);
               aiEcho(" ");
               aiEcho("FORWARD BASE COMPLETED, GOING TO STATE ACTIVE, MOVING ATTACK GOAL.");
               aiEcho(" ");
            }
            else if (kbUnitGetBaseID(militaryBuildingID) >= 0)
            {  
               // Base has been created for it.
               gForwardBaseState = cForwardBaseStateActive;
               gForwardBaseID = kbUnitGetBaseID(militaryBuildingID);
               gForwardBaseLocation = kbUnitGetPosition(militaryBuildingID);  
               aiEcho("Forward base location is "+gForwardBaseLocation+", Base ID is "+gForwardBaseID+", Unit ID is "+militaryBuildingID);
               // Tell the attack goal where to go.
               aiPlanSetBaseID(gMainAttackGoal, gForwardBaseID);
               aiEcho(" ");
               aiEcho("FORWARD BASE COMPLETED, GOING TO STATE ACTIVE, MOVING ATTACK GOAL.");
               aiEcho(" ");
            }
            else
            {
               aiEcho(" ");
               aiEcho("FORT COMPLETE, WAITING FOR FORWARD BASE ID.");
               aiEcho(" ");
            }
         }
         else  // Check if plan still exists. If not, go back to state 'none'.
         {
            if (aiPlanGetState(gForwardBaseBuildPlan) < 0)
            {  // It failed?
               gForwardBaseState = cForwardBaseStateNone;
               gForwardBaseLocation = cInvalidVector;
               gForwardBaseID = -1;
               gForwardBaseBuildPlan = -1;
               aiEcho(" ");
               aiEcho("FORWARD BASE PLAN FAILED, RETURNING TO STATE NONE.");
               aiEcho(" ");
            }
         }
         
         break;
      }
      case cForwardBaseStateActive:
      {  // Normal state.  If fort is destroyed and base overrun, bail.
         if ( (getUnitByLocation(cUnitTypeFortFrontier, cMyID, cUnitStateAlive, gForwardBaseLocation, 50.0) < 0) ||
              (getUnitByLocation(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive, gForwardBaseLocation, 50.0) < 0) )
         {
            // Fort is missing, is base still OK?  
            if ( ((gDefenseReflexBaseID == gForwardBaseID) && (gDefenseReflexPaused == true)) ||
                  (gDefenseReflexBaseID == kbBaseGetMainID(cMyID)) ||
                  (kbBaseGetNumberUnits(cMyID, gForwardBaseID, cPlayerRelationSelf, cUnitTypeBuilding) < 1))
            {  // No, not OK.  Get outa Dodge.
               gForwardBaseState = cForwardBaseStateNone;
               gForwardBaseID = -1;
               gForwardBaseLocation = cInvalidVector;
               // Tell the attack goal to go back to the main base.
               aiPlanSetBaseID(gMainAttackGoal, kbBaseGetMainID(cMyID));
               endDefenseReflex();
               aiEcho(" ");
               aiEcho("    ABANDONING FORWARD BASE, RETREATING TO MAIN BASE.");
               aiEcho(" ");
            }
         }
         break;
      }
    }
}

rule forwardBaseManagerAge3
inactive
group tcComplete
minInterval 30
{
   
   if ( (cvOkToBuild == false) || (cvOkToBuildForts == false) || (aiTreatyActive() == true) || (kbGetAge() < cAge3))
      return;

   //if (kbGetAge() < cAge4)
   //   return;   
   
   switch(gForwardBaseState)
   {
      case cForwardBaseStateNone:
      {
         int i=0;
	 i=aiRandInt(3);
	 while(i<3)
	 {/*
	    if (kbGetAge() < cAge3)
            {  // Start a new forward base build plan               
               gForwardBaseLocation = selectForwardBaseLocation();
               gForwardBaseBuildPlan = aiPlanCreate("Forward Base plan ", cPlanBuild);
               if (kbGetCiv() == cCivRussians)          
               {
		  //if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  //else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gArtilleryDepotUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
               if( (kbGetCiv() == cCivGermans) || (kbGetCiv() == cCivDutch) || (kbGetCiv() == cCivOttomans) || (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivFrench) || (kbGetCiv() == cCivSpanish) || (kbGetCiv() == cCivPortuguese) )
	       {
            //      if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  //else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gArtilleryDepotUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if( kbGetCiv() == cCivXPAztec )
	       {
		  //if ( (i==0) || (i==1) )
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeNoblesHut);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if( kbGetCiv() == cCivXPIroquois )
	       {
		  //if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  //else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gArtilleryDepotUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if( kbGetCiv() == cCivXPSioux )
	       {
		  //if ( (i==0)||(i==1) )
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
	       {
		  //if ( (i==0)||(i==1) )
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
	       {
		  //if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  //else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) )
	       {
		  //if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  //else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  //else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
            //aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeFortFrontier);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
			aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeNoblesHut);
            aiPlanSetDesiredPriority(gForwardBaseBuildPlan, 87);
            // Military
            aiPlanSetMilitary(gForwardBaseBuildPlan, true);
            // Escrow.
            aiPlanSetEscrowID(gForwardBaseBuildPlan, cMilitaryEscrowID);                    
            // Builders.
            aiPlanAddUnitType(gForwardBaseBuildPlan, gEconUnit, 2, 2, 2);
            
            // Instead of base ID or areas, use a center position
            aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanCenterPosition, 0, gForwardBaseLocation);
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanCenterPositionDistance, 0, 150.0);
     
            // Weight it to stay very close to center point.
            aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanInfluencePosition, 0, gForwardBaseLocation);    // Position influence for center
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionDistance, 0,  150.0);     // 100m range.
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionValue, 0, 100.0);        // 100 points for center
            aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
                    
            // Add position influence for nearby towers   
	    if (kbGetCiv() == cCivRussians)          
            {
	       //if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	       //else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	       //else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gArtilleryDepotUnit);
	    }
            if ( (kbGetCiv() == cCivGermans) || (kbGetCiv() == cCivDutch) || (kbGetCiv() == cCivOttomans) || (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivFrench) || (kbGetCiv() == cCivSpanish) || (kbGetCiv() == cCivPortuguese) )
	    {
               //if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	      // else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gArtilleryDepotUnit);
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	    }
	    if( kbGetCiv() == cCivXPAztec )
	    {
	      // if ( (i==0)||(i==1) )
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeNoblesHut);
	    }
	    if ( kbGetCiv() == cCivXPIroquois )
	    {
	      // if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	     //  else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gArtilleryDepotUnit);
	    }
	    if ( kbGetCiv() == cCivXPSioux )
	    {
	      // if ((i==0)||(i==1))
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
            }
	    if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
	    {
	     //  if ((i==0)||(i==1))
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	    }
	    if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
	    {
	    //   if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	      // else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	    }
	    if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) )
	    {
	      // if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	      // else if(i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	      // else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	    }
            
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitDistance, 0, 10.0);    
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitValue, 0, 200.0);        
            aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffNone);
		 
            aiPlanSetActive(gForwardBaseBuildPlan);
			
	    sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillBuildMilitaryBase, gForwardBaseLocation);
            
            gForwardBaseState = cForwardBaseStateBuilding;               
            aiEcho("BUILDING FORWARD BASE, MOVING DEFEND PLANS TO COVER.");
            aiEcho("PLANNED LOCATION IS "+gForwardBaseLocation);              
           
            if (gDefenseReflex == false)
               endDefenseReflex();  // Causes it to move to the new location
            }
			else*/
	    if (kbGetAge() > cAge2)
            {  // Start a new forward base build plan               
               gForwardBaseLocation = selectForwardBaseLocation();
               gForwardBaseBuildPlan = aiPlanCreate("Forward Base plan ", cPlanBuild);
               if (kbGetCiv() == cCivRussians)          
               {
		  if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gArtilleryDepotUnit);
	       }
               if( (kbGetCiv() == cCivGermans) || (kbGetCiv() == cCivDutch) || (kbGetCiv() == cCivOttomans) || (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivFrench) || (kbGetCiv() == cCivSpanish) || (kbGetCiv() == cCivPortuguese) )
	       {
                  if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gArtilleryDepotUnit);
	       }
	       if( kbGetCiv() == cCivXPAztec )
	       {
		  if ( (i==0) || (i==1) )
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeNoblesHut);
	       }
	       if( kbGetCiv() == cCivXPIroquois )
	       {
		  if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gArtilleryDepotUnit);
	       }
	       if( kbGetCiv() == cCivXPSioux )
	       {
		  if ( (i==0)||(i==1) )
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		  else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
	       }
	       if( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
	       {
		  if ( (i==0)||(i==1) )
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
	       {
		  if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
	       if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) )
	       {
		  if (i==0)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gBarracksUnit);
		  else if (i==1)
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gStableUnit);
		  else
		    aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
	       }
            //aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeFortFrontier);
            aiPlanSetDesiredPriority(gForwardBaseBuildPlan, 87);
            // Military
            aiPlanSetMilitary(gForwardBaseBuildPlan, true);
            // Escrow.
            aiPlanSetEscrowID(gForwardBaseBuildPlan, cMilitaryEscrowID);                    
            // Builders.
            aiPlanAddUnitType(gForwardBaseBuildPlan, gEconUnit, 1, 1, 1);
            
            // Instead of base ID or areas, use a center position
            aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanCenterPosition, 0, gForwardBaseLocation);
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanCenterPositionDistance, 0, 60.0);
     
            // Weight it to stay very close to center point.
            aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanInfluencePosition, 0, gForwardBaseLocation);    // Position influence for center
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionDistance, 0,  50.0);     // 100m range.
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionValue, 0, 100.0);        // 100 points for center
            aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
                    
            // Add position influence for nearby towers   
	    if (kbGetCiv() == cCivRussians)          
            {
	       if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	       else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	       else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gArtilleryDepotUnit);
	    }
            if ( (kbGetCiv() == cCivGermans) || (kbGetCiv() == cCivDutch) || (kbGetCiv() == cCivOttomans) || (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivFrench) || (kbGetCiv() == cCivSpanish) || (kbGetCiv() == cCivPortuguese) )
	    {
               if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	       else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	       else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gArtilleryDepotUnit);
	    }
	    if( kbGetCiv() == cCivXPAztec )
	    {
	       if ( (i==0)||(i==1) )
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	       else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeNoblesHut);
	    }
	    if ( kbGetCiv() == cCivXPIroquois )
	    {
	       if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	       else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	       else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gArtilleryDepotUnit);
	    }
	    if ( kbGetCiv() == cCivXPSioux )
	    {
	       if ((i==0)||(i==1))
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	       else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
            }
	    if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
	    {
	       if ((i==0)||(i==1))
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	       else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	    }
	    if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
	    {
	       if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	       else if (i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	       else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	    }
	    if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) )
	    {
	       if (i==0)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gBarracksUnit);
	       else if(i==1)
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gStableUnit);
	       else
		 aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);
	    }
            
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitDistance, 0, 50.0);    
            aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitValue, 0, -200.0);        
            aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffNone);

            aiPlanSetActive(gForwardBaseBuildPlan);
			
	    sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillBuildMilitaryBase, gForwardBaseLocation);
            
            gForwardBaseState = cForwardBaseStateBuilding;               
            aiEcho("BUILDING FORWARD BASE, MOVING DEFEND PLANS TO COVER.");
            aiEcho("PLANNED LOCATION IS "+gForwardBaseLocation);              
           
            if (gDefenseReflex == false)
               endDefenseReflex();  // Causes it to move to the new location
            }
            break;
         }
      }
      case cForwardBaseStateBuilding:
      {
         int fortUnitID = getUnitByLocation(cUnitTypeFortFrontier, cMyID, cUnitStateAlive, gForwardBaseLocation, 200.0);
         int militaryBuildingID = getUnitByLocation(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive, gForwardBaseLocation, 200.0);
         if ( (fortUnitID >= 0) || (militaryBuildingID >= 0) )
         {  // Building exists and is complete, go to state Active
            if (kbUnitGetBaseID(fortUnitID) >= 0)
            {  // Base has been created for it.
               gForwardBaseState = cForwardBaseStateActive;
               gForwardBaseID = kbUnitGetBaseID(fortUnitID);
               gForwardBaseLocation = kbUnitGetPosition(fortUnitID);  
               aiEcho("Forward base location is "+gForwardBaseLocation+", Base ID is "+gForwardBaseID+", Unit ID is "+fortUnitID);
               // Tell the attack goal where to go.
               aiPlanSetBaseID(gMainAttackGoal, gForwardBaseID);
               aiEcho(" ");
               aiEcho("FORWARD BASE COMPLETED, GOING TO STATE ACTIVE, MOVING ATTACK GOAL.");
               aiEcho(" ");
            }
            else if (kbUnitGetBaseID(militaryBuildingID) >= 0)
            {  
               // Base has been created for it.
               gForwardBaseState = cForwardBaseStateActive;
               gForwardBaseID = kbUnitGetBaseID(militaryBuildingID);
               gForwardBaseLocation = kbUnitGetPosition(militaryBuildingID);  
               aiEcho("Forward base location is "+gForwardBaseLocation+", Base ID is "+gForwardBaseID+", Unit ID is "+militaryBuildingID);
               // Tell the attack goal where to go.
               aiPlanSetBaseID(gMainAttackGoal, gForwardBaseID);
               aiEcho(" ");
               aiEcho("FORWARD BASE COMPLETED, GOING TO STATE ACTIVE, MOVING ATTACK GOAL.");
               aiEcho(" ");
            }
            else
            {
               aiEcho(" ");
               aiEcho("FORT COMPLETE, WAITING FOR FORWARD BASE ID.");
               aiEcho(" ");
            }
         }
         else  // Check if plan still exists. If not, go back to state 'none'.
         {
            if (aiPlanGetState(gForwardBaseBuildPlan) < 0)
            {  // It failed?
               gForwardBaseState = cForwardBaseStateNone;
               gForwardBaseLocation = cInvalidVector;
               gForwardBaseID = -1;
               gForwardBaseBuildPlan = -1;
               aiEcho(" ");
               aiEcho("FORWARD BASE PLAN FAILED, RETURNING TO STATE NONE.");
               aiEcho(" ");
            }
         }
         
         break;
      }
      case cForwardBaseStateActive:
      {  // Normal state.  If fort is destroyed and base overrun, bail.
         if ( (getUnitByLocation(cUnitTypeFortFrontier, cMyID, cUnitStateAlive, gForwardBaseLocation, 50.0) < 0) ||
              (getUnitByLocation(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive, gForwardBaseLocation, 50.0) < 0) )
         {
            // Fort is missing, is base still OK?  
            if ( ((gDefenseReflexBaseID == gForwardBaseID) && (gDefenseReflexPaused == true)) ||
                  (gDefenseReflexBaseID == kbBaseGetMainID(cMyID)) ||
                  (kbBaseGetNumberUnits(cMyID, gForwardBaseID, cPlayerRelationSelf, cUnitTypeBuilding) < 1))
            {  // No, not OK.  Get outa Dodge.
               gForwardBaseState = cForwardBaseStateNone;
               gForwardBaseID = -1;
               gForwardBaseLocation = cInvalidVector;
               // Tell the attack goal to go back to the main base.
               aiPlanSetBaseID(gMainAttackGoal, kbBaseGetMainID(cMyID));
               endDefenseReflex();
               aiEcho(" ");
               aiEcho("    ABANDONING FORWARD BASE, RETREATING TO MAIN BASE.");
               aiEcho(" ");
            }
         }
         break;
      }
    }
}

void deathMatchSetup(void)
{  // Make a bunch of changes to get a deathmatch start
   aiEcho("RUNNING DEATHMATCH SETUP");
   // 10 houses, pronto.
   if (cMyCiv != cCivXPSioux)
      createSimpleBuildPlan(gHouseUnit, 10, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      //createLocationBuildPlan(gHouseUnit, 10, 99, true, cEconomyEscrowID, gHousePosition, 1);
   
   gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);   // Load up on castles.
   
   xsEnableRule("turtleUp");   
   xsEnableRule("deathMatch");
}

rule deathMatch
inactive
minInterval 40
{
    if (xsGetTime() > 90000)
    {
       xsDisableSelf();
       return;
    }

    // 2 each of the main military buildings, ASAP.
   if ( (civIsNative() == false) && (civIsAsian() == false) )
   {
      createSimpleBuildPlan(gBarracksUnit, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      createSimpleBuildPlan(gStableUnit, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);

      if (cMyCiv == cCivGermans)
         createSimpleBuildPlan(gFarmUnit, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   else if (civIsAsian() == true) 
   {
      if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) 
      {
        createSimpleBuildPlan(gBarracksUnit, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
        createSimpleBuildPlan(gStableUnit, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      else if ( (cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese) )
      {   createSimpleBuildPlan(gBarracksUnit, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);   }
      else 
      {
        createSimpleBuildPlan(gBarracksUnit, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
        createSimpleBuildPlan(gStableUnit, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      //createSimpleBuildPlan(cUnitTypeypCastle, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   else
   {      
      //createSimpleBuildPlan(cUnitTypeWarHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      if (cMyCiv == cCivXPAztec)
         createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      else
         createSimpleBuildPlan(gStableUnit, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }
   if ( (civIsNative() == false) || (cMyCiv == cCivXPIroquois) ) 
   {
      if (civIsAsian() == false)
        createSimpleBuildPlan(gArtilleryDepotUnit, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      //else
       // createSimpleBuildPlan(cUnitTypeypCastle, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
   }

   xsEnableRule("moreDMHouses");
}

rule moreDMHouses
inactive
minInterval 80
{  // After 90 seconds, make 10 more houses
   if (cMyCiv != cCivXPSioux)
      createSimpleBuildPlan(gHouseUnit, 10, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      //createLocationBuildPlan(gHouseUnit, 10, 99, true, cEconomyEscrowID, gHousePosition, 1);
   
   xsEnableRule("finalDMHouses");
}

rule finalDMHouses
inactive
minInterval 100
{         
   int count = kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive);
   int max = kbGetBuildLimit(cMyID, gHouseUnit);
   
   count = max - count; // Count is number needed.
   if ( aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit) >= 0 )
      count = count - 1;
   if (cMyCiv == cCivXPSioux)
      count = 0;
   
   if (count > 0)
      createSimpleBuildPlan(gHouseUnit, count, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      //createLocationBuildPlan(gHouseUnit, count, 99, true, cEconomyEscrowID, gHousePosition, 1);
   
   xsDisableSelf();
}


//==============================================================================
/*
   Military Manager
   
   Create maintain plans for military unit lines.  Control 'maintain' levels,
   buy upgrades.  
*/
//==============================================================================
rule militaryManager
inactive
minInterval 5
{
   
   static bool init = false;   // Flag to indicate vars, plans are initialized
   int i = 0;
   int proto = 0;
   int planID = -1;
   
   if (init == false)
   {     
      // Need to initialize, if we're allowed to.
      if (cvOkToTrainArmy == true)
      {
         init = true;         
         if (cvNumArmyUnitTypes >= 0)
            gNumArmyUnitTypes = cvNumArmyUnitTypes;
         else
            gNumArmyUnitTypes = 3;
         
         gLandUnitPicker = initUnitPicker("Land military units", gNumArmyUnitTypes, 1, 30, -1, -1, 1, true);

         // now the goal
         // wmj -- hard coded for now, but this should most likely ramp up as the ages progress
         aiSetMinArmySize  (25 * kbGetAge() - 25); //(gGoodArmyPop+50);
   
         gMainAttackGoal = createSimpleAttackGoal("AttackGoal", aiGetMostHatedPlayerID(), gLandUnitPicker, -1, cAge2, -1, gMainBase, true);
         aiPlanSetVariableInt(gMainAttackGoal, cGoalPlanReservePlanID, 0, gLandReservePlan);
      }
   }

   if (gLandUnitPicker != -1)
   {  
      setUnitPickerPreference(gLandUnitPicker);  // Update preferences in case btBiasEtc vars have changed, or cvPrimaryArmyUnit has changed.
      
      if ((kbGetAge() < cAge3) && (xsGetTime() < 10*60*1000) && ( agingUp() == false ))
      {
	 kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 1);
	 kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, 20); // gGoodArmyPop);
      }
	  else
      if ((kbGetAge() < cAge3) && (xsGetTime() > 15*60*1000) && ( agingUp() == false ))
      {
	 kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 1);
	 kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, 20); // gGoodArmyPop);
      }
	  else
      {
	 kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 1);
	 kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, 20);
      }
	  
      if ((kbGetAge() < cAge4) && (xsGetTime() > 20*60*1000) && ( agingUp() == false ))
      {
	 kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 1);
	 kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, 30); // gGoodArmyPop);
      }
	  else
      {
	 kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 1);
	 kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, 30); // gGoodArmyPop);
      }
	  
      if ((kbGetAge() < cAge5) && (xsGetTime() > 25*60*1000) && ( agingUp() == false ))
      {
	 kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 1);
	 kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, 40); // gGoodArmyPop);
      }
	  else
      {
	 kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 1);
	 kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, 40); // gGoodArmyPop);
      }
	  
      if (kbGetAge() == cAge5)
      {
	 kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 1);
	 kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, 60); // gGoodArmyPop);
      }
   }
   
   switch(kbGetAge())
   {
      case cAge1:
      {
         break;
      }
      case cAge2:
      {
         aiSetMinArmySize(25); // Now irrelevant?  (Was used to determine when to launch attack, but attack goal and opp scoring now do this.)
         break;
      }
      case cAge3:
      {
         aiSetMinArmySize(50);
         break;
      }
      case cAge4:
      {
         aiSetMinArmySize(75);
         break;
      }
      case cAge5:
      {
         aiSetMinArmySize(100);
         break;
      }
   }   
}

int getNavalTargetPlayer()    // Find an enemy player ID to attack on the water.
{
   int count = 0;
   int retVal = -1;
   static int unitQueryID = -1;

   //If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID=kbUnitQueryCreate("navy target count");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
      kbUnitQuerySetPlayerRelation(unitQueryID, cPlayerRelationEnemyNotGaia);
   }
   
   kbUnitQuerySetUnitType(unitQueryID, gDockUnit);   // dock
   kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
   kbUnitQueryResetResults(unitQueryID);
   count = kbUnitQueryExecute(unitQueryID);  
   //aiEcho("Enemy fishing boats: "+ count);
   if (count > 0)
   {  retVal = kbUnitGetPlayerID(kbUnitQueryGetResult(unitQueryID,0));  }
   else
   {    
      kbUnitQuerySetUnitType(unitQueryID, gFishingUnit);   // Fishing boats
      kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
      kbUnitQueryResetResults(unitQueryID);
      count = kbUnitQueryExecute(unitQueryID);  
      //aiEcho("Enemy fishing boats: "+ count);
      if (count > 3)
	{  retVal = kbUnitGetPlayerID(kbUnitQueryGetResult(unitQueryID,0));  }
   }     
   return(retVal);
}

rule waterAttackDefend
active
minInterval 13
{  
   // Broke this out separately (from navyManager) so that scenarios that start with a pre-made navy will work.
   if (cvInactiveAI == true)
   {
      xsDisableSelf();
      return;
   }

   int navyUnit = getUnit(cUnitTypeAbstractWarShip, cMyID, cUnitStateAlive);

   if (navyUnit < 0)
      return;
     
   int flagUnit = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
   if (flagUnit >= 0)
      gNavyVec = kbUnitGetPosition(flagUnit);
   else
      gNavyVec = kbUnitGetPosition(navyUnit);
   
   if (gNavyDefendPlan < 0)
   {
      gNavyDefendPlan = aiPlanCreate("Primary Water Defend", cPlanDefend);      
      aiPlanAddUnitType(gNavyDefendPlan, cUnitTypeAbstractWarShip , 1, 1, 200);    // Grab first caravel and any others 
      aiPlanAddUnitType(gNavyDefendPlan, cUnitTypeCanoe, 1, 10, 20);       
      aiPlanSetVariableVector(gNavyDefendPlan, cDefendPlanDefendPoint, 0, gNavyVec);
      aiPlanSetVariableFloat(gNavyDefendPlan, cDefendPlanEngageRange, 0, 300.0);    // Loose
      aiPlanSetVariableBool(gNavyDefendPlan, cDefendPlanPatrol, 0, false);
      aiPlanSetVariableFloat(gNavyDefendPlan, cDefendPlanGatherDistance, 0, 80.0);
      aiPlanSetInitialPosition(gNavyDefendPlan, gNavyVec);
      aiPlanSetUnitStance(gNavyDefendPlan, cUnitStanceDefensive);
      aiPlanSetVariableInt(gNavyDefendPlan, cDefendPlanRefreshFrequency, 0, 1);
      aiPlanSetVariableInt(gNavyDefendPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
      aiPlanSetDesiredPriority(gNavyDefendPlan, 20);    // Very low priority, gather unused units.
      aiPlanSetActive(gNavyDefendPlan); 
      aiEcho("Creating primary navy defend plan at "+gNavyVec);
   }
  
   if (((aiPlanGetNumberUnits(gNavyDefendPlan, cUnitTypeAbstractWarShip) >= 3 ) && (civIsNative() == false)) ||      
       ((aiPlanGetNumberUnits(gNavyDefendPlan, cUnitTypeAbstractWarShip) >= 6 ) && (civIsNative() == true))) 
   {  // Time to start an attack?
      if (getNavalTargetPlayer() >= 0)  // There's something to attack
      {
         int targetID = -1;
	 int targetPlayerID = -1;
	 vector targetLocation = cInvalidVector;

         targetID = getUnit(gFishingUnit, cPlayerRelationEnemyNotGaia, cUnitStateAlive);
         if (targetID < 0)
	 {
	    targetID = getUnit(cUnitTypeAbstractWarShip, cPlayerRelationEnemyNotGaia, cUnitStateAlive);
	    if (targetID < 0)
	      targetID = getUnit(gDockUnit, cPlayerRelationEnemyNotGaia, cUnitStateAlive);
         }

         targetPlayerID = kbUnitGetPlayerID(targetID); 
	 targetLocation = kbUnitGetPosition(targetID);

         int attackPlan = aiPlanCreate("Navy attack plan", cPlanAttack);
         aiPlanSetVariableInt(attackPlan, cAttackPlanPlayerID, 0, targetPlayerID);
         aiPlanSetNumberVariableValues(attackPlan, cAttackPlanTargetTypeID, 5, true);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 0, cUnitTypeAbstractWarShip);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 1, gFishingUnit);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 2, gDockUnit);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 3, cUnitTypeUnit);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 4, cUnitTypeBuilding);
         aiPlanSetVariableVector(attackPlan, cAttackPlanGatherPoint, 0, targetLocation);
         aiPlanSetVariableFloat(attackPlan, cAttackPlanGatherDistance, 0, 50.0);
         aiPlanSetVariableInt(attackPlan, cAttackPlanRefreshFrequency, 0, 1);
         aiPlanSetDesiredPriority(attackPlan, 48); // Above defend, fishing.  Below explore.
         aiPlanAddUnitType(attackPlan, cUnitTypeAbstractWarShip, 1, 10, 30);
         aiPlanAddUnitType(attackPlan, cUnitTypeCanoe, 5, 10, 20);  
         aiPlanSetInitialPosition(attackPlan, gNavyVec);
         aiEcho("***** LAUNCHING NAVAL ATTACK, plan ID is "+attackPlan); 
         aiPlanSetActive(attackPlan, true);
      }
   } 
}

//==============================================================================
/*
   Navy Manager
   
   Create maintain plans for navy unit lines.  Control 'maintain' levels.
*/
//==============================================================================
rule navyManager
inactive
minInterval 40
{

   if (gNavyMap == false)
   {
      gNavyMode = cNavyModeOff;
      aiEcho("gNavyMap was false, turning off navy manager.");
      xsDisableSelf();
      return;
   }
   
   vector flagVec =  cInvalidVector;
   int flagUnit = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
   if (flagUnit >= 0)
   {      
      flagVec = kbUnitGetPosition(flagUnit);
   }
   else
   {
      int closestDock = getUnitByLocation(gDockUnit, cMyID, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 500.0);
      if (closestDock >= 0)
         flagVec = kbUnitGetPosition(closestDock);
   }
   if ( (gNavyVec == cInvalidVector) && (flagVec != cInvalidVector) )
      gNavyVec = flagVec;   // Set global vector   
     
   closestDock = getUnitByLocation(gDockUnit, cMyID, cUnitStateAlive, flagVec, 500.0);
   if (closestDock < 0)
      closestDock = getUnit(gDockUnit, cMyID, cUnitStateAlive);
   
   if(gWaterExplorePlan < 0)
   {
      vector location = cInvalidVector;
      if (getUnit(gTransportUnit, cMyID, cUnitStateAlive) >= 0)
         location = kbUnitGetPosition(getUnit(gTransportUnit, cMyID, cUnitStateAlive));
      else
         location = kbAreaGetCenter(kbAreaGetClosetArea(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), cAreaTypeWater, cAreaTypeWater, -1.0) );
      gWaterExplorePlan=aiPlanCreate("Water Explore", cPlanExplore);
      aiPlanSetVariableBool(gWaterExplorePlan, cExplorePlanReExploreAreas, 0, false);
      aiPlanSetInitialPosition(gWaterExplorePlan, location);
      aiPlanSetDesiredPriority(gWaterExplorePlan, 45);   // Low, so that transport plans can steal it as needed.
      aiPlanAddUnitType(gWaterExplorePlan, gTransportUnit, 1, 1, 1);
      aiPlanSetEscrowID(gWaterExplorePlan, cEconomyEscrowID);
      aiPlanSetVariableBool(gWaterExplorePlan, cExplorePlanDoLoops, 0, false);
      aiPlanSetActive(gWaterExplorePlan);
   }

   if (closestDock < 0)
      return;  // Don't fire up maintain plans until we have a dock
   
   int baseID = kbUnitGetBaseID(closestDock);
   if (baseID < 0) 
      return;  // Don't fire up maintain plans until we have a base ID
   
      
   //See if we have any enemy warships running around.
   int numberEnemyWarships=0;
   int numberEnemyFishingBoat=0;
   //Find the largest warship count for any of our enemies.
   for (i=0; < cNumberPlayers)
   {
      if ((kbIsPlayerEnemy(i) == true) &&
         (kbIsPlayerResigned(i) == false) &&
         (kbHasPlayerLost(i) == false))
      {
         int tempNumberEnemyWarships=kbUnitCount(i, cUnitTypeAbstractWarShip, cUnitStateAlive);  
         int tempNumberEnemyFishingBoat=kbUnitCount(i, gFishingUnit, cUnitStateAlive);       
         if (tempNumberEnemyWarships > numberEnemyWarships)
            numberEnemyWarships=tempNumberEnemyWarships;
         if (tempNumberEnemyFishingBoat > numberEnemyFishingBoat)
            numberEnemyFishingBoat=tempNumberEnemyFishingBoat;
      }
   }

   //Figure out the min/max number of warships we want.
   int numCaravel = 0;
   int numGalleon = 0;
   int numFrigate = 0;
   int numMonitor = 0;
   int numCanoe = 0;

   if ( (numberEnemyWarships > 0) || (numberEnemyFishingBoat > 0) )
   {
      gNavyMode = cNavyModeActive;
      numCaravel = kbGetBuildLimit(cMyID, gCaravelUnit);
      numGalleon = kbGetBuildLimit(cMyID, gGalleonUnit);
      numFrigate = kbGetBuildLimit(cMyID, gFrigateUnit);
      numMonitor = kbGetBuildLimit(cMyID, cUnitTypeMonitor);
      numCanoe = kbGetBuildLimit(cMyID, cUnitTypeCanoe);
 
      gCaravelMaintain = createSimpleMaintainPlan(gCaravelUnit, numCaravel, true, baseID, 1);
      gGalleonMaintain = createSimpleMaintainPlan(gGalleonUnit, numGalleon, true, baseID, 1);
      gFrigateMaintain = createSimpleMaintainPlan(gFrigateUnit, numFrigate, true, baseID, 1);
      gMonitorMaintain = createSimpleMaintainPlan(cUnitTypeMonitor, numMonitor, true, baseID, 1);
      if (civIsNative() == false)
        gCanoeMaintain = createSimpleMaintainPlan(cUnitTypeCanoe, numCanoe, true, baseID, 1);

      aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, numCaravel);
      aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, numGalleon);
      aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, numFrigate);
      aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, numMonitor);
      aiPlanSetVariableInt(gCanoeMaintain, cTrainPlanNumberToMaintain, 0, numCanoe);
   }
}

//==============================================================================
// RULE dockMonitor
//==============================================================================
rule dockMonitor
inactive
group tcComplete
minInterval 40
{
   // Quit and disable immediately if we're not on a water map
   if (gNavyMap == false)
   {
      xsDisableSelf();
      return;
   }

   if (kbResourceGet(cResourceWood) < 600)
     return;

   int numDocks=kbUnitCount(cMyID, gDockUnit, cUnitStateAlive);

   // everything ok. we have enough docks
   if ((numDocks >= kbGetAge()) || aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gDockUnit) >= 5)
      return;

   static int areaID=-1;
   if (areaID == -1)
     areaID=kbAreaGetClosetArea(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), cAreaTypeWater);

   int flagUnit = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
   vector flagVec = kbUnitGetPosition(flagUnit);
   if ( (gNavyVec == cInvalidVector) && (flagVec != cInvalidVector) )
      gNavyVec = flagVec;   // Set global vector 

   int dockPlan = aiPlanCreate("military dock plan", cPlanBuild);
   if (dockPlan >= 0) 
   { 
      aiPlanSetVariableInt(dockPlan, cBuildPlanBuildingTypeID, 0, gDockUnit);
      // Priority.
      aiPlanSetDesiredPriority(dockPlan, 80);
      // Mil vs. Econ.     
      aiPlanSetMilitary(dockPlan, false);
      aiPlanSetEconomy(dockPlan, true);         
     
      // Escrow.
      aiPlanSetEscrowID(dockPlan, cEconomyEscrowID);
      // Builders. //BHG - check for the new dockwagon, mostly for the honhsu map
      if (kbUnitCount(cMyID, cUnitTypeYPDockWagon, cUnitStateAlive) > 0) 
      {  aiPlanAddUnitType(dockPlan, cUnitTypeYPDockWagon, 1, 1, 1); }
      else 
      {  aiPlanAddUnitType(dockPlan, gEconUnit, 1, 1, 1); }
      
      aiPlanSetNumberVariableValues(dockPlan, cBuildPlanDockPlacementPoint, 3, true);
      aiPlanSetVariableVector(dockPlan, cBuildPlanDockPlacementPoint, 0, gNavyVec);  // One point at flag unit
      aiPlanSetVariableVector(dockPlan, cBuildPlanDockPlacementPoint, 1, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))); // One point at main base
      aiPlanSetVariableVector(dockPlan, cBuildPlanDockPlacementPoint, 2, kbAreaGetCenter(areaID));   // One point at coast
           
      aiPlanSetActive(dockPlan);
      aiEcho("**** STARTING NAVY DOCK PLAN, plan ID "+dockPlan);      
   }
}

//==============================================================================
// setMilitaryUnitCostForecast
// Checks the current age, looks into the appropriate unit picker,
// calculates approximate resource needs for the next few (3?) minutes,
// adds this amount to the global vars.
//==============================================================================
/*void setMilitaryUnitCostForecast(void)
{
   int upID = -1;		// ID of the unit picker to query
   float totalAmount = 0.0;	// Total resources to be spent in near future
   
   if ((kbGetAge() == cAge2) && (xsGetTime() > 15*60*1000) && ( agingUp() == false ))
   {
      upID = gLandUnitPicker;
      totalAmount = 1000;
   }
	 else
   {
      upID = gLandUnitPicker;
      totalAmount = 1000;
   }
   
   if ((kbGetAge() == cAge3) && (xsGetTime() > 20*60*1000 && ( agingUp() == false )) //30 minutes
   {
      upID = gLandUnitPicker;
      totalAmount = 1000;
   }
	 else
   {
      upID = gLandUnitPicker;
      totalAmount = 4000;
   }
   
   if ((kbGetAge() == cAge4) && (xsGetTime() > 25*60*1000) && ( agingUp() == false ))
   {
      upID = gLandUnitPicker;
      totalAmount = 1600;
   }
	 else
   {
      upID = gLandUnitPicker;
      totalAmount = 8000;
   }
   if (kbGetAge() == cAge5)
   {
      upID = gLandUnitPicker;
      totalAmount = 20000;
   }
   		
   float goldCost = 0.0;
   float woodCost = 0.0;
   float foodCost = 0.0;
   float totalCost = 0.0;

   int unitID = kbUnitPickGetResult(upID, 0);	// Primary unit
   float weight = 1.0;
   int numUnits = kbUnitPickGetDesiredNumberUnitTypes(upID);

   if (numUnits == 2)
      weight = 0.67; // 2/3 and 1/3
   if (numUnits >= 3)
      weight = 0.50; // 1/2, 1/3, 1/6
   
   goldCost = kbUnitCostPerResource(unitID, cResourceGold);
   woodCost = kbUnitCostPerResource(unitID, cResourceWood);
   foodCost = kbUnitCostPerResource(unitID, cResourceFood);
   totalCost = goldCost+woodCost+foodCost;
	
   gForecasts = gForecasts + (goldCost+woodCost+foodCost) * (totalAmount*weight/totalCost);
     
   if (numUnits > 1)
   {  // Do second unit
      unitID = kbUnitPickGetResult(upID, 1);    // Secondary unit
      weight = 0.33;    // Second is 1/3 regardless 
      
      goldCost = kbUnitCostPerResource(unitID, cResourceGold);
      woodCost = kbUnitCostPerResource(unitID, cResourceWood);
      foodCost = kbUnitCostPerResource(unitID, cResourceFood);
      totalCost = goldCost+woodCost+foodCost;
	   
      gForecasts = gForecasts + (goldCost+woodCost+foodCost) * (totalAmount*weight/totalCost);      
   }

   if (numUnits > 2)
   {  // Do third unit
      unitID = kbUnitPickGetResult(upID, 2);    // Tertiary unit
      weight = 0.167;    // Third unit, if used, is 1/6
      
      goldCost = kbUnitCostPerResource(unitID, cResourceGold);
      woodCost = kbUnitCostPerResource(unitID, cResourceWood);
      foodCost = kbUnitCostPerResource(unitID, cResourceFood);
      totalCost = goldCost+woodCost+foodCost;
	   
      gForecasts = gForecasts + (goldCost+woodCost+foodCost) * (totalAmount*weight/totalCost);      
   }      
}
*/
//==============================================================================
// rule age2Monitor
/*
   Watch for us reaching age 2.
*/
//==============================================================================
rule age2Monitor
inactive
group tcComplete
minInterval 1
{ 

		 
   if (kbGetAge() >= cAge2)   // We're in age 2
   {
      xsDisableSelf();
      xsEnableRule("age3Monitor");
      xsEnableRule("rickshawMonitor");
	  
      if (xsIsRuleEnabled("militaryManager") == false)
      {
         xsEnableRule("militaryManager");
         aiEcho("Enabling the military manager.");
         militaryManager();   // runImmediately doesn't work.
      }
      if (xsIsRuleEnabled("navyManager") == false)
      {
         xsEnableRule("navyManager");
         aiEcho("Enabling the navy manager.");
      }

      //xsEnableRule("stageCoachMonitor");            
      xsEnableRule("bigMarketNewYearMonitor");
      
      // Enable settler hitpoint and attack upgrades (research to be started about 3 minutes later)
      xsEnableRule("settlerUpgradeMonitor");
      
      // Enable mansabdar maintain plans for Indians
      if (cMyCiv == cCivIndians)
      {
         xsEnableRule("mansabdarMonitor");      
         xsEnableRule("sacredFieldMonitor");
      }
      // Enable cree coureur maintain plan
      xsEnableRule("maintainCreeCoureurs");
       
      findEnemyBase();  // Create a one-off explore plan to probe the likely enemy base location.
      updateForecasts();
      updateGatherers();
      updateSettlerCounts();

      // Get the estimate of military needs
      //setMilitaryUnitCostForecast();

      kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 200.0);

      gAgeUpTime = xsGetTime();
      updateEscrows();
      
      //kbEscrowAllocateCurrentResources();

      //-- Set the resource TargetSelector factors.
      gTSFactorDistance = -40.0;
      gTSFactorPoint = 10.0;
      gTSFactorTimeToDone = 0.0;
      gTSFactorBase = 100.0;
      gTSFactorDanger = -40.0;
      kbSetTargetSelectorFactor(cTSFactorDistance, gTSFactorDistance);
      kbSetTargetSelectorFactor(cTSFactorPoint, gTSFactorPoint);
      kbSetTargetSelectorFactor(cTSFactorTimeToDone, gTSFactorTimeToDone);
      kbSetTargetSelectorFactor(cTSFactorBase, gTSFactorBase);
      kbSetTargetSelectorFactor(cTSFactorDanger, gTSFactorDanger);
      
      setUnitPickerPreference(gLandUnitPicker);
     
      gLastAttackMissionTime = xsGetTime() - 5000;     
      gLastDefendMissionTime = xsGetTime() - 5000;     
      gLastClaimMissionTime = xsGetTime() - 5000;
      
	  
      aiEcho("*** We're in age 2 ***");
   }
}


//==============================================================================
// rule age3Monitor
/*
   Watch for us reaching age 3.
*/
//==============================================================================
rule age3Monitor
inactive
minInterval 15
{
		 
   if (kbGetAge() >= cAge3)
   {
      aiEcho("*** We're in age 3.");
      
      // Bump up settler train plan
      updateSettlerCounts();
      // Get the estimate of military needs
      //setMilitaryUnitCostForecast();
     
      xsDisableSelf();
      xsEnableRule("age4Monitor");
      gAgeUpTime = xsGetTime();
      
      kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 300.0);

      if (cMyCiv == cCivGermans)
        xsEnableRule("GermantownFarmersMonitor");
      
      // Enable basic church upgrades
      xsEnableRule("churchUpgradeMonitor");
      
      // Enable unique church upgrades
      xsEnableRule("royalDecreeMonitor");

      // Enable arsenal upgrades
      xsEnableRule("arsenalUpgradeMonitor");
      
      // Enable unit upgrade rules
      xsEnableRule("veteranUpgradeMonitor");
      xsEnableRule("eliteUpgradeMonitor");
      xsEnableRule("disciplinedUpgradeMonitor");
      xsEnableRule("warriorSocietyUpgradeMonitor");
      xsEnableRule("minorAsianDisciplinedUpgradeMonitor");     
      //xsEnableRule("upgradeWallConnector");
      xsEnableRule("autoFeedLowestAlly");
      
      // Enable minor tribe techs
      xsEnableRule("minorTribeTechMonitor");
      xsEnableRule("minorAsianTribeTechMonitor");

      // Enable navy upgrades
      xsEnableRule("navyUpgradeMonitor");

      // Enable agra fort upgrades for Indians
      if (kbGetCiv() == cCivIndians)
        xsEnableRule("agraFortUpgradeMonitor");

      // Enable monastery
      xsEnableRule("monasteryMonitor");

      // Enable summer palace tactic monitor for Chinese
      if (kbGetCiv() == cCivChinese)
        xsEnableRule("summerPalaceTacticMonitor");

      // Enable dojo tactic monitor for Japanese
      if (cMyCiv == cCivJapanese)
      {
         xsEnableRule("dojoTacticMonitor");
         xsEnableRule("arsenalUpgradeAsianMonitor");
         xsEnableRule("churchUpgradeAsianMonitor");
      }
      updateEscrows();
   }
}


//==============================================================================
// rule age4Monitor
/*
   Watch for us reaching age 4.
*/
//==============================================================================
rule age4Monitor
inactive
minInterval 15
{

		 
   if (kbGetAge() >= cAge4)
   {
      aiEcho("*** We're in age 4.");
      // Bump up settler train plan
      updateSettlerCounts();
      // Get the estimate of military needs
      //setMilitaryUnitCostForecast();
      xsDisableSelf();

      xsEnableRule("stageCoachMonitor");      
      xsEnableRule("ironHorseMonitor");
      xsEnableRule("balloonMonitor");
      // Enable advanced arsenal upgrades
      xsEnableRule("advancedArsenalUpgradeMonitor");

      if (cMyCiv == cCivBritish)
        xsEnableRule("ManorMonitor");
            
      // Enable 'New Way' upgrades for Sioux
      if (cMyCiv == cCivXPSioux)
        xsEnableRule("newWaySiouxMonitor");
      
      // Enable shrine upgrade for Japanese
      if (cMyCiv == cCivJapanese)
      {
         xsEnableRule("shrineUpgradeMonitor");    
         xsEnableRule("goldenPavillionUpgradeMonitor");  
         xsEnableRule("dojoUpgradeMonitor");
      }
      // Enable 'New Way' upgrades for Iroquois
      if (cMyCiv == cCivXPIroquois)
         xsEnableRule("newWayIroquoisMonitor");

      // Enable 'New Way' upgrades for Sioux
      if (cMyCiv == cCivXPSioux)
         xsEnableRule("newWaySiouxMonitor");
      
      if (civIsEuropean() == true) 
        xsEnableRule("buildFortress");

      // Enable unit upgrade rules
      xsEnableRule("guardUpgradeMonitor");      
      xsEnableRule("championUpgradeMonitor");
      xsEnableRule("honoredUpgradeMonitor");
      xsEnableRule("artilleryUpgradeMonitor");
      xsEnableRule("minorNativeChampionUpgradeMonitor");
      xsEnableRule("minorAsianHonoredUpgradeMonitor");
      
      // Enable fort upgrade
      if ( (civIsEuropean() == true) || (kbGetCiv() == cCivChinese) )
        xsEnableRule("fortUpgradeMonitor");

      // Enable factory upgrades and production configuration
      xsEnableRule("factoryUpgradeMonitor");
      xsEnableRule("factoryTacticMonitor");
      
      // Enable revolution specific rules (only in about 1 out of 3 games)
      if ((civIsEuropean() == true) && (gSPC == false))
      {         
         xsEnableRule("revolutionMonitor");
         xsEnableRule("setRevolutionFlag");
         aiEcho("Revolution feature enabled for this game");
      }
      else
      {  aiEcho("Revolution feature disabled for this game");  }
      
      xsEnableRule("autoFeedRevolutionary"); // independent of probability above!

      xsEnableRule("age5Monitor");
      gAgeUpTime = xsGetTime();
      
      kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 400.0);

      updateEscrows();
	  
    }
}

//==============================================================================
// rule age5Monitor
/*
   Watch for us reaching age 5.
*/
//==============================================================================
rule age5Monitor
inactive
minInterval 15
{
   if (kbGetAge() >= cAge5)
   {
      aiEcho("*** We're in age 5.");
      // Bump up settler train plan
      updateSettlerCounts();

      // Get the estimate of military needs
      //setMilitaryUnitCostForecast();
      xsEnableRule("imperialUpgradeMonitor");
      xsEnableRule("legendaryUpgradeMonitor");
      xsEnableRule("exaltedUpgradeMonitor");
      // Enable spies upgrades
      if (civIsEuropean() == true)
        xsEnableRule("spiesMonitor");

      // Enable blockade upgrades
      if (civIsEuropean() == false)
        xsEnableRule("spiesNativeMonitor");

      // Enable blockade upgrades
      //if (civIsEuropean() == true)
        //xsEnableRule("blockadeMonitor");

      // Enable blockade upgrades
      //if (civIsEuropean() == false)
      //  xsEnableRule("blockadeNativeMonitor");

      // Enable capitol upgrades
      xsEnableRule("capitolUpgradeMonitor");

      // Enable sheep handling for British
      if (cMyCiv == cCivBritish)
         xsEnableRule("sheepBritishMonitor");

      // Enable sheep handling for Iroquois
      if (cMyCiv == cCivXPIroquois)
         xsEnableRule("sheepIroquoisMonitor");

      // Enable goat handling for Chinese
      if (cMyCiv == cCivChinese)
        xsEnableRule("goatMonitor");

      // Enable fireship plan
      //xsEnableRule("fireshipMonitor");

      // Enable tlaloccanoe plan
      //xsEnableRule("tlaloccanoeMonitor");

      // Enable brigade technologies at the consulate
      //if (civIsAsian() == true)
         xsEnableRule("brigadeMonitor");
     
      xsDisableSelf();
      gAgeUpTime = xsGetTime();

      kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 600.0);
	  
      xsEnableRule("decideToBuildWall");

      updateEscrows();
   }
}

//==============================================================================
// rule startFishing
//==============================================================================
rule startFishing
inactive
group tcComplete
mininterval 29
{                 

   int fishCount=kbUnitCount(0, cUnitTypeAbstractFish, cUnitStateAlive);
   if (fishCount == 0)
      return;
	  
   // Quit and disable immediately if we're not on a water map
   if ((gGoodFishingMap == false) && (cvOkToFish == false))
   {
      xsDisableSelf();
      return;
   }
   
   if (fishCount == 0)
   {
      xsDisableSelf();
      return;
   }

   gNumFishBoats = aiGetEconomyPop() * 0.1; // At max boom, that's 10.  
   if (gNumFishBoats < 2)
   {
      gNumFishBoats = 0;   // Rushers generally shouldn't fish.
   }
   if (gGoodFishingMap == true)
   {
      if (gNumFishBoats >= 2)
         gNumFishBoats = 10;   // Always fish on those maps.
   }
     
      //  Check to see if we have spotted a fish reasonably close to our water spawn flag.  
      int flag = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
      if (flag >= 0)
      {
         static int fishQuery = -1;
         int fish = -1;
         int fishAreaGroup = -1;
         int flagAreaGroup = -1;

         flagAreaGroup = kbAreaGroupGetIDByPosition(kbUnitGetPosition(flag));

         if (fishQuery < 0)
         {
            fishQuery=kbUnitQueryCreate("fish query");
            kbUnitQuerySetIgnoreKnockedOutUnits(fishQuery, true);
            kbUnitQuerySetPlayerID(fishQuery, 0);
            kbUnitQuerySetUnitType(fishQuery, cUnitTypeAbstractFish);
            kbUnitQuerySetState(fishQuery, cUnitStateAny);
            kbUnitQuerySetPosition(fishQuery, kbUnitGetPosition(flag));
            kbUnitQuerySetMaximumDistance(fishQuery, 600.0);
            kbUnitQuerySetAscendingSort(fishQuery, true);
         }
         kbUnitQueryResetResults(fishQuery);
         if (kbUnitQueryExecute(fishQuery) > 0)
            fish = kbUnitQueryGetResult(fishQuery, 0);   // Get the nearest fish.
         if (fish >= 0)
            fishAreaGroup = kbAreaGroupGetIDByPosition(kbUnitGetPosition(fish));
         if ( (fish >= 0) && (fishAreaGroup == flagAreaGroup) )
            aiEcho("Found fish # "+fish+" at "+kbUnitGetPosition(fish));
         else
         {
            aiEcho("No fish found near "+kbUnitGetPosition(flag));
            return;  // No fish near enough, keep looking
         }
      }  // else, no flag, so just go ahead.
      
      if (fish < 0)
         getUnit(cUnitTypeAbstractFish, 0, cUnitStateAny);  // need to have one fish visible
      
      if (fish < 0)
         return;
      
      aiEcho("*** Starting fishing plan. ***");
      
      gFishingPlan = aiPlanCreate("Fishing plan", cPlanFish); 
      aiPlanSetDesiredPriority(gFishingPlan, 90);   
      aiPlanAddUnitType(gFishingPlan, gFishingUnit, 1, 10, 20);      
      aiPlanSetEscrowID(gFishingPlan, cEconomyEscrowID); 
      aiPlanSetBaseID(gFishingPlan, kbBaseGetMainID(cMyID)); 
      aiPlanSetVariableVector(gFishingPlan, cFishPlanLandPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))); 
      if ( flag >= 0 )
      {
         aiEcho("Setting fishing plan water point to "+kbUnitGetPosition(getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID)) );
         aiPlanSetVariableVector(gFishingPlan, cFishPlanWaterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID)) );
      }
      else
      {
         aiEcho("Couldn't find a water spawn flag.");
         aiPlanSetVariableVector(gFishingPlan, cFishPlanLandPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))); 
      }
      aiPlanSetVariableBool(gFishingPlan, cFishPlanBuildDock, 0, false);    //BHG - the ai doesn't like to fish if this is set to true
      aiPlanSetActive(gFishingPlan); 

      aiEcho("*** Creating maintain plan for fishing boats.");      
      gFishingBoatMaintainPlan = createSimpleMaintainPlan(gFishingUnit, gNumFishBoats, true, kbBaseGetMainID(cMyID), 1);
}

//==============================================================================
// addMillBuildPlan
//==============================================================================
void addMillBuildPlan(void)
{     
      int farmBuildPlan = createLocationBuildPlan(gFarmUnit, 1, 98, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);			            
      aiPlanSetVariableFloat(farmBuildPlan, cBuildPlanCenterPositionDistance, 0, 200.0);
      // If we don't have enough mills, and we need to farm, and we're not building one, build one.
      if ( (kbGetCiv() == cCivXPIroquois) && (kbUnitCount(cMyID, cUnitTypexpBuilder, cUnitStateAlive) > 0) )
	aiPlanAddUnitType(farmBuildPlan, cUnitTypexpBuilder, 1, 1, 1);			 
      else
	aiPlanAddUnitType(farmBuildPlan, gEconUnit, 1, 1, 1);   
}

//==============================================================================
// rule updateFoodBreakdown
//==============================================================================
rule updateFoodBreakdown
inactive
group tcComplete
minInterval 10
{  
   int numberMills = kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive);
   const int cMaxSettlersPerHuntPlan = 10;
   const int cMinSettlersPerHuntPlan = 2;    // Must be much less than Max/2 to avoid thrashing
   static int totalFoodPlans = 0;            // How many are currently requested?  Try to avoid thrashing this number
   int huntPlans = 0;
   int huntables = 0;                        // Used to monitor hunting count
   int herdables = 0;
   int animalsAvailable = 0;   
      
   // Get an estimate for the number of food gatherers.
   // Figure out how many mill plans that should be, and how many villagers will be farming.
   // Look at how many hunt plans we'd have, and see if that's a reasonable number.  
   float percentOnFood = aiGetResourceGathererPercentage(cResourceFood, cRGPActual);
   int numFoodGatherers =  percentOnFood * (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive));
   int foodGatherersRemaining = numFoodGatherers;
   int farmPlans = 0;
   if (numFoodGatherers > (numberMills * cMaxSettlersPerMill)) // Can we max out the farms?
   {
      farmPlans = numberMills;
      foodGatherersRemaining = numFoodGatherers - (farmPlans * cMaxSettlersPerMill);
      if (xsGetTime() > 10*60*1000)  
      {  // In ages 1/2, consider just staying with hunting
         huntables = getUnitCountByLocation(cUnitTypeHuntable, 0, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 60.0);
		 herdables =(getUnitCountByLocation(cUnitTypeHerdable, 0, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 60.0));// -
	     //(getUnitCountByLocation(cUnitTypeypShrineJapanese, cPlayerRelationAny, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 60.0) *6) );            
         animalsAvailable = huntables - herdables; // Huntables, less gaia herdables I don't yet own;
         herdables = getUnitCountByLocation(cUnitTypeHerdable, cMyID, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 60.0); // MY herdables         
         animalsAvailable = animalsAvailable + herdables; // Add in the herdables I've claimed
         if ((civIsAsian() == true) && (kbUnitCount(cMyID, cUnitTypeypRicePaddy, cUnitStateAlive) >= 8))
	 {
	    return;
	 }
         if ( ((kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy)) && (xsGetTime() > 10*60*1000) ) 
         { 
            addMillBuildPlan(); 
         } 
         else if ( (gTimeToFarm == true) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gFarmUnit) < 0) && (animalsAvailable < 8) )
         {  
            addMillBuildPlan(); 
         }
      }
   }
   else
   {  // We can't fill the farms
      farmPlans = 1 + (foodGatherersRemaining / cMaxSettlersPerMill);
      foodGatherersRemaining = 0;
   }
  
   if (foodGatherersRemaining > 0)
   {  // Assign some hunt plans      
      huntPlans = totalFoodPlans - farmPlans;   // Let's try to preserve the total number of plans
      if (huntPlans < 1)
         huntPlans = 1;
      
      while ( (foodGatherersRemaining / huntPlans) < cMinSettlersPerHuntPlan)  // Too many plans, not enough gatherers
         huntPlans = huntPlans - 1;
      
      while ( (foodGatherersRemaining / huntPlans) > cMaxSettlersPerHuntPlan)  // Too many gatherers, not enough plans
         huntPlans = huntPlans + 1;
   }
   else
   {
      huntPlans = 0;
   }
      
   totalFoodPlans = huntPlans + farmPlans;

   if ( (numFoodGatherers <= 0) || (cvOkToGatherFood == false) )
      totalFoodPlans = 0;    // Checked here to avoid div 0 above.
            
   aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, totalFoodPlans, 79, 1.0, kbBaseGetMainID(cMyID));
 
   if ( (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) 
   { 
      int breakDownTime = 15*60*1000; // 15 minutes
      if ((gJapaneseIsAlly == true) && (xsGetTime() > breakDownTime))  //AI's villagers always try to hunt animals at a shrine.
	aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, 0, 79, 0.0, kbBaseGetMainID(cMyID));
      else if (xsGetTime() > 25*60*1000) //30 minutes
	aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, 0, 79, 0.0, kbBaseGetMainID(cMyID));
      else
	aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, totalFoodPlans, 81, 1.0, kbBaseGetMainID(cMyID));
   }

   if ( (kbGetCiv() != cCivIndians) && (kbGetCiv() != cCivSPCIndians) && (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) 
   {  
      aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, totalFoodPlans, 50, 1.0, kbBaseGetMainID(cMyID)); 
   }
   
   aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHuntAggressive, 0, 79, 0.0, kbBaseGetMainID(cMyID)); 
   aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, 0, 79, 0.0, kbBaseGetMainID(cMyID));   
   aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, 0, 81, 0.0, kbBaseGetMainID(cMyID)); 
}

//==============================================================================
// rule updateWoodBreakdown
//==============================================================================
rule updateWoodBreakdown
inactive
group tcComplete
minInterval 10
{
   float percentOnWood = aiGetResourceGathererPercentage(cResourceWood, cRGPActual);
   int numWoodGatherers =  percentOnWood * (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive));
   int mainBaseID = kbBaseGetMainID(cMyID);
   static int numWoodPlans = 0;  // How many are currently requested?  Try to avoid thrashing this number
   const int cMaxSettlersPerWoodPlan = 10;
   const int cMinSettlersPerWoodPlan = 2;    // Must be much less than Max/2 to avoid thrashing
   
   if (numWoodPlans < 1)
      numWoodPlans = 1;
   
   while ( (numWoodGatherers / numWoodPlans) < cMinSettlersPerWoodPlan )   // Too many plans, not enough gatherers
      numWoodPlans = numWoodPlans - 1;
   
   while ( (numWoodGatherers / numWoodPlans) > cMaxSettlersPerWoodPlan )   // Too many gatherers, not enough plans
      numWoodPlans = numWoodPlans + 1;   

   if ( (numWoodGatherers <= 0) || (cvOkToGatherWood == false) )   
      numWoodPlans = 0;    // Checked here to avoid div 0 above.
	  
    /*   if (xsGetTime() > 35*60*1000) //30 minutes
	aiSetResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, numWoodPlans, 78, 0.0, kbBaseGetMainID(cMyID));
      else
    aiSetResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, numWoodPlans, 78, 1.0, kbBaseGetMainID(cMyID));*/
}


//==============================================================================
// rule updateGoldBreakdown
//==============================================================================
rule updateGoldBreakdown
inactive
group tcComplete
minInterval 10
{
   static int numberGoldPlans = 0;
   
   float percentOnGold = aiGetResourceGathererPercentage( cResourceGold, cRGPActual );
   int numGoldGatherers =  percentOnGold * (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive));

   int minPlans = (numGoldGatherers / 15) + 1;     // Assume up to 15 per site

   if (gTimeForPlantations == true)
      minPlans = (numGoldGatherers / cMaxSettlersPerPlantation) + 1;

   int maxPlans = (numGoldGatherers / 2) + 1;
   
   if (numberGoldPlans > maxPlans)
   {
      numberGoldPlans = maxPlans;
      aiEcho("Decreasing to "+numberGoldPlans+" gold plans.");
   }
   if ((numberGoldPlans < minPlans) && (numGoldGatherers > 0))
   {
      numberGoldPlans = minPlans;
      aiEcho("Increasing to "+numberGoldPlans+" gold plans.");
   }

   if ( (numGoldGatherers <= 0) || (cvOkToGatherGold == false) )
      numberGoldPlans = 0;    // Checked here to avoid div 0 above.
            
   if ( (kbGetAge()>=cAge3) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gPlantationUnit) < 0) )
   {  // It's third age, and we're not building a plantation...see if we need one.     
      if ( (numberGoldPlans > kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateAlive)) && (cvOkToBuild == true) && (gTimeForPlantations == true) )
      {  
         if ((kbGetCiv() == cCivDutch) && ((kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 6) || (kbUnitCount(cMyID, gPlantationUnit, cUnitStateAlive) >= 2)) ||
            (civIsAsian() == true) && (kbUnitCount(cMyID, cUnitTypeypRicePaddy, cUnitStateAlive) >= 12))
	 {
	    return;
	 }
         int plantationBuildPlan = createLocationBuildPlan(gPlantationUnit, 1, 97, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);			            
	 aiPlanSetVariableFloat(plantationBuildPlan, cBuildPlanCenterPositionDistance, 0, 240.0);
	 aiEcho("Starting a new plantation build plan.");         
	 if ( (kbGetCiv() == cCivXPIroquois) && (kbUnitCount(cMyID, cUnitTypexpBuilder, cUnitStateAlive) > 0) )
	   aiPlanAddUnitType(plantationBuildPlan, cUnitTypexpBuilder, 1, 1, 1);			 
	 else
	   aiPlanAddUnitType(plantationBuildPlan, gEconUnit, 1, 1, 1);	 
      }    
   } 
   /*
    if (xsGetTime() > 30*60*1000) //30 minutes
	{
	aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, 0, 79, 0.0, kbBaseGetMainID(cMyID));
      else
	  }*/
    aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, numberGoldPlans, 80, 1.0, kbBaseGetMainID(cMyID));
   
  
}

//==============================================================================
// initGatherGoal()
//==============================================================================
int initGatherGoal()
{
   /* Create the gather goal, return its handle.  The gather goal stores the key data for controlling
      gatherer distribution.  
   */
   int planID = aiPlanCreate("GatherGoals", cPlanGatherGoal);    

   if (planID >= 0)
   {
      //Overall percentages.
      aiPlanSetDesiredPriority(planID, 90);
      //Set the RGP weights.  Script in charge.  
      aiSetResourceGathererPercentageWeight(cRGPScript, 1.0);              // Portion driven by forecast
      aiSetResourceGathererPercentageWeight(cRGPCost, 0.0);                // Portion driven by exchange rates
		
      // Set the gather goal to reflect those settings (Gather goal values are informational only to simplify debugging.)
      // Set the gather goal to reflect those settings (Gather goal values are informational only to simplify debugging.)
      aiPlanSetVariableFloat(planID, cGatherGoalPlanScriptRPGPct, 0, 1.0); 
      aiPlanSetVariableFloat(planID, cGatherGoalPlanCostRPGPct, 0, 1.0);   

      aiPlanSetNumberVariableValues(planID, cGatherGoalPlanGathererPct, cNumResourceTypes, true);
      // Set initial gatherer assignments.
      aiPlanSetVariableFloat(planID, cGatherGoalPlanGathererPct, cResourceGold, 0.0);
      aiPlanSetVariableFloat(planID, cGatherGoalPlanGathererPct, cResourceWood, 0.2);
      aiPlanSetVariableFloat(planID, cGatherGoalPlanGathererPct, cResourceFood, 0.8);

      //Standard resource breakdown setup, all easy at the start.
      aiPlanSetNumberVariableValues(planID, cGatherGoalPlanNumFoodPlans, 5, true);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeEasy, 1);
      if ( (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) 
	  {
        aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHunt, 1);
      }
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHerdable, 0);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHunt, 0);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHuntAggressive, 0);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeFarm, 0);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeFish, 0);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumWoodPlans, 0, 1);
      aiPlanSetVariableInt(planID, cGatherGoalPlanNumGoldPlans, 0, 1);  

      //Cost weights...set the convenience copies in the gather goal first, then the real ones next.
      aiPlanSetNumberVariableValues(planID, cGatherGoalPlanResourceCostWeight, cNumResourceTypes, true);
      aiPlanSetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceGold, 1.0); // Gold is the standard
      aiPlanSetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceWood, 1.0); // Start at 1.0, since wood is harder to collect
      aiPlanSetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceFood, 1.0); // Premium for food, or 1.0?

      //Setup AI Cost weights.  This makes it actually work, the calls above just set the convenience copy in the gather goal.
      kbSetAICostWeight(cResourceFood, aiPlanGetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceFood));
      kbSetAICostWeight(cResourceWood, aiPlanGetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceWood));
      kbSetAICostWeight(cResourceGold, aiPlanGetVariableFloat(planID, cGatherGoalPlanResourceCostWeight, cResourceGold));
      
      //Set initial gatherer percentages.
      aiSetResourceGathererPercentage(cResourceFood, 0.8, false, cRGPScript);    
      aiSetResourceGathererPercentage(cResourceWood, 0.2, false, cRGPScript);    
      aiSetResourceGathererPercentage(cResourceGold, 0.0, false, cRGPScript);  
      if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
      {  // Need extra wood
         aiSetResourceGathererPercentage(cResourceWood, 0.7, false, cRGPScript);    
         aiSetResourceGathererPercentage(cResourceFood, 0.3, false, cRGPScript);
      }
      if (kbGetCiv() == cCivDutch)
      {  // Need bank (wood/food) early, and gold for villagers.
         // aiSetResourceGathererPercentage(cResourceGold, 0.2, false, cRGPScript);
         aiSetResourceGathererPercentage(cResourceWood, 0.7, false, cRGPScript);    
         aiSetResourceGathererPercentage(cResourceFood, 0.3, false, cRGPScript);
      }
      if ( (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivPirate) || (kbGetCiv() == cCivTheCircle)  || (kbGetCiv() == cCivSPCAct3))
      {  // Need extra wood
         aiSetResourceGathererPercentage(cResourceWood, 0.6, false, cRGPScript);    
         aiSetResourceGathererPercentage(cResourceFood, 0.4, false, cRGPScript);
      } 
      aiNormalizeResourceGathererPercentages(cRGPScript);

      //Set up the initial resource breakdowns.
      int numFoodEasyPlans=aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeEasy);
      int numFoodHuntPlans=aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHunt);
      int numFoodHerdablePlans=aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHerdable);
      int numFoodHuntAggressivePlans=aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeHuntAggressive);
      int numFishPlans=aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeFish);
      int numFarmPlans=aiPlanGetVariableInt(planID, cGatherGoalPlanNumFoodPlans, cAIResourceSubTypeFarm);
      int numWoodPlans=aiPlanGetVariableInt(planID, cGatherGoalPlanNumWoodPlans, 0);
      int numGoldPlans=aiPlanGetVariableInt(planID, cGatherGoalPlanNumGoldPlans, 0);

      if (kbBaseGetMainID(cMyID) >= 0)     // Don't bother if we don't have a main base
      {         
         if (cvOkToGatherFood == true)
         {
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, numFoodEasyPlans, 49, 1.0, kbBaseGetMainID(cMyID));      // All on easy food at start
            if ( (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) {
              aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, numFoodHuntPlans, 49, 1.0, kbBaseGetMainID(cMyID));      // All on easy hunting food at start
            }
            if ( (kbGetCiv() != cCivIndians) && (kbGetCiv() != cCivSPCIndians) && (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) {
              aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, numFoodHerdablePlans, 24, 1.0, kbBaseGetMainID(cMyID));
            }
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeHuntAggressive, numFoodHuntAggressivePlans, 49, 0.0, kbBaseGetMainID(cMyID)); 
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, numFishPlans, 49, 0.0, kbBaseGetMainID(cMyID));
            aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, numFarmPlans, 51, 0.0, kbBaseGetMainID(cMyID));
            if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) ) {
              aiSetResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, numFarmPlans, 51, 1.0, kbBaseGetMainID(cMyID));
            }
         }
         if (cvOkToGatherWood == true)
            aiSetResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, numWoodPlans, 50, 1.0, kbBaseGetMainID(cMyID));
         if (cvOkToGatherGold == true)
            aiSetResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, numGoldPlans, 55, 1.0, kbBaseGetMainID(cMyID));
      }

   }
   return(planID);
}

//==============================================================================
// updateEconSiteList
/*
   Scan all potential econ bases that aren't being used.   Sort them into a 
   rational order of planned use, considering size, proximity to each other,
   security, etc.
*/
//==============================================================================
void updateEconSiteList(void)
{
}

//==============================================================================
// initEcon
/*
   Called when the initial units have disembarked.  Sets up initial economy.
*/
//==============================================================================
void initEcon(void)
{
   if (kbGetCiv() == cCivFrench)  
      gEconUnit = cUnitTypeCoureur;
              
   if (civIsNative() == true)
   {       
      gFarmUnit = cUnitTypeFarm;
      gEconUnit = cUnitTypeSettlerNative;
      gLivestockPenUnit = cUnitTypeFarm;
   }      
      
   //BHG...
   if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
   {    
      gEconUnit = cUnitTypeypSettlerAsian; 
      gHouseUnit = cUnitTypeypVillage;         
      gLivestockPenUnit = cUnitTypeypVillage;
      gFarmUnit = cUnitTypeypRicePaddy;
      gPlantationUnit = cUnitTypeypRicePaddy;      
      gMarketUnit = cUnitTypeypTradeMarketAsian;
      gDockUnit = cUnitTypeYPDockAsian;
      gFishingUnit = cUnitTypeypFishingBoatAsian;
      cvOkToBuildForts = true; // BHG: Chinese can buy a fort wagon from Russian consulate.
   }
   
   if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) )
   {
      gEconUnit = cUnitTypeypSettlerJapanese;    
      gHouseUnit = cUnitTypeypShrineJapanese;           
      gLivestockPenUnit = cUnitTypeypShrineJapanese;
      gFarmUnit = cUnitTypeypRicePaddy;
      gPlantationUnit = cUnitTypeypRicePaddy;      
      gMarketUnit = cUnitTypeypTradeMarketAsian;
      gDockUnit = cUnitTypeYPDockAsian;
      gFishingUnit = cUnitTypeypFishingBoatAsian;
   }
   
   if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
   {     
      gHouseUnit = cUnitTypeypHouseIndian;            
      gLivestockPenUnit = cUnitTypeypSacredField;     
      gEconUnit = cUnitTypeypSettlerIndian;
      gFarmUnit = cUnitTypeypRicePaddy;
      gPlantationUnit = cUnitTypeypRicePaddy;      
      gMarketUnit = cUnitTypeypTradeMarketAsian;
      gDockUnit = cUnitTypeYPDockAsian;
      gFishingUnit = cUnitTypeypFishingBoatAsian;
   }
   //...BHG

   if ( (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivTheCircle) || (kbGetCiv() == cCivPirate) || (kbGetCiv() == cCivSPCAct3))
      gHouseUnit = cUnitTypeManor;
   
   if ( (kbGetCiv() == cCivFrench) || (kbGetCiv() == cCivDutch) )
      gHouseUnit = cUnitTypeHouse;
   
   if ( (kbGetCiv() == cCivGermans) || (kbGetCiv() == cCivRussians) )
      gHouseUnit = cUnitTypeHouseEast;
   
   if ( (kbGetCiv() == cCivSpanish) || (kbGetCiv() == cCivPortuguese) || (kbGetCiv() == cCivOttomans) )
      gHouseUnit = cUnitTypeHouseMed;
   
   if ( kbGetCiv() == cCivXPIroquois )      
      gHouseUnit = cUnitTypeLonghouse;     

   if ( kbGetCiv() == cCivXPAztec )
      gHouseUnit = cUnitTypeHouseAztec;

   /*gMaximumBaseResourceDistance = 25.0 * (1+kbGetAge());	 50m, 75m, 100m, 125m, 150m in ages 1-5*/
     
   // Escrow initialization is now delayed until the TC is built, as
   // any escrow allocation prevents the AI from affording a TC.
   // For now, though, override the default and set econ/mil to 0
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceFood, 0.0);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceWood, 0.0);   
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceFame, 0.0);
      
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFood, 0.0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceWood, 0.0);  
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFame, 0.0);
   
   kbEscrowAllocateCurrentResources();

   aiSetEconomyPercentage(1.0);
   aiSetMilitaryPercentage(1.0);    // Priority balance neutral

   gFarmBaseID=kbBaseGetMainID(cMyID);
   gFoodBaseID=kbBaseGetMainID(cMyID);       // Where we hunt or gather non-farm food.
   gGoldBaseID=kbBaseGetMainID(cMyID);
   gWoodBaseID=kbBaseGetMainID(cMyID);

   //gFarmBaseID=kbBaseFindCreateResourceBase(cResourceFood, cAIResourceSubTypeFarm, kbBaseGetMainID(cMyID));
   //gFoodBaseID=kbBaseFindCreateResourceBase(cResourceFood, cAIResourceSubTypeEasy, kbBaseGetNextID());
   //gWoodBaseID=kbBaseFindCreateResourceBase(cResourceWood, cAIResourceSubTypeEasy, kbBaseGetNextID());
   //gGoldBaseID=kbBaseFindCreateResourceBase(cResourceGold, cAIResourceSubTypeEasy, kbBaseGetNextID());

   // Set up gatherer goal
   gGatherGoal = initGatherGoal();
   
   xsEnableRuleGroup("startup");

   //Lastly, force an update on the economy...call the function directly.
   econMaster();
}

//==============================================================================
// evaluateBases
/*
   Review the list of currently active economic bases for viability.  
   Determine if bases need to be added to or removed from the list.  
*/
//==============================================================================
void evaluateBases()
{
}

//==============================================================================
//
// updatePrices
// 
// This function compares actual supply vs. forecast, updates AICost 
// values (internal resource prices), and buys/sells at the market as appropriate
//==============================================================================
void updatePrices()
{
   // check for valid forecasts, exit if not ready
   if ( (xsArrayGetFloat(gForecasts,0) + xsArrayGetFloat(gForecasts,1) + xsArrayGetFloat(gForecasts,2) ) < 100 )
     return; 
   
   float scaleFactor = 5.0;      // Higher values make prices more volatile
   // Commentary on scale factor.  A factor of 1.0 compares inventory of resources against the full 3-minute forecast.  A scale of 10.0
   // compares inventory to 1/10th of the forecast.  A large scale makes prices more volatile, encourages faster and more frequent trading at lower threshholds, etc.
   float goldStatus = 0.0;
   float woodStatus = 0.0;
   float foodStatus = 0.0;
   float minForecast = 200.0 * (1+kbGetAge());	// 200, 400, 600, 800 in ages 1-4, prevents small amount from looking large if forecast is very low

   if (xsArrayGetFloat(gForecasts,cResourceGold) > minForecast)
     goldStatus = scaleFactor * kbResourceGet(cResourceGold)/xsArrayGetFloat(gForecasts,cResourceGold);
   else
     goldStatus = scaleFactor * kbResourceGet(cResourceGold)/minForecast;

   if (xsArrayGetFloat(gForecasts,cResourceFood) > minForecast)
     foodStatus = scaleFactor * kbResourceGet(cResourceFood)/xsArrayGetFloat(gForecasts,cResourceFood);
   else
     foodStatus = scaleFactor * kbResourceGet(cResourceFood)/minForecast;

   if (xsArrayGetFloat(gForecasts,cResourceWood) > minForecast)
     woodStatus = scaleFactor * kbResourceGet(cResourceWood)/xsArrayGetFloat(gForecasts,cResourceWood);
   else
     woodStatus = scaleFactor * kbResourceGet(cResourceWood)/minForecast;
		
   // Status now equals inventory/forecast
   // Calculate value rate of wood:gold and food:gold.  1.0 means they're of the same status, 2.0 means 
   // that the resource is one forecast more scarce, 0.5 means one forecast more plentiful, i.e. lower value.
   float woodRate = (1.0 + goldStatus)/(1.0 + woodStatus);
   float foodRate = (1.0 + goldStatus)/(1.0 + foodStatus);

   // The rates are now the instantaneous price for each resource.  Set the long-term prices by averaging this in
   // at a 5% weight.
   float cost = 0.0;
   
   // wood        
   cost = kbGetAICostWeight(cResourceWood);
   cost = (cost * 0.95) + (woodRate * .05);        
   kbSetAICostWeight(cResourceWood, cost);

   // food
   cost = kbGetAICostWeight(cResourceFood);
   cost = (cost * 0.95) + (foodRate * .05);
   kbSetAICostWeight(cResourceFood, cost);

   // Gold              
   kbSetAICostWeight(cResourceGold, 1.00);	// gold always 1.0, others relative to gold
	
   // Update the gather plan goal
   int i=0;
   for (i=0; < 3)
   {   aiPlanSetVariableFloat(gGatherGoal, cGatherGoalPlanResourceCostWeight, i, kbGetAICostWeight(i));  }
}

//==============================================================================
// spewForecasts
//==============================================================================
void spewForecasts()
{  // Debug aid, dump forecast contents
   int gold = xsArrayGetFloat(gForecasts, cResourceGold);
   int wood = xsArrayGetFloat(gForecasts, cResourceWood);
   int food = xsArrayGetFloat(gForecasts, cResourceFood);
   
   aiEcho("Forecast Gold: "+gold+", Wood: "+wood+", Food: "+food);
   aiEcho("Prices Gold: "+kbGetAICostWeight(cResourceGold)+", Wood: "+kbGetAICostWeight(cResourceWood)+", Food: "+kbGetAICostWeight(cResourceFood));
}

//==============================================================================
// addItemToForecasts
//==============================================================================
void addItemToForecasts(int protoUnit = -1, int qty = -1)

{
   // Add qty of item protoUnit to the global forecast arrays
   if (protoUnit < 0)
      return;
   if (qty < 1)
      return;
   int i=0;
   for (i=0; <3)  // Step through first three resources
   {
      xsArraySetFloat(gForecasts, i, xsArrayGetFloat(gForecasts, i) + (kbUnitCostPerResource(protoUnit, i) * qty));
   }
   aiEcho(" "+qty+" "+kbGetProtoUnitName(protoUnit));
   //spewForecasts();
}

//==============================================================================
// addTechToForecasts
//==============================================================================
void addTechToForecasts(int techID = -1)
{
   // Add cost of this tech to the global forecast arrays
   if (techID < 0)
      return;
   int i=0;
   for (i=0; <3)  // Step through first three resources
   {
      xsArraySetFloat(gForecasts, i, xsArrayGetFloat(gForecasts, i) + kbTechCostPerResource(techID, i));
   }  
   aiEcho("    "+kbGetTechName(techID));
   //spewForecasts();
}

//==============================================================================
// clearForecasts
//==============================================================================
void clearForecasts()
{
   // Clear the global forecast arrays
   int i=0;
   for(i=0; <3)
   {
      xsArraySetFloat(gForecasts, i, 0.0);
   }
   //aiEcho("******** Clearing forecasts");
      updateEscrows();
}

//==============================================================================
// updateForecasts
/*
   Create 3-minute forecast of resource needs for food, wood and gold
*/
//==============================================================================
void updateForecasts()
{

   
  
      updateEscrows();
	  
   int i=0;
   int militaryUnit = -1;
   int milQty = -1;
   int popSlots = -1;
   
   int effectiveAge = kbGetAge();
   if ( agingUp() == true )
      effectiveAge = effectiveAge + 1;
   
   int numUnits = 0; // Temp var used to track how many of each item will be needed

   clearForecasts(); // Reset all to zero
   aiEcho("Starting forecast.  Items included:");
   
   int millsNeeded = 1 + ((kbUnitCount(cMyID, gEconUnit, cUnitStateAlive)*0.6) / cMaxSettlersPerMill);        // Enough for 50% of population, rough value for forecast      
   int plantsNeeded = 1 + ((kbUnitCount(cMyID, gEconUnit, cUnitStateAlive)*0.6) / cMaxSettlersPerPlantation); // Enough for 40% of population, rough value for forecast
   int paddiesNeeded = 1 + ((kbUnitCount(cMyID, gEconUnit, cUnitStateAlive)*1.2) / cMaxSettlersPerMill);      // Enough for 90% of population for both food and coin, rough value for forecast

   if (kbGetCiv() == cCivDutch)
   {
      millsNeeded = 1 + ( (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) * 1.2) / cMaxSettlersPerMill);          // Enough for 90% of population, rough value for forecast
      plantsNeeded = 1 + ( (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) * 0.4) / cMaxSettlersPerPlantation);   // Enough for 10% of population, rough value for forecast 
   }

   if (civIsAsian() == false)
   {
      millsNeeded = millsNeeded - kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ);
      if ( (gTimeToFarm == true) && (millsNeeded > 0) )
         addItemToForecasts(gFarmUnit, millsNeeded);

      plantsNeeded = plantsNeeded - kbUnitCount(cMyID, gPlantationUnit, cUnitStateABQ);
      if ( (plantsNeeded > 0) && (effectiveAge > cAge2) && (gTimeForPlantations == true) )
         addItemToForecasts(gPlantationUnit, plantsNeeded);
   }
   if (civIsAsian() == true)
   {      
      if ( (gTimeToFarm == true) && (effectiveAge > cAge4) && (gTimeForPlantations == true) )  // Paddies needed for both food and coin 
      {
         paddiesNeeded = paddiesNeeded - kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ);
         if (paddiesNeeded > 0)
            addItemToForecasts(gFarmUnit, paddiesNeeded);
      }
      else if ( (gTimeToFarm == true) && ((effectiveAge < cAge3) || (gTimeForPlantations == false)) )  // Paddies needed for food only
      {
         millsNeeded = millsNeeded - kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ);
         if (millsNeeded > 0)
            addItemToForecasts(gFarmUnit, millsNeeded);
      }
      else if ( (gTimeToFarm == false) && (effectiveAge > cAge4) && (gTimeForPlantations == true) )  // Paddies needed for coin only
      {
         plantsNeeded = plantsNeeded - kbUnitCount(cMyID, gPlantationUnit, cUnitStateABQ);
         if (plantsNeeded > 0)
            addItemToForecasts(gPlantationUnit, plantsNeeded);
      }    
   }

   int numCaravel = 0;
   int numGalleon = 0;
   int numFrigate = 0;
   int numMonitor = 0;
   int numCanoe = 0;

   int fishBoats = 0;
   if (gFishingBoatMaintainPlan >= 0)
   {  fishBoats = aiPlanGetVariableInt(gFishingBoatMaintainPlan, cTrainPlanNumberToMaintain, 0) - kbUnitCount(cMyID, gFishingUnit, cUnitStateABQ); }
   
   if (fishBoats > 0)
      addItemToForecasts(gFishingUnit, fishBoats);
        
   switch(kbGetAge())
   {
      case cAge1:
      {
         if (cMyCiv != cCivOttomans)
         {
            numUnits = xsArrayGetInt(gTargetSettlerCounts) - kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
			
			if (numUnits > 0)
			{
            addItemToForecasts(gEconUnit); //, numUnits); //, numUnits);
			}
			
         }
		 
         //if ((kbUnitCount(cMyID, gMarketUnit, cUnitStateABQ) < 1) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) > 0) && (agingUp() == true))
         //   addItemToForecasts(gMarketUnit, 1);
			
	     /*
         if (cMyCiv != cCivOttomans)   // Ottomans get them free
         {
            addItemToForecasts(gEconUnit);
         }
		 */
		 
         if ((cMyCiv != cCivXPSioux) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < 1))
         {
            addItemToForecasts(gHouseUnit);
         }
         
         if ( agingUp() != true ) 
         {
            if (civIsAsian() == false)
            {
               addTechToForecasts(aiGetPoliticianListByIndex(cAge2, 0));
               if (gSPC == false)
               addTechToForecasts(aiGetPoliticianListByIndex(cAge2, 0));
            }
            else
            {
              addItemToForecasts(getPreferredWonderToBuild(cAge2), 1);
               if (gSPC == false)
              addItemToForecasts(getPreferredWonderToBuild(cAge2), 1);
            }
         }
         
         if (cMyCiv == cCivOttomans)
         {
            if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeChurch, 1);
            if ( (kbTechGetStatus(cTechChurchMilletSystem) == cTechStatusObtainable) || (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) == 0) )
            {
               addTechToForecasts(cTechChurchMilletSystem);
            }
            if ( (kbTechGetStatus(cTechChurchGalataTowerDistrict) == cTechStatusObtainable) || (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) == 0) )
            {
               addTechToForecasts(cTechChurchGalataTowerDistrict);
            }
         }
         
         if (cMyCiv == cCivDutch)
         {
            if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank))
               addItemToForecasts(cUnitTypeBank);

			xsArraySetFloat(gForecasts, cResourceFood, xsArrayGetFloat(gForecasts, cResourceFood) + 0.0);
			xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 0.0);
         }
		 
         if (cMyCiv == cCivBritish)
         {
            if ((kbUnitCount(cMyID, cUnitTypeManor, cUnitStateABQ) < 2))
               addItemToForecasts(cUnitTypeManor);
         }
         
         if (cMyCiv == cCivJapanese)
         {
            if ((kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateABQ) < 2))
               addItemToForecasts(cUnitTypeypShrineJapanese);
         }
                  
         break;
      }
	  
      case cAge2:
      { 
         // Add a baseline just to make sure we don't get any near-zero resource amounts
		 //if (xsGetTime() > 10*60*1000)
		 //{
         xsArraySetFloat(gForecasts, cResourceFood, xsArrayGetFloat(gForecasts, cResourceFood) + 1200.0);
         xsArraySetFloat(gForecasts, cResourceGold, xsArrayGetFloat(gForecasts, cResourceGold) + 1000.0);
		 //}
		 
			if ((cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPAztec) || (cMyCiv == cCivBritish) || (cMyCiv == cCivIndians) || (cMyCiv == cCivJapanese)) 
			{
         xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 0.0);
			}
		 else
			{
         xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 0.0);
			} 
         
		 /*
		 if (xsGetTime() < 8*60*1000)
		 {
         if (cMyCiv == cCivDutch)
         {
         kbEscrowFlush(cEconomyEscrowID, cResourceGold, true);
		 }
		 else if (cMyCiv == cCivIndians)
		 {
         kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);
		 }
		 else if (cMyCiv != cCivRussians)
		 {
         kbEscrowFlush(cEconomyEscrowID, cResourceFood, true);
		 }
		 }*/
			 
         if (cMyCiv != cCivOttomans)
         {
            numUnits = xsArrayGetInt(gTargetSettlerCounts) - kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
			if (numUnits > 0)
			{
            addItemToForecasts(gEconUnit, numUnits); //, numUnits);
			}
         }
		 
		 /*
         if (cMyCiv != cCivOttomans)
         {
            numUnits = xsArrayGetInt(gTargetSettlerCounts) >= kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
            addItemToForecasts(gEconUnit); 
         }
         */
		 
         //if ((xsGetTime() > 8*60*1000) || (cMyCiv == cCivOttomans) ||( cMyCiv == cCivPortuguese) || (cMyCiv == cCivGermans))
         //{
            if (civIsAsian() == false)
            {
               addTechToForecasts(aiGetPoliticianListByIndex(cAge3, 0));
               if (gSPC == false)
                  addTechToForecasts(aiGetPoliticianListByIndex(cAge3, 0));   // Add it again to make the age 3 upgrade more reliable.
            }
            else 
            {
              addItemToForecasts(getPreferredWonderToBuild(cAge3), 1);
              if (gSPC == false)
                  addItemToForecasts(getPreferredWonderToBuild(cAge3), 1);   // Add it again to make the age 3 upgrade more reliable.
            }
         //}
		 
		 
            if ((kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < kbGetBuildLimit(cMyID, gHouseUnit)) && (cMyCiv != cCivXPSioux))
               addItemToForecasts(gHouseUnit, 2);
         
         /*if (xsGetTime() >= 10*60*1000)
            {
            xsArraySetInt(gForecasts, cResourceFood, 1400 + xsArrayGetInt(gForecasts, cResourceFood));
            xsArraySetInt(gForecasts, cResourceGold, 1200 + xsArrayGetInt(gForecasts, cResourceGold));
         }*/
		 
		 
			   
         if (cMyCiv == cCivOttomans)
         {
            if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeChurch, 1);
            if (kbTechGetStatus(cTechChurchKopruluViziers) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechChurchKopruluViziers);
            }
            if (kbTechGetStatus(cTechChurchGalataTowerDistrict) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechChurchGalataTowerDistrict);
            }
         }

         // Ships for water maps
         if (gNavyMode == cNavyModeActive)
         {
            numCaravel = kbGetBuildLimit(cMyID, gCaravelUnit);
            numGalleon = kbGetBuildLimit(cMyID, gGalleonUnit);

            if (civIsNative() == false)
            {
               if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < numCaravel)
                  addItemToForecasts(gCaravelUnit, numCaravel);
               if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < numGalleon)
                  addItemToForecasts(gGalleonUnit, numGalleon);
            }
            else
            {
               if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < numCaravel)
                  addItemToForecasts(gCaravelUnit, numGalleon);
            }
         }

         if (cMyCiv == cCivChinese)
         {
            if (kbTechGetStatus(cTechypVillagePopCapIncrease) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypVillagePopCapIncrease);
            }
         }

         if (cMyCiv == cCivDutch)
         {
            if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank))
               addItemToForecasts(cUnitTypeBank);

			xsArraySetFloat(gForecasts, cResourceFood, xsArrayGetFloat(gForecasts, cResourceFood) + 1500.0);
			xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 1500.0);
         }
		 
		
         if (cMyCiv == cCivBritish)
         {
            if (kbUnitCount(cMyID, cUnitTypeManor, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeManor))
         //kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);
               addItemToForecasts(cUnitTypeManor);
         }
         
         if (cMyCiv == cCivJapanese)
         {
            if (kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeypShrineJapanese))
         //kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);
               addItemToForecasts(cUnitTypeypShrineJapanese);
         }
         
         if (civIsAsian() == true)
         {
            if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeypConsulate, 1);
         }
         
         if (cMyCiv == cCivIndians)
         {
            if (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateABQ) < 2)
               addItemToForecasts(cUnitTypeypSacredField, 2 - kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateABQ));
         } 

         if ((civIsNative() == true) && (kbGetAge() >= cAge4))
         {
            if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeFirePit, 1);
         }
		 

         if  (cMyCiv == cCivOttomans)
         {
            if (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeArtilleryDepot, 1);  
         }
		 
         if ((cMyCiv != cCivXPSioux) && (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) +  
               kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateABQ) ) < 1)
			   {
				addItemToForecasts(gBarracksUnit, 1);
				if (cMyCiv == cCivJapanese)
				{
				addItemToForecasts(cUnitTypeypBarracksJapanese, 1);
				}
			   }
         
         if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese) && (cMyCiv != cCivXPIroquois) && (cMyCiv != cCivJapanese))
        {
            if ( (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ) ) < 1)
			   {
				addItemToForecasts(gStableUnit, 1);/*
				if (cMyCiv == cCivJapanese)
				{
				addItemToForecasts(cUnitTypeypStableJapanese, 1);
				}*/
			   }
		}
			  
         if (kbUnitCount(cMyID, gMarketUnit, cUnitStateABQ) < 1)
            addItemToForecasts(gMarketUnit, 1);
		 
		 
         aiEcho("And the primary military unit is: "+kbUnitPickGetResult( gLandUnitPicker, 0));
		 
         if (gLandUnitPicker >= 0)
         {  
      //kbEscrowFlush(cMilitaryEscrowID, cResourceWood, true);
      //kbEscrowFlush(cMilitaryEscrowID, cResourceGold, true);
      //kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
	  
            /*gUnitPickPlayerID = -1;
            cvPrimaryArmyUnit = -1;
            cvSecondaryArmyUnit = -1;
            setUnitPickerPreference(gLandUnitPicker); */ 
            militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 0);
            if (militaryUnit >= 0)
            {
               popSlots = kbGetPopSlots(cMyID, militaryUnit);
               if (popSlots < 1)
                  popSlots = 1;
               milQty = 20 / popSlots; 
               addItemToForecasts(militaryUnit, milQty);
            }          
            
            // Add 8 pop slots of secondary military unit
            if (kbUnitPickGetNumberResults(gLandUnitPicker) > 1)
            {
               militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 1);
               if (militaryUnit >= 0)
               {
                  popSlots = kbGetPopSlots(cMyID, militaryUnit);
                  if (popSlots < 1)
                     popSlots = 1;
                  milQty = 20 / popSlots; 
                  addItemToForecasts(militaryUnit, milQty);
               } 
            }
         }
		 
         
         if ( (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < gNumTowers) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 1) )
         {
            if (cMyCiv != cCivXPAztec)
               addItemToForecasts(gTowerUnit, gNumTowers - kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ)); 
         }
        
         if (agingUp() == true)
         {            
            if (cMyCiv == cCivOttomans)
	    {
            if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeTownCenter))
               addItemToForecasts(cUnitTypeTownCenter);
	    }
	    else if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < 2)
	    {
            if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeTownCenter))
               addItemToForecasts(cUnitTypeTownCenter);
	    }
         }
		 
         break;
      }
	  
      case cAge3:
      { 
         // Add a baseline just to make sure we don't get any near-zero resource amounts
		 //if (xsGetTime() >= 15*60*1000)
		 //{
         xsArraySetFloat(gForecasts, cResourceFood, xsArrayGetFloat(gForecasts, cResourceFood) + 2400.0);
         xsArraySetFloat(gForecasts, cResourceGold, xsArrayGetFloat(gForecasts, cResourceGold) + 1200.0);
		 //}
		 
			if ((cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPAztec) || (cMyCiv == cCivBritish) || (cMyCiv == cCivIndians) || (cMyCiv == cCivJapanese)) 
			{
         xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 0.0);
			}
		 else
			{
         xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 0.0);
			} 
         
			   
         if (cMyCiv != cCivOttomans)
         {
            numUnits = xsArrayGetInt(gTargetSettlerCounts) - kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
			if (numUnits > 0)
			{/*
         if (cMyCiv == cCivDutch)
         {
         kbEscrowFlush(cEconomyEscrowID, cResourceGold, true);
		 }
		 else if (cMyCiv == cCivIndians)
		 {
         kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);
		 }
		 else
		 {
         kbEscrowFlush(cEconomyEscrowID, cResourceFood, true);
		 }*/
            addItemToForecasts(gEconUnit, numUnits); //, numUnits);
			}
         }
		 
		 /*
         if (cMyCiv != cCivOttomans)
         {
            numUnits = xsArrayGetInt(gTargetSettlerCounts) - kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
            addItemToForecasts(1); //, numUnits);
         }
		 */
         
         //if (xsGetTime() >= 15*60*1000) //) || (cMyCiv == cCivOttomans) ||( cMyCiv == cCivPortuguese) || (cMyCiv == cCivGermans))
         //{
            if (civIsAsian() == false)
            {
               addTechToForecasts(aiGetPoliticianListByIndex(cAge4, 0));
               addTechToForecasts(aiGetPoliticianListByIndex(cAge4, 0));
               if (gSPC == false)
                  addTechToForecasts(aiGetPoliticianListByIndex(cAge4, 0));   // Add it again to make the age 3 upgrade more reliable.
                  addTechToForecasts(aiGetPoliticianListByIndex(cAge4, 0));   // Add it again to make the age 3 upgrade more reliable.
            }
            else 
            {
              addItemToForecasts(getPreferredWonderToBuild(cAge4), 1);
              addItemToForecasts(getPreferredWonderToBuild(cAge4), 1);
              if (gSPC == false)
                  addItemToForecasts(getPreferredWonderToBuild(cAge4), 1);   // Add it again to make the age 3 upgrade more reliable.
                  addItemToForecasts(getPreferredWonderToBuild(cAge4), 1);   // Add it again to make the age 3 upgrade more reliable.
            }
         //}
		 
		 
         /*if (xsGetTime() >= 15*60*1000)
            {
            xsArraySetInt(gForecasts, cResourceFood, 2400 + xsArrayGetInt(gForecasts, cResourceFood));
            xsArraySetInt(gForecasts, cResourceGold, 1600 + xsArrayGetInt(gForecasts, cResourceGold));
         }*/
		 
		 
            if ((kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < kbGetBuildLimit(cMyID, gHouseUnit)) && (cMyCiv != cCivXPSioux))
               addItemToForecasts(gHouseUnit, 3);
         
         if (gNavyMode == cNavyModeActive)
         {
            numCaravel = kbGetBuildLimit(cMyID, gCaravelUnit);
            numGalleon = kbGetBuildLimit(cMyID, gGalleonUnit);
            numFrigate = kbGetBuildLimit(cMyID, gFrigateUnit);

            if(civIsNative() == false)
            {
               if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < numCaravel)
                  addItemToForecasts(gCaravelUnit, numCaravel);
               if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < numGalleon)
                  addItemToForecasts(gGalleonUnit, numGalleon);
               if ((kbGetCiv() != cCivChinese) && (kbGetCiv() != cCivSPCChinese))
               {
                  if (kbUnitCount(cMyID, gFrigateUnit, cUnitStateAlive) < numFrigate)
                     addItemToForecasts(gFrigateUnit, numFrigate);
               }
               if (kbTechGetStatus(cTechCarronade) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechCarronade);
               }
               if (kbTechGetStatus(cTechArmorPlating) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechArmorPlating);
               }
            }
            else
            {
               if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < numCaravel)
                  addItemToForecasts(gCaravelUnit, numCaravel);
               if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < numGalleon)
                  addItemToForecasts(gGalleonUnit, numGalleon);
            }
         }

         if (cMyCiv == cCivOttomans)
         {
            if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeChurch, 1);
            if (kbTechGetStatus(cTechChurchAbbassidMarket) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechChurchAbbassidMarket);
            }
            if (kbTechGetStatus(cTechChurchTopkapi) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechChurchTopkapi);
            }
         }
         else if ((civIsNative() == false) && (civIsAsian() == false))  // Other non-native/non-Asian civs - just the church
         {
            if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeChurch, 1);   
         }

         if ((civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeypMonastery, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeypMonastery, 1);

         if ((civIsNative() == false) && (civIsAsian() == false))  
         {
            if (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechChurchGasLighting);
            }
            if (kbTechGetStatus(cTechChurchTownWatch) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechChurchTownWatch);
            }
         }

         switch(kbGetCiv())
         {
            case cCivBritish:
            {
               if (kbTechGetStatus(cTechChurchBlackWatch) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchBlackWatch);
               }
               break;
            }
            case cCivDutch:
            {
               if (kbTechGetStatus(cTechChurchWaardgelders) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchWaardgelders);
               }
               break;
            }
            case cCivFrench:
            {
               if (kbTechGetStatus(cTechChurchGardeImperial1) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchGardeImperial1);
               }
               if (kbTechGetStatus(cTechChurchGardeImperial2) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchGardeImperial2);
               }
               break;
            }
            case cCivGermans:
            {
               break; // no tech researched in Age 3
            }
            case cCivOttomans:
            {
               if (kbTechGetStatus(cTechChurchTufanciCorps) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchTufanciCorps);
               }
               break;
            }
            case cCivPortuguese:
            {
               if (kbTechGetStatus(cTechChurchBestieros) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchBestieros);
               }
               break;
            }
            case cCivRussians:
            {
               if (kbTechGetStatus(cTechChurchWesternization) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchWesternization);
               }
               if (kbTechGetStatus(cTechChurchKalmucks) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchKalmucks);
               }
               break;
            }
            case cCivSpanish:
            {
               if (kbTechGetStatus(cTechChurchQuatrefage) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchQuatrefage);
               }
               break;
            }
         }

         if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) >= 3)
         {
            if ((civIsNative() == false) && (civIsAsian() == false) && (cMyCiv != cCivRussians))
            {
               if (kbTechGetStatus(cTechFrontierOutpost) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechFrontierOutpost);
               }
            }
            else if (cMyCiv == cCivRussians)
            {
               if (kbTechGetStatus(cTechFrontierBlockhouse) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechFrontierBlockhouse);
               }
            }
            else if (civIsAsian() == true)
            {
               if (kbTechGetStatus(cTechypFrontierCastle) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechypFrontierCastle);
               }
            }
            else if (cMyCiv == cCivXPIroquois)
            {
               if (kbTechGetStatus(cTechStrongWarHut) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechStrongWarHut);
               }
            }
            else if (cMyCiv == cCivXPAztec)
            {
               if (kbTechGetStatus(cTechStrongNoblesHut) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechStrongNoblesHut);
               }
            }
         }

         if ((cMyCiv == cCivXPAztec) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) >= 3))
         {
            if (kbTechGetStatus(cTechStrongWarHut) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechStrongWarHut);
            }
         }

         if ((kbUnitCount(cMyID, cUnitTypeypWIAgraFort2, cUnitStateAlive) > 0) ||
             (kbUnitCount(cMyID, cUnitTypeypWIAgraFort3, cUnitStateAlive) > 0) ||
             (kbUnitCount(cMyID, cUnitTypeypWIAgraFort4, cUnitStateAlive) > 0) ||
             (kbUnitCount(cMyID, cUnitTypeypWIAgraFort5, cUnitStateAlive) > 0))
         {
            if (kbTechGetStatus(cTechypFrontierAgra) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypFrontierAgra);
            }
         }

         if (cMyCiv == cCivChinese)
         {
            if (kbTechGetStatus(cTechypVillagePopCapIncrease2) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypVillagePopCapIncrease2);
            }
         }

         if (cMyCiv == cCivDutch)
         {
            if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank))
               addItemToForecasts(cUnitTypeBank);

            xsArraySetInt(gForecasts, cResourceFood, 0 + xsArrayGetInt(gForecasts, cResourceFood));
            xsArraySetInt(gForecasts, cResourceWood, 0 + xsArrayGetInt(gForecasts, cResourceWood));
         }
		
         if (cMyCiv == cCivBritish)
         {
            if (kbUnitCount(cMyID, cUnitTypeManor, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeManor))
         //kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);
               addItemToForecasts(cUnitTypeManor);
         }
         
         if (cMyCiv == cCivJapanese)
         {
            if (kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeypShrineJapanese))
         //kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);
               addItemToForecasts(cUnitTypeypShrineJapanese);
         }
         
         if (cMyCiv == cCivIndians)
         {
            if (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateABQ) < 2)
               addItemToForecasts(cUnitTypeypSacredField, 2 - kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateABQ));
         } 

         if ((civIsNative() == true) && (kbGetAge() >= cAge4))
         {
            if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeFirePit, 1);
         }

         if (civIsAsian() == true)
         {
            if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeypConsulate, 1);
         }

         if ((cMyCiv != cCivXPSioux) && (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateABQ) ) < 2)
			   {
				addItemToForecasts(gBarracksUnit, 2);
				if (cMyCiv == cCivJapanese)
				{
				addItemToForecasts(cUnitTypeypBarracksJapanese, 2);
				}
			   }
         
         if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese))
        {
            if ( (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ) ) < 2)
			   {
				addItemToForecasts(gStableUnit, 2);
				if (cMyCiv == cCivJapanese)
				{
				addItemToForecasts(cUnitTypeypStableJapanese, 2);
				}
			   }
		}

         if ( (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux) && (civIsAsian() == false) ) 
         {
            if (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeArtilleryDepot, 1);  
         }

         if (civIsAsian() == true) 
         {
            if (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeypCastle, 1);  
         }

         if (kbUnitCount(cMyID, gMarketUnit, cUnitStateABQ) < 1)
            addItemToForecasts(gMarketUnit, 1);


         if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeTownCenter))
               addItemToForecasts(cUnitTypeTownCenter);
         
         aiEcho("And the primary military unit is: "+kbUnitPickGetResult( gLandUnitPicker, 0));
		 
         if (gLandUnitPicker >= 0)
         {
      //kbEscrowFlush(cMilitaryEscrowID, cResourceWood, true);
      //kbEscrowFlush(cMilitaryEscrowID, cResourceGold, true);
      //kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
            militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 0);
            if (militaryUnit >= 0)
            {
               popSlots = kbGetPopSlots(cMyID, 5);
               if (popSlots < 1)
                   popSlots = 1;
               milQty = 30 / popSlots; 
               addItemToForecasts(militaryUnit, milQty);
            }          
            
            // Add 8 pop slots of secondary military unit
            if (kbUnitPickGetNumberResults(gLandUnitPicker) > 1)
            {
               militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 1);
               if (militaryUnit >= 0)
               {
                  popSlots = kbGetPopSlots(cMyID, militaryUnit);
                  if (popSlots < 1)
                      popSlots = 1;
                  milQty = 30 / popSlots; 
                  addItemToForecasts(militaryUnit, milQty);
               } 
            }
         }
		 
 
         if ( (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < gNumTowers) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 55) )
            addItemToForecasts(gTowerUnit, gNumTowers - kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ)); 
         
         break;
      }
	  
      case cAge4:
      { 
         // Add a baseline just to make sure we don't get any near-zero resource amounts
		 //if (xsGetTime() >= 20*60*1000)
		 //{
         xsArraySetFloat(gForecasts, cResourceFood, xsArrayGetFloat(gForecasts, cResourceFood) + 4000.0);
         xsArraySetFloat(gForecasts, cResourceGold, xsArrayGetFloat(gForecasts, cResourceGold) + 4000.0);
		 //}
		 
			if ((cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPAztec) || (cMyCiv == cCivBritish) || (cMyCiv == cCivIndians) || (cMyCiv == cCivJapanese)) 
			{
         xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 0.0);
			}
		 else
			{
         xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 0.0);
			} 
			
         if (cMyCiv != cCivOttomans)
         {
            numUnits = xsArrayGetInt(gTargetSettlerCounts) - kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
			if (numUnits > 0)
			{/*
         if (cMyCiv == cCivDutch)
         {
         kbEscrowFlush(cEconomyEscrowID, cResourceGold, true);
		 }
		 else if (cMyCiv == cCivIndians)
		 {
         kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);
		 }
		 else
		 {
         kbEscrowFlush(cEconomyEscrowID, cResourceFood, true);
		 }*/
            addItemToForecasts(gEconUnit, numUnits); //, numUnits);
			}
         }
			 
		 /*
         if (cMyCiv != cCivOttomans)
         {
            numUnits = xsArrayGetInt(gTargetSettlerCounts) - kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
            addItemToForecasts(gEconUnit); //, numUnits);
         }
		 */
         
         //if ((xsGetTime() >= 20*60*1000)) 
         //{
            if (civIsAsian() == false)
            {
               addTechToForecasts(aiGetPoliticianListByIndex(cAge5, 0));
               addTechToForecasts(aiGetPoliticianListByIndex(cAge5, 0));
               if (gSPC == false)
                  addTechToForecasts(aiGetPoliticianListByIndex(cAge5, 0));   // Add it again to make the age 3 upgrade more reliable.
                  addTechToForecasts(aiGetPoliticianListByIndex(cAge5, 0));   // Add it again to make the age 3 upgrade more reliable.
            }
            else 
            {
              addItemToForecasts(getPreferredWonderToBuild(cAge5), 1);
              addItemToForecasts(getPreferredWonderToBuild(cAge5), 1);
              if (gSPC == false)
                  addItemToForecasts(getPreferredWonderToBuild(cAge5), 1);   // Add it again to make the age 3 upgrade more reliable.
                  addItemToForecasts(getPreferredWonderToBuild(cAge5), 1);   // Add it again to make the age 3 upgrade more reliable.
            }
        // }
		 
         /*if (xsGetTime() >= 20*60*1000)
            {
            xsArraySetInt(gForecasts, cResourceFood, 0 + xsArrayGetInt(gForecasts, cResourceFood));
            xsArraySetInt(gForecasts, cResourceGold, 0 + xsArrayGetInt(gForecasts, cResourceGold));
         }*/
		 
         
         // 3 houses
            if ((kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < kbGetBuildLimit(cMyID, gHouseUnit)) && (cMyCiv != cCivXPSioux))
               addItemToForecasts(gHouseUnit, 4);
		 
		 
         // Ships and navy techs for water maps
         // Ships for water maps
         if (gNavyMode == cNavyModeActive)
         {
            numCaravel = kbGetBuildLimit(cMyID, gCaravelUnit);
            numGalleon = kbGetBuildLimit(cMyID, gGalleonUnit);
            numFrigate = kbGetBuildLimit(cMyID, gFrigateUnit);
            numMonitor = kbGetBuildLimit(cMyID, cUnitTypeMonitor);
            numCanoe = 20;

            if(civIsNative() == false)
            {
               if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < numCaravel)
                  addItemToForecasts(gCaravelUnit, numCaravel);
               if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < numGalleon)
                  addItemToForecasts(gGalleonUnit, numGalleon);
               if ((kbGetCiv() != cCivChinese) && (kbGetCiv() != cCivSPCChinese))
               {
                  if (kbUnitCount(cMyID, gFrigateUnit, cUnitStateAlive) < numFrigate)
                     addItemToForecasts(gFrigateUnit, numFrigate);
               }
               if (kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) < numMonitor)
                  addItemToForecasts(cUnitTypeMonitor, numMonitor);
               if (kbUnitCount(cMyID, cUnitTypeCanoe, cUnitStateAlive) < numCanoe)
                  addItemToForecasts(cUnitTypeCanoe, numCanoe);
            }
            else
            {
               if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < numCaravel)
                  addItemToForecasts(gCaravelUnit, numCaravel);
               if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < numGalleon)
                  addItemToForecasts(gGalleonUnit, numGalleon);
               if (kbUnitCount(cMyID, cUnitTypeCanoe, cUnitStateAlive) < numCanoe)
                  addItemToForecasts(cUnitTypeCanoe, numCanoe);
            }
         }
         // Ottoman - mosque and techs
         if (cMyCiv == cCivOttomans)
         {
            if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeChurch, 1);
            if (kbTechGetStatus(cTechChurchAbbassidMarket) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechChurchAbbassidMarket);
            }
            if (kbTechGetStatus(cTechChurchTanzimat) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechChurchTanzimat);
            }
         }
         else if ((civIsNative() == false) && (civIsAsian() == false))  // Other non-native/non-Asian civs - just the church
         {
            if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeChurch, 1);   
         }

         // Mosque or church (not for natives or Asians)
         if ((civIsNative() == false) && (civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeChurch, 1);   

         // Asians - one monastery
         if ((civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeypMonastery, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeypMonastery, 1);

         // Basic church upgrades (not for natives or Asians)
         if ((civIsNative() == false) && (civIsAsian() == false))
         {
            if (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechChurchStandingArmy);
            }
            if (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechChurchMassCavalry);
            }
         }

         // Unique church upgrades and troops
         switch(kbGetCiv())
         {
            case cCivBritish:
            {
               if (kbTechGetStatus(cTechChurchRogersRangers) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchRogersRangers);
               }
               break;
            }
            case cCivDutch:
            {
               if (kbTechGetStatus(cTechChurchStadholders) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchStadholders);
               }
               break;
            }
            case cCivFrench:
            {
               if (kbTechGetStatus(cTechChurchGardeImperial3) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchGardeImperial3);
               }
               break;
            }
            case cCivGermans:
            {
               if (kbTechGetStatus(cTechChurchZweihander) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchZweihander);
               }
               break;
            }
            case cCivOttomans:
            {
               if (kbTechGetStatus(cTechChurchTopcuCorps) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchTopcuCorps);
               }
               break;
            }
            case cCivPortuguese:
            {
               if (kbTechGetStatus(cTechChurchTowerAndSword) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchTowerAndSword);
               }
               break;
            }
            case cCivRussians:
            {
               if (kbTechGetStatus(cTechChurchPetrineReforms) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchPetrineReforms);
               }
               if (kbTechGetStatus(cTechChurchBashkirPonies) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchBashkirPonies);
               }
               break;
            }
            case cCivSpanish:
            {
               if (kbTechGetStatus(cTechChurchWildGeeseSpanish) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechChurchWildGeeseSpanish);
               }
               break;
            }
         }

         // Factory upgrades (provided there is at least one)
         if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0)  
         {
            if (kbTechGetStatus(cTechFactoryMassProduction) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechFactoryMassProduction);
            }
         }
         if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 1)  
         {
            if (kbTechGetStatus(cTechFactorySteamPower) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechFactorySteamPower);
            }
         }

         // Fort upgrades (provided there is at least one)
         if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive) > 1)  
         {
            if (kbTechGetStatus(cTechRevetment) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechRevetment);
            }
            if (kbTechGetStatus(cTechStarFort) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechStarFort);
            }
         }

         // Tower upgrades (provided there are enough around)
         if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) >= 3)
         {
            if ((civIsNative() == false) && (civIsAsian() == false) && (cMyCiv != cCivRussians))
            {
               if (kbTechGetStatus(cTechFrontierOutpost) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechFrontierOutpost);
               }
            }
            else if (cMyCiv == cCivRussians)
            {
               if (kbTechGetStatus(cTechFrontierBlockhouse) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechFrontierBlockhouse);
               }
            }
            else if (civIsAsian() == true)
            {
               if (kbTechGetStatus(cTechypFrontierCastle) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechypFrontierCastle);
               }
            }
            else if (cMyCiv == cCivXPIroquois)
            {
               if (kbTechGetStatus(cTechStrongWarHut) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechStrongWarHut);
               }
            }
            else if (cMyCiv == cCivXPAztec)
            {
               if (kbTechGetStatus(cTechStrongNoblesHut) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechStrongNoblesHut);
               }
            }
         }
         if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) >= 5)
         {
            if ((civIsNative() == false) && (civIsAsian() == false) && (cMyCiv != cCivRussians))
            {
               if (kbTechGetStatus(cTechFortifiedOutpost) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechFortifiedOutpost);
               }
            }
            else if (cMyCiv == cCivRussians)
            {
               if (kbTechGetStatus(cTechFortifiedBlockhouse) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechFortifiedBlockhouse);
               }
            }
            else if (civIsAsian() == true)
            {
               if (kbTechGetStatus(cTechypFortifiedCastle) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechypFortifiedCastle);
               }
            }
            else if (cMyCiv == cCivXPIroquois)
            {
               if (kbTechGetStatus(cTechMightyWarHut) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechMightyWarHut);
               }
            }
            else if (cMyCiv == cCivXPAztec)
            {
               if (kbTechGetStatus(cTechMightyNoblesHut) == cTechStatusObtainable)
               {
                  addTechToForecasts(cTechMightyNoblesHut);
               }
            }
         }

         // Aztec warhut upgrades (provided there are enough around)
         if ((cMyCiv == cCivXPAztec) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) >= 3))
         {
            if (kbTechGetStatus(cTechStrongWarHut) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechStrongWarHut);
            }
         }
         if ((cMyCiv == cCivXPAztec) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) >= 5))
         {
            if (kbTechGetStatus(cTechMightyWarHut) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechMightyWarHut);
            }
         }

         // Agra fort upgrades (provided there is one)
         if ((kbUnitCount(cMyID, cUnitTypeypWIAgraFort2, cUnitStateAlive) > 0) ||
             (kbUnitCount(cMyID, cUnitTypeypWIAgraFort3, cUnitStateAlive) > 0) ||
             (kbUnitCount(cMyID, cUnitTypeypWIAgraFort4, cUnitStateAlive) > 0) ||
             (kbUnitCount(cMyID, cUnitTypeypWIAgraFort5, cUnitStateAlive) > 0))
         {
            if (kbTechGetStatus(cTechypFrontierAgra) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypFrontierAgra);
            }
            if (kbTechGetStatus(cTechypFortifiedAgra) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypFortifiedAgra);
            }
         }

         // Japanese - dojo upgrade (provided there is one)
         if ((cMyCiv == cCivJapanese) && (kbUnitCount(cMyID, cUnitTypeypDojo, cUnitStateAlive) > 0))
         {
            if (kbTechGetStatus(cTechypDojoUpgrade1) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypDojoUpgrade1);
            }
         }

         // Japanese - shrine upgrade (provided there are enough around)
         if (cMyCiv == cCivJapanese)
         {
            if ((kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine2, cUnitStateAlive) > 0) ||
                (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine3, cUnitStateAlive) > 0) ||
                (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine4, cUnitStateAlive) > 0) ||
                (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine5, cUnitStateAlive) > 0))
            {
               if ((kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) >= 10) &&
                   (kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable))
               {
                  addTechToForecasts(cTechypShrineFortressUpgrade);
               }
            }
            else if ((kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) >= 16) &&
                     (kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable))
            {
               addTechToForecasts(cTechypShrineFortressUpgrade);
            }
         }

         // Indians - sacred field upgrade (provided there is one)
         if ((cMyCiv == cCivIndians) && (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateAlive) > 0))
         {
            if (kbTechGetStatus(cTechypLivestockHoliness) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypLivestockHoliness);
            }
         }

         // Chinese - third village upgrade
         if (cMyCiv == cCivChinese)
         {
            if (kbTechGetStatus(cTechypVillagePopCapIncrease3) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypVillagePopCapIncrease3);
            }
         }

         // While aging up, add wood for additional Portuguese town center in Age 5
         if ((cMyCiv == cCivPortuguese) && (agingUp() == true))
         {            
            if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeTownCenter))
               addItemToForecasts(cUnitTypeTownCenter);
         }

         // Dutch - 8 banks (including those made available by the coffee trade tech)
         if (cMyCiv == cCivDutch)
         {
            if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank))
               addItemToForecasts(cUnitTypeBank);

            xsArraySetInt(gForecasts, cResourceFood, 0 + xsArrayGetInt(gForecasts, cResourceFood));
            xsArraySetInt(gForecasts, cResourceWood, 0 + xsArrayGetInt(gForecasts, cResourceWood));
         }
		 
         if (cMyCiv == cCivBritish)
         {
            if (kbUnitCount(cMyID, cUnitTypeManor, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeManor))
               addItemToForecasts(cUnitTypeManor);
         }
         
         if (cMyCiv == cCivJapanese)
         {
            if (kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeypShrineJapanese))
               addItemToForecasts(cUnitTypeypShrineJapanese);
         }
         
         
         // Indians - 2 sacred fields
         if (cMyCiv == cCivIndians)
         {
            if (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateABQ) < 2)
               addItemToForecasts(cUnitTypeypSacredField, 2 - kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateABQ));
         } 

         // Natives - one fire pit
         if ((civIsNative() == true) && (kbGetAge() >= cAge4))
         {
            if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeFirePit, 1);
         }

         // Asians - one consulate
         if (civIsAsian() == true)
         {
            if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeypConsulate, 1);
         }

         if ((cMyCiv != cCivXPSioux) && (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateABQ) ) < 4)
			   {
				addItemToForecasts(gBarracksUnit, 4);
				if (cMyCiv == cCivJapanese)
				{
				addItemToForecasts(cUnitTypeypBarracksJapanese, 4);
				}
			   }
         
         if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese))
        {
            if ( (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ) ) < 4)
			   {
				addItemToForecasts(gStableUnit, 4);
				if (cMyCiv == cCivJapanese)
				{
				addItemToForecasts(cUnitTypeypStableJapanese, 4);
				}
			   }
		}

         // 1 artillery depot (not for Aztecs, Sioux or Asians)
         if ( (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux) && (civIsAsian() == false) ) 
         {
            if (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeArtilleryDepot, 1);  
         }

         // 2 additional blockhouses for Russian (up to 4 in total)
         if (kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) < 4)
            addItemToForecasts(cUnitTypeBlockhouse, 4);

         // 5 additional war hut for Iroquois (up to 9 in total)
         if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < 9)
            addItemToForecasts(cUnitTypeWarHut, 9);

         // One castle for Asians
         if (civIsAsian() == true) 
         {
            if (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeypCastle, 1);  
         }

         // One market
         if (kbUnitCount(cMyID, gMarketUnit, cUnitStateABQ) < 1)
            addItemToForecasts(gMarketUnit, 1);

         // One town center
            if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeTownCenter))
               addItemToForecasts(cUnitTypeTownCenter);
            
         aiEcho("And the primary military unit is: "+kbUnitPickGetResult( gLandUnitPicker, 0));
		 
         if (gLandUnitPicker >= 0)
         {
      //kbEscrowFlush(cMilitaryEscrowID, cResourceWood, true);
      //kbEscrowFlush(cMilitaryEscrowID, cResourceGold, true);
      //kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
            militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 0);
            if (militaryUnit >= 0)
            {
               popSlots = kbGetPopSlots(cMyID, militaryUnit);
               if (popSlots < 1)
                   popSlots = 1;
               milQty = 40 / popSlots; 
               addItemToForecasts(militaryUnit, milQty);
            }          
            
            // Add 8 pop slots of secondary military unit
            if (kbUnitPickGetNumberResults(gLandUnitPicker) > 1)
            {
               militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 1);
               if (militaryUnit >= 0)
               {
                  popSlots = kbGetPopSlots(cMyID, militaryUnit);
                  if (popSlots < 1)
                      popSlots = 1;
                  milQty = 40 / popSlots; 
                  addItemToForecasts(militaryUnit, milQty);
               } 
            }
         }
         
         // Check towers
         if ( (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < gNumTowers) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 65) )
            addItemToForecasts(gTowerUnit, gNumTowers - kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ)); 
         
         break;
      }
      case cAge5:
      {
         // Add a baseline just to make sure we don't get any near-zero resource amounts
         xsArraySetFloat(gForecasts, cResourceFood, xsArrayGetFloat(gForecasts, cResourceFood) + 3000.0);
         xsArraySetFloat(gForecasts, cResourceGold, xsArrayGetFloat(gForecasts, cResourceGold) + 3000.0);
			if ((cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPAztec) || (cMyCiv == cCivBritish) || (cMyCiv == cCivIndians) || (cMyCiv == cCivJapanese)) 
			{
         xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 3000.0);
			}
		 else
			{
         xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 3000.0);
			} 
         
            //xsArraySetInt(gForecasts, cResourceWood, 6000 + xsArrayGetInt(gForecasts, cResourceWood));
		 
         if (cMyCiv != cCivOttomans)
         {
            numUnits = xsArrayGetInt(gTargetSettlerCounts) - kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
			if (numUnits > 0)
			{/*
         if (cMyCiv == cCivDutch)
         {
         kbEscrowFlush(cEconomyEscrowID, cResourceGold, true);
		 }
		 else if (cMyCiv == cCivIndians)
		 {
         kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);
		 }
		 else
		 {
         kbEscrowFlush(cEconomyEscrowID, cResourceFood, true);
		 }*/
            addItemToForecasts(gEconUnit, numUnits); //, numUnits);
			}
         }
			   
		 /*
         // 8 houses
            if ((kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < kbGetBuildLimit(cMyID, gHouseUnit)) && (cMyCiv != cCivXPSioux))
               addItemToForecasts(gHouseUnit, 5);
         */
				  
         // Ships for water maps
         if (gNavyMode == cNavyModeActive)
         {
            numCaravel = kbGetBuildLimit(cMyID, gCaravelUnit);
            numGalleon = kbGetBuildLimit(cMyID, gGalleonUnit);
            numFrigate = kbGetBuildLimit(cMyID, gFrigateUnit);
            numMonitor = kbGetBuildLimit(cMyID, cUnitTypeMonitor);
            numCanoe = 20;

            if(civIsNative() == false)
            {
               if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < numCaravel)
                  addItemToForecasts(gCaravelUnit, numCaravel);
               if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < numGalleon)
                  addItemToForecasts(gGalleonUnit, numGalleon);
               if ((kbGetCiv() != cCivChinese) && (kbGetCiv() != cCivSPCChinese))
               {
                  if (kbUnitCount(cMyID, gFrigateUnit, cUnitStateAlive) < numFrigate)
                     addItemToForecasts(gFrigateUnit, numFrigate);
               }
               if (kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) < numMonitor)
                  addItemToForecasts(cUnitTypeMonitor, numMonitor);
               if (kbUnitCount(cMyID, cUnitTypeCanoe, cUnitStateAlive) < numCanoe)
                  addItemToForecasts(cUnitTypeCanoe, numCanoe);
            }
            else
            {
               if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < numCaravel)
                  addItemToForecasts(gCaravelUnit, numCaravel);
               if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < numGalleon)
                  addItemToForecasts(gGalleonUnit, numGalleon);
               if (kbUnitCount(cMyID, cUnitTypeCanoe, cUnitStateAlive) < numCanoe)
                  addItemToForecasts(cUnitTypeCanoe, numCanoe);
            }
         }
         
         // Mosque or church (not for natives or Asians)
         if ((civIsNative() == false) && (civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeChurch, 1);   

         // Capitol (not for natives or Asians)
         if ((civIsNative() == false) && (civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeCapitol, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeCapitol, 1);   

         // Asians - one monastery
         if ((civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeypMonastery, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeypMonastery, 1);
         
         // Natives - one fire pit
         if ((civIsNative() == true) && (kbGetAge() >= cAge4))
         {
            if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeFirePit, 1);
         }

         // Asians - one consulate
         if (civIsAsian() == true)
         {
            if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeypConsulate, 1);
         }

         // Factory upgrades (provided there is at least one)
         if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0)  
         {
            if (kbTechGetStatus(cTechFactoryMassProduction) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechFactoryMassProduction);
            }
         }
         if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 1)  
         {
            if (kbTechGetStatus(cTechFactorySteamPower) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechFactorySteamPower);
            }
         }

         // Capitol upgrades (provided there is one)
         if (kbUnitCount(cMyID, cUnitTypeCapitol, cUnitStateAlive) > 0)
         {
            if (kbTechGetStatus(cTechImpExcessiveTaxation) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechImpExcessiveTaxation);
            }
            if (kbTechGetStatus(cTechImpLargeScaleAgriculture) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechImpLargeScaleAgriculture);
            }
            if (kbTechGetStatus(cTechImpDeforestation) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechImpDeforestation);
            }
            if (kbTechGetStatus(cTechImpPeerage) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechImpPeerage);
            }
            if (kbTechGetStatus(cTechImpImmigrants) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechImpImmigrants);
            }
            if (kbTechGetStatus(cTechImpKnighthood) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechImpKnighthood);
            }
            if (kbTechGetStatus(cTechImpLegendaryNatives) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechImpLegendaryNatives);
            }
         }

         // Fort upgrades (provided there is at least one)
         if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive) > 1)  
         {
            if (kbTechGetStatus(cTechRevetment) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechRevetment);
            }
            if (kbTechGetStatus(cTechStarFort) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechStarFort);
            }
         }

         // Agra fort upgrades (provided there is one)
         if ((kbUnitCount(cMyID, cUnitTypeypWIAgraFort2, cUnitStateAlive) > 0) ||
             (kbUnitCount(cMyID, cUnitTypeypWIAgraFort3, cUnitStateAlive) > 0) ||
             (kbUnitCount(cMyID, cUnitTypeypWIAgraFort4, cUnitStateAlive) > 0) ||
             (kbUnitCount(cMyID, cUnitTypeypWIAgraFort5, cUnitStateAlive) > 0))
         {
            if (kbTechGetStatus(cTechypFrontierAgra) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypFrontierAgra);
            }
            if (kbTechGetStatus(cTechypFortifiedAgra) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypFortifiedAgra);
            }
         }

         // Japanese - shrine upgrade (provided there are enough around)
         if (cMyCiv == cCivJapanese)
         {
            if ((kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine2, cUnitStateAlive) > 0) ||
                (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine3, cUnitStateAlive) > 0) ||
                (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine4, cUnitStateAlive) > 0) ||
                (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine5, cUnitStateAlive) > 0))
            {
               if ((kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) >= 10) &&
                   (kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable))
               {
                  addTechToForecasts(cTechypShrineFortressUpgrade);
               }
            }
            else if ((kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) >= 16) &&
                     (kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable))
            {
               addTechToForecasts(cTechypShrineFortressUpgrade);
            }
         }

         // Chinese - fourth village upgrade
         if (cMyCiv == cCivChinese)
         {
            if (kbTechGetStatus(cTechypVillagePopCapIncrease4) == cTechStatusObtainable)
            {
               addTechToForecasts(cTechypVillagePopCapIncrease4);
            }
         }

         // Dutch - 10 banks (including those made available by the coffee trade tech)
         if (cMyCiv == cCivDutch)
         {
            if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank))
               addItemToForecasts(cUnitTypeBank);

            xsArraySetInt(gForecasts, cResourceFood, 0 + xsArrayGetInt(gForecasts, cResourceFood));
            xsArraySetInt(gForecasts, cResourceWood, 0 + xsArrayGetInt(gForecasts, cResourceWood));
         }
		 
         if (cMyCiv == cCivBritish)
         {
            if (kbUnitCount(cMyID, cUnitTypeManor, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeManor))
               addItemToForecasts(cUnitTypeManor);
         }
         
         if (cMyCiv == cCivJapanese)
         {
            if (kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeypShrineJapanese))
               addItemToForecasts(cUnitTypeypShrineJapanese);
         }
         
         // Indians - 2 sacred fields
         if (cMyCiv == cCivIndians)
         {
            if (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateABQ) < 2)
               addItemToForecasts(cUnitTypeypSacredField, 2 - kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateABQ));
         } 

         if ((cMyCiv != cCivXPSioux) && (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) + 
               kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateABQ) ) < 12)
			   {
				addItemToForecasts(gBarracksUnit, 12);
				if (cMyCiv == cCivJapanese)
				{
				addItemToForecasts(cUnitTypeypBarracksJapanese, 12);
				}
			   }
         
         if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese))
        {
            if ( (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ) ) < 12)
			   {
				addItemToForecasts(gStableUnit, 12);
				if (cMyCiv == cCivJapanese)
				{
				addItemToForecasts(cUnitTypeypStableJapanese, 12);
				}
			   }
		}
		
         // 3 additional blockhouses for Russian (up to 7 in total)
         if (kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) < 7)
            addItemToForecasts(cUnitTypeBlockhouse, 7);

         // 12 additional war hut for Iroquois (up to 16 in total)
         if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < 16)
            addItemToForecasts(cUnitTypeWarHut, 16);

         // 9 additional war hut for Sioux (up to 13 in total)
         if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < 13)
            addItemToForecasts(cUnitTypeWarHut, 13);

         // 9 additional war hut for Aztecs (up to 13 in total)
         if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < 13)
            addItemToForecasts(cUnitTypeWarHut, 13);

         // 2 additional War Academy for Chinese (up to 6 in total)
         if (kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) < 6)
            addItemToForecasts(cUnitTypeypWarAcademy, 6);

         // 4 stables, corrals or caravanserais(not for Chinese and Dutch)
         if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese)) // && (cMyCiv != cCivDutch))
         {
            if ( (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) + 
                  kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ) ) < 4)
               addItemToForecasts(cUnitTypeStable, 4 - kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ));
         }

         // 2 artillery depots (not for Aztecs, Sioux or Asians)
         if ( (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux) && (civIsAsian() == false) ) 
         {
            if (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) < 2)
               addItemToForecasts(cUnitTypeArtilleryDepot, 2 - kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ));  
         }

         // 20 teepees for Sioux
         if (kbUnitCount(cMyID, cUnitTypeTeepee, cUnitStateABQ) < 20)
            addItemToForecasts(cUnitTypeTeepee, 20);

         // Two castles for Asians 
         if (civIsAsian() == true) 
         {
            if (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ) < 2)
               addItemToForecasts(cUnitTypeypCastle, 2 - kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ));  
         }

         // 7 additional castles for Chinese (up to 9 in total)
         if (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ) < 9)
            addItemToForecasts(cUnitTypeypCastle, 9 - kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ));  

         // One market
         if (kbUnitCount(cMyID, gMarketUnit, cUnitStateABQ) < 1)
            addItemToForecasts(gMarketUnit, 1);


         // One town center
            if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeTownCenter))
               addItemToForecasts(cUnitTypeTownCenter);
         
		 
         aiEcho("And the primary military unit is: "+kbUnitPickGetResult( gLandUnitPicker, 0));
		 
         if (gLandUnitPicker >= 0)
         {
      //kbEscrowFlush(cMilitaryEscrowID, cResourceWood, true);
      //kbEscrowFlush(cMilitaryEscrowID, cResourceGold, true);
      //kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
            militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 0);
            if (militaryUnit >= 0)
            {
               popSlots = kbGetPopSlots(cMyID, militaryUnit);
               if (popSlots < 1)
                   popSlots = 1;
               milQty = 60 / popSlots; 
               addItemToForecasts(militaryUnit, milQty);
            }          
            
            // Add 8 pop slots of secondary military unit
            if (kbUnitPickGetNumberResults(gLandUnitPicker) > 1)
            {
               militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 1);
               if (militaryUnit >= 0)
               {
                  popSlots = kbGetPopSlots(cMyID, militaryUnit);
                  if (popSlots < 1)
                      popSlots = 1;
                  milQty = 60 / popSlots; 
                  addItemToForecasts(militaryUnit, milQty);
               } 
            }
         }
		 
         break;
      }
   }
   spewForecasts();
   updatePrices();   // Set the aicost weights, buy/sell resources as needed.
}

/*
bool farmsWanted()
{  
   vector loc = cInvalidVector;
   bool timeToFarm = false;
   int numHuntableThere = 0;
   int numShrineThere = 0;
   int j = 0;
   int i = 0;

   static int huntableQuery = -1;
   huntableQuery = createSimpleQuery(0, cUnitTypeHuntable, cUnitStateAlive);
   kbUnitQueryResetResults(huntableQuery);
   int huntableCount = kbUnitQueryExecute(huntableQuery);
   int numStart = aiRandInt(huntableCount);
   int numRand = aiRandInt(huntableCount);
   int huntableID = -1;
   for (j=numStart; < numStart + huntableCount)
   {
      if (j >= huntableCount)
	i = j - huntableCount;
      else
	i = j;
      huntableID = kbUnitQueryGetResult(huntableQuery, i);
      loc = kbUnitGetPosition(huntableID);		
      numHuntableThere = getUnitCountByLocation(cUnitTypeHuntable, 0, cUnitStateAlive, loc, 300.0);
      
      if (numHuntableThere < 8)
	timeToFarm = true;
       break;	
   }        
   return(timeToFarm);
}
*/

void updateResources()
{
   const int cMinResourcePerGatherer = 100;   // When our supply gets below this level, start farming/plantations.
   int mainBaseID = kbBaseGetMainID(cMyID);
   if (mainBaseID < 0)
      return;
   vector loc = kbBaseGetLocation(cMyID, mainBaseID);
   
   if (xsGetTime() > 5*1000)
   {
      int foodAmount = kbGetAmountValidResources(mainBaseID, cResourceFood , cAIResourceSubTypeEasy, 200.0);
      if ( (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) )
      {  foodAmount = foodAmount + kbGetAmountValidResources( mainBaseID, cResourceFood , cAIResourceSubTypeHunt, 200.0);  }
      //if ( (kbGetCiv() != cCivIndians) && (kbGetCiv() != cCivSPCIndians) && (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) 
      //{  foodAmount = foodAmount + kbGetAmountValidResources( mainBaseID, cResourceFood , cAIResourceSubTypeHerdable, 60.0);  }       
     
      // Subtract mills at 999 each.
      foodAmount = foodAmount - (getUnitCountByLocation(gFarmUnit, cMyID, cUnitStateAlive, loc, 60.0) * 999);
      float percentOnFood = aiGetResourceGathererPercentage( cResourceFood, cRGPActual );
      int numFoodGatherers =  percentOnFood * kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
      if (numFoodGatherers < 1)
         numFoodGatherers = 1;
      int foodPerGatherer = foodAmount / numFoodGatherers;
      
      int woodAmount = kbGetAmountValidResources( mainBaseID, cResourceWood , cAIResourceSubTypeEasy, 600.0);
      float percentOnWood = aiGetResourceGathererPercentage( cResourceWood, cRGPActual );
      int numWoodGatherers =  percentOnWood * kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
      if (numWoodGatherers < 1)
         numWoodGatherers = 1;
      int woodPerGatherer = woodAmount / numWoodGatherers;
      
      int goldAmount = kbGetAmountValidResources( mainBaseID, cResourceGold , cAIResourceSubTypeEasy, 200.0);
      // Subtract plantations at 999 each.
      goldAmount = goldAmount - (getUnitCountByLocation(gPlantationUnit, cMyID, cUnitStateAlive, loc, 60.0) * 999);
      float percentOnGold = aiGetResourceGathererPercentage( cResourceGold, cRGPActual );
      int numGoldGatherers =  percentOnGold * kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
      if (numGoldGatherers < 1)
         numGoldGatherers = 1;
      int goldPerGatherer = goldAmount / numGoldGatherers;
      
      aiEcho("Resources:Food "+foodAmount+", Wood "+woodAmount+", Gold "+goldAmount);
      aiEcho("Per gatherer:Food "+foodPerGatherer+", Wood "+woodPerGatherer+", Gold "+goldPerGatherer);
      
      if ( (foodAmount < 8.0) && (gTimeToFarm == false) && (foodPerGatherer < cMinResourcePerGatherer) )
      {
         aiEcho("**** It's time to start farming! ****");
         gTimeToFarm = true;
      }
	  
    if (xsGetTime() < 15*60*1000)
	{
		gTimeForPlantations = true;
        gTimeToFarm = true;
    }     
     
      if ( (goldAmount < 1.0) && (gTimeForPlantations == false) && (goldPerGatherer < cMinResourcePerGatherer) )
      {
         aiEcho("**** It's time to start using plantations! ****");
         gTimeForPlantations = true;
      }      
   }
}


//==============================================================================
/*
   econMaster(int mode, int value)

   Performs top-level economic analysis and direction.   Generally called
   by the econMasterRule, it can be called directly for special-event processing.
   EconMasterRule calls it with default parameters, directing it to do a full
   reanalysis.  
*/
//==============================================================================
void econMaster(int mode=-1, int value=-1)
{
   // Monitor main base supply of food and gold, activate farming and plantations when resources run low
   updateResources();
 
   // Maintain list of possible future econ bases, prioritize them
   updateEconSiteList();

   // Evaluate active base status...are all bases still usable?  Adjust if not.
   evaluateBases();

   // Update forecasts for economic and military expenses.  Set resource
   // exchange rates.
   updateForecasts();      

   // Set desired gatherer ratios.  Spread them out per base, set per-base 
   // resource breakdowns.
   updateGatherers();
   
   // Update our settler maintain targets, based on age, personality.
   updateSettlerCounts();
   
   // Maintain escrow balance based on age, personality, actual vs. desired settler pop.
   updateEscrows();
}

//==============================================================================
// rule econMasterRule
/*
   This rule calls the econMaster() function on a regular basis.  The 
   function is separate so that it may be called with a parameter for 
   unscheduled processing based on unexpected events.  
*/
//==============================================================================
rule econMasterRule
inactive
group startup
minInterval 30
{
   econMaster();
}

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Military
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================

rule delayWalls
inactive
minInterval 20
{
   int i=0;
   
   while(i<3)
   {           
      int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
      if (wallPlanID != -1)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive)));
         //aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 80.0+20*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 20+20*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
         i++;
       }       
      xsDisableSelf();
   }    
}
/*

rule delayWallsMonitor
inactive
minInterval 30
{
         xsEnableRule("delayWalls1");  
         xsEnableRule("delayWalls2");
         xsEnableRule("delayWalls3");
         xsEnableRule("delayWalls4");
         xsEnableRule("delayWalls5");
         xsEnableRule("delayWalls6");
         xsEnableRule("delayWalls7");   
}


rule delayWalls
inactive
minInterval 30

{         
      int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
	  //float currentWood=kbResourceGet(cResourceWood);     
      if (wallPlanID != -1) // && (currentWood >= 4000))
	{

	  	if  (kbGetAge() == cAge5)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 120);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 12);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }
	  	  if  (kbGetAge() == cAge5)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 100);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 10);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }    
	   
	  	  if  (kbGetAge() == cAge5)          
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 80);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 8);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }       
	   
	  	  if  (kbGetAge() == cAge5)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 60);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 6);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }
	   
	  	  if  (kbGetAge() == cAge5)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeBuildingsThatShoot, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 26);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 2);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }
	   
	  	  if  (kbGetAge() == cAge5)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypePlantation, cMyID, cUnitStateAlive)));
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeFarm, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 20);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 2);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
         //i++;
        }
    }       
    
}       


rule delayWalls1
inactive
minInterval 30
{
   int i=0;
   
   while(i<3)
   {           
      int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
      if (wallPlanID != -1)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 120);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 12);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps1");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }
      xsDisableSelf();
   }    
}

rule delayWalls2
inactive
minInterval 30
{
   int i=0;
   
   while(i<3)
   {           
      int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
      if (wallPlanID != -1)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 100);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 10);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps2");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }    
      xsDisableSelf();
   }    
}

rule delayWalls3
inactive
minInterval 30
{
   int i=0;
   
   while(i<3)
   {           
      int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
      if (wallPlanID != -1)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 80);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 8);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps3");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }     
      xsDisableSelf();
   }    
}

rule delayWalls4
inactive
minInterval 30
{
   int i=0;
   
   while(i<3)
   {           
      int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
      if (wallPlanID != -1)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 60);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 6);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps4");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }
      xsDisableSelf();
   }    
}

rule delayWalls5
inactive
minInterval 30
{
   int i=0;
   
   while(i<3)
   {           
      int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
      if (wallPlanID != -1)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeBuildingsThatShoot, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 26);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 2);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps5");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }
      xsDisableSelf();
   }    
}

rule delayWalls6
inactive
minInterval 30
{
   int i=0;
   
   while(i<3)
   {           
      int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
      if (wallPlanID != -1)
        {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypePlantation, cMyID, cUnitStateAlive)));
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(gFarmUnit, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 20);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 2);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps6");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
        }
      xsDisableSelf();
   }    
}

rule delayWalls7
inactive
minInterval 30
{
   int i=0;
   
   while(i<3)
   {           
      int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
      if (wallPlanID != -1)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 40);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 4);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID, 80);
         aiPlanSetActive(wallPlanID, true);
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn, kbUnitGetPosition(getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive)));
         //Enable our wall gap rule, too.
         xsEnableRule("fillInWallGaps5");
         aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
       }       
      xsDisableSelf();
   }    
}
*/

rule turtleUp
inactive
group tcComplete
minInterval 23
{
   if ((kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive) + 5* kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) + .5 * kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive)) < 60)
      return;
   
   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
      return;
   
   // If it hasn't been defined elsewhere, set defaults
   if (civIsAsian() == false)
   {
      if (aiGetGameMode() == cGameModeDeathmatch)
        gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
      else
        gNumTowers = ( (btOffenseDefense * -1.0) + 0.5 ) * 5.25; // 7 for extreme turtler, 2 for balanced.
      if (gNumTowers < 0)
         gNumTowers = 0.0;
      if (kbGetCivForPlayer(cMyID) == cCivXPAztec)
         gNumTowers = gNumTowers / 2;
   }
   else
   {
      if (aiGetGameMode() == cGameModeDeathmatch)
        gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
      else
        gNumTowers = ( (btOffenseDefense * -1.0) + 0.7 ) * 3.0; // 5 for extreme turtler, 2 for balanced.
      if (gNumTowers < 0)
         gNumTowers = 0.0;
   }   

   if (cvOkToFortify == false)
      gNumTowers = 0.0;
   
   aiEcho("Planning on making "+gNumTowers+" towers.");

   //xsEnableRule("towerUpgradeMonitor");
   //xsEnableRule("aztecNoblesHutUpgradeMonitor");
      
   xsDisableSelf();
}

rule decideToBuildWall
inactive
group tcComplete
minInterval 30
{

	  //float currentWood = kbResourceGet(cResourceWood);     
	  	  //if  ((kbGetAge() == cAge5) && (xsGetTime() > 35*60*1000))//(currentWood >= 4000))
	  	  if (xsGetTime() > 35*60*1000)
		  {
		  gBuildWalls = true;          
         xsEnableRule("delayWalls");   
         xsEnableRule("upgradeWallConnector");
          //xsEnableRule("delayWallsMonitor");   
          //xsEnableRule("upgradeWallConnector");
		  }
}
		  
/*		  
   // if all of my teammates have left the game.
   int activeEnemies=0;
   int activeTeammates=0;
   int deadTeammates=0;
   int player = 1;
   for (player=0; < cNumberPlayers)
   {
       if (player == cMyID)                    
         continue;
        
       if (kbIsPlayerAlly(player) == false)
       {
          //Increment the active number of enemies there currently are.
          if (kbIsPlayerResigned(player) == false)
          {
             activeEnemies=activeEnemies+1;                
          }
            continue;
       }
     
       //If I still have an active teammate, don't resign.
       if (kbIsPlayerResigned(player) == true)
         deadTeammates=deadTeammates+1;
       else
         activeTeammates=activeTeammates+1;
   }
  
   int armySize = aiPlanGetNumberUnits(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary) + aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
   int enemyArmySize = -1;      
   bool emergency = false;
   static int enemyArmyQuery = -1;
   if (enemyArmyQuery < 0)
   {  // Initialize the queryID
      enemyArmyQuery = kbUnitQueryCreate("Enemy army query");
      kbUnitQuerySetIgnoreKnockedOutUnits(enemyArmyQuery, true);
      kbUnitQuerySetPlayerRelation(enemyArmyQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetUnitType(enemyArmyQuery, cUnitTypeLogicalTypeLandMilitary);
      kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
      kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);   // Ignore units we think are under fog
   }
   
   // Check main base first
   kbUnitQuerySetPosition(enemyArmyQuery,  kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
   kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius);   
   kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
   kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
   kbUnitQueryResetResults(enemyArmyQuery);
   enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
      
   // if at least one player from my team has left the game and I am the only player left on my team, 
   // and the other team(s) have 1 or more players in the game, it's time to start wall
   if ( (enemyArmySize >= 2) && ((activeEnemies >= 1) || (activeTeammates <= 1) || (deadTeammates > 0)) ) 
   {  
      // Enemy army size at least 2x my size and more than 20 units total. Thus, we do wall
      if ( ((armySize * 2.0) < enemyArmySize) && (enemyArmySize >= 20) && (cvOkToBuildWalls == true) && (civIsEuropean() == true) && (mapPreventsWalls() == false))
      {     
         gBuildWalls = true;          
         xsEnableRule("delayWalls");   
         xsEnableRule("upgradeWallConnector");  
      }                     
   }
}
*/


/* setUnitPickerPreference()

   Updates the unit picker biases, arbitrates between the potentially conflicting sources.  

   Priority order is:

      1)  If control is from a trigger, that wins.  The unit line specified in gCommandUnitLine gets a +.8, all others +.2
      2)  If control is ally command, ditto.  (Can only be one unit due to UI limits.
      3)  If we're not under command, but cvPrimaryArmyUnit (and optionally cvSecondaryArmyUnit, cvTertiaryArmy Unit) are set, they rule.
               If just primary, it gets 0.8, with 0.2 for other classes.  
               If primary and secondary, they get 1.0 and 0.5, others get 0.0.
               If primary, secondary and tertiary, they get 0.8, 0.4 and 0.2, others get 0.0.
      4)  If enough enemy units have been spotted, bias towards appropriate counters
      5)  If not under command, no cv's are set, and no units have been spotted, we go with the btBiasCav, btBiasInf and btBiasArt line settings.  


*/
void setUnitPickerPreference(int upID = -1)
{ 
   // Add the main unit lines
   if (upID < 0)
      return;
   
   // Check for commanded unit preferences.
   if ( (gUnitPickSource == cOpportunitySourceTrigger) || (gUnitPickSource == cOpportunitySourceAllyRequest) )
   {  // We have an ally or trigger command, so bias everything for that one unit
      if (cvPrimaryArmyUnit < 0)
         return;     // This should never happen, it should be set when the unitPickSource is set.
      
      kbUnitPickResetAll(gLandUnitPicker);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 1.0);   // Range 0.0 to 1.0
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 1.0 );
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 1.0);
      //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCoureur, 0.0);    // Avoid coureurs, they mess up econ/mil calcs.
      if (cMyCiv == cCivXPAztec)
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightInfantry, 1.0);

      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarrior, 0.0);    // Never pick xpWarrior or xpDogSoldier, available via dance only
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpDogSoldier, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMedicineManAztec, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSkullKnight, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSpy, 0.0);

      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpRam, 0.0);   // Avoid units the AI cannot handle properly
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpPetard, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMortar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMorutaru, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSpy, 0.0);

      return;
   }
   
   // Check for cv settings
   if ( cvPrimaryArmyUnit >= 0 )
   {
      kbUnitPickResetAll(gLandUnitPicker);
      
      // See if 1, 2, or 3 lines set.  If 1, score 0.8 vs. 0.2.  If 2, score 1.0, 0.5 and 0.0.  If 3, score 0.8, 0.4 and 0.2.
      if (cvSecondaryArmyUnit < 0)  // Only one line selected
      {
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 1.0);   // Range 0.0 to 1.0
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 1.0 );
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 1.0);
         //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
         if (cMyCiv == cCivXPAztec)
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightInfantry, 1.0);

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCoureur, 0.0);    // Avoid coureurs, they mess up econ/mil calcs.

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarrior, 0.0);    // Never pick xpWarrior or xpDogSoldier, available via dance only
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpDogSoldier, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMedicineManAztec, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSkullKnight, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSpy, 0.0);

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpRam, 0.0);   // Avoid units the AI cannot handle properly
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpPetard, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMortar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMorutaru, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSpy, 0.0);

         if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) )    // Avoid Ninja or Ronin or Daimyos or Shogun
         {
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateNinja, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateRonin, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypDaimyoMasamune, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypDaimyoKiyomasa, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypDaimyoMototada, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypShogunTokugawa, 0.0);
         }

         if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )    // Avoid mansabdar units
         {
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNatMercGurkhaJemadar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypRajputMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSepoyMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypZamburakMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSowarMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdahMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahoutMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSiegeElephantMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphantMansabdar, 0.0);
         }

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvPrimaryArmyUnit, 0.8);
      }
      else if (cvTertiaryArmyUnit < 0)  // Two lines selected
      {
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 1.0);   // Range 0.0 to 1.0
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 1.0 );
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 1.0);
         //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
         if (cMyCiv == cCivXPAztec)
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightInfantry, 1.0);

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCoureur, 0.0);    // Avoid coureurs, they mess up econ/mil calcs.  

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarrior, 0.0);    // Never pick xpWarrior or xpDogSoldier, available via dance only
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpDogSoldier, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMedicineManAztec, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSkullKnight, 0.0);

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpRam, 0.0);   // Avoid units the AI cannot handle properly
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpPetard, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMortar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMorutaru, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSpy, 0.0);

         if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) )    // Avoid Ninja or Ronin or Daimyos or Shogun
         {
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateNinja, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateRonin, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypDaimyoMasamune, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypDaimyoKiyomasa, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypDaimyoMototada, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypShogunTokugawa, 0.0);
         }

         if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )    // Avoid mansabdar units
         {
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNatMercGurkhaJemadar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypRajputMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSepoyMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypZamburakMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSowarMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdahMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahoutMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSiegeElephantMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphantMansabdar, 0.0);
         }

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvPrimaryArmyUnit, 1.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvSecondaryArmyUnit, 1.0);         
      }
      else  // Three lines selected
      {
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 1.0);   // Range 0.0 to 1.0
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 1.0 );
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 1.0);
         //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
         if (cMyCiv == cCivXPAztec)
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightInfantry, 1.0);

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCoureur, 0.0);    // Avoid coureurs, they mess up econ/mil calcs.  

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarrior, 0.0);    // Never pick xpWarrior or xpDogSoldier, available via dance only
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpDogSoldier, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMedicineManAztec, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSkullKnight, 0.0);

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpRam, 0.0);   // Avoid units the AI cannot handle properly
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpPetard, 0.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMortar, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMorutaru, 0.0);
      kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSpy, 0.0);

         if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) )    // Avoid Ninja or Ronin or Daimyos or Shogun
         {
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateNinja, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateRonin, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypDaimyoMasamune, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypDaimyoKiyomasa, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypDaimyoMototada, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypShogunTokugawa, 0.0);
         }

         if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )    // Avoid mansabdar units
         {
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNatMercGurkhaJemadar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypRajputMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSepoyMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypZamburakMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSowarMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdahMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahoutMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSiegeElephantMansabdar, 0.0);
            kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphantMansabdar, 0.0);
         }

         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvPrimaryArmyUnit, 1.0);
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvSecondaryArmyUnit, 1.0);         
         kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvTertiaryArmyUnit, 1.0);         
      }
      return;
   }    

   //======================== Set a new unit Preference Factor ========================//
   // Check  for units to counter
   static bool counterUnitMode = false;
   int unitPreferenceRandomizer = aiRandInt(10); // 0-9
   
   float enemyToCounter = aiGetMostHatedPlayerID();
   
   float lightInfantryCount = kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) +
                              kbUnitCount(enemyToCounter, cUnitTypeAbstractLightCavalry, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
							  
   float heavyCavalryCount =  kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive)+ 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive)   +
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractSiegeTrooper, cUnitStateAlive);  
							  
   float heavyInfantryCount = kbUnitCount(enemyToCounter, cUnitTypeAbstractCavalry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
   
   float lightCavalryCount =  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) + 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractSiegeTrooper, cUnitStateAlive); 
							  
   float artilleryCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
   
   float coreUnitCount = 	  kbUnitCount(enemyToCounter, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
   
   float totalEnemyCount =    lightInfantryCount + heavyCavalryCount + heavyInfantryCount + lightCavalryCount + artilleryCount; /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
   
   float MahoutCount =  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive)+ 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive)   +
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractSiegeTrooper, cUnitStateAlive);  
							  
   float HowdahCount =  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive)+ 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractSiegeTrooper, cUnitStateAlive); 
							  
   float LancerCount =  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive) +//kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) + 
							  //kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) +
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive)   +
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractSiegeTrooper, cUnitStateAlive)
							  
   float SiegeTrooperCount =  kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
   
   float AbusGunCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
							  
   
   float JanissaryCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractCavalry, cUnitStateAlive);
							  
   float OttoHussarCount =    kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive)+ 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive)   +
                              //kbUnitCount(enemyToCounter, cUnitTypeAbstractSiegeTrooper, cUnitStateAlive) +
							  
   float CuirassierCount =    kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeWarWagon, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeDopplesoldner, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeypKensei, cUnitStateAlive) - 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHowdah, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractCavalry, cUnitStateAlive)+ 
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractLancer, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
   
   float SamuraiCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHandInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) -
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */ 
							  
   float EspadaCount = 	  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractCavalry, cUnitStateAlive) -
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
							  
   float JaguarKnightCount =  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
							  
   float RifleRiderCount = 	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
   
   float TercioCount = 	  	  kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) -
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractRangedInfantry, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeCuirassier, cUnitStateAlive); /* +
							  kbUnitCount(enemyToCounter, cUnitTypeAbstractVillager, cUnitStateAlive) +
							  kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive); */
   
   float ArrowKnightCount =   kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive); //  + kbUnitCount(enemyToCounter, cUnitTypeBuilding, cUnitStateAlive);
   
   if (totalEnemyCount > 10)
   {  
      counterUnitMode = true;
      /* We see one of this player's units for the first time...let's do some analysis on it

         Setup the military unit preferences.  These are just various strategies of unit
         combos and what-not that are more or less setup to coincide with the bonuses
         and mainline units of each civ.  We start with a random choice.  If we have
         an enemy unit type to preference against, we override that random choice.
          
         0:  Counter infantry (i.e. enemyToCounter == cUnitTypeAbstractInfantry).
         1:  Counter artillery (i.e. enemyToCounter == cUnitTypeAbstractArtillery).
         2:  Counter cavalry (i.e. enemyToCounter == cUnitTypeAbstractCavalry).
      */
      
      // Calculate enemy's basic unit ratio and favor appropriate counters
      float lightInfantryFactor = lightInfantryCount * 2 / totalEnemyCount;
      float heavyInfantryFactor = heavyInfantryCount * 2 / totalEnemyCount;
      float lightCavalryFactor = lightCavalryCount * 2 / totalEnemyCount;
      float heavyCavalryFactor = heavyCavalryCount * 2 / totalEnemyCount;
      float artilleryFactor = artilleryCount * 1 / totalEnemyCount;
      float coreUnitFactor = coreUnitCount * 2 / totalEnemyCount;
      float MahoutFactor = MahoutCount * 2 / totalEnemyCount;
      float HowdahFactor = HowdahCount * 2 / totalEnemyCount;
      float LancerFactor = LancerCount * 2 / totalEnemyCount;
      float SiegeTrooperFactor = SiegeTrooperCount * 2 / totalEnemyCount;
      float AbusGunFactor = AbusGunCount * 2 / totalEnemyCount;
      float JanissaryFactor = JanissaryCount * 2 / totalEnemyCount;
      float SamuraiFactor = SamuraiCount * 2 / totalEnemyCount;
      float RifleRiderFactor = RifleRiderCount * 2 / totalEnemyCount;
      float TercioFactor = TercioCount * 2 / totalEnemyCount;
      float ArrowKnightFactor = ArrowKnightCount * 2 / totalEnemyCount;
      float OttoHussarFactor = OttoHussarCount * 2 / totalEnemyCount;
      float JaguarKnightFactor = JaguarKnightCount * 2 / totalEnemyCount;
      float EspadaFactor = EspadaCount * 2 / totalEnemyCount;
      float CuirassierFactor = CuirassierCount * 4 / totalEnemyCount;
          
      if ( ((lightInfantryFactor > 0.0) || (heavyInfantryFactor > 0.0)) && (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) > 2) )
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmInf);
      if ( ((lightCavalryFactor > 0.0) || (heavyCavalryFactor > 0.0)) && (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 2) )
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmCav); 
      if ( ((kbGetCivForPlayer(cMyID) == cCivFrench) && (coreUnitFactor > 0.0) && (kbGetAge() > cAge2)) )
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmCav);
      if ( (artilleryFactor > 0.0) && (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) > 5) )
         sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirmArt); 

      switch(kbGetCiv())
      { 
	  
          case cCivXPIroquois:
          {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpTomahawk, heavyInfantryFactor);    
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpHorseman, heavyCavalryFactor); 
			 
             if (kbGetAge() < cAge3)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpAenna, lightInfantryFactor);
			 }        
			 
             if (kbGetAge() > cAge2)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMusketWarrior, lightInfantryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMusketRider, lightCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMantlet, SiegeTrooperFactor);   
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpHorseman, heavyCavalryFactor);   
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			 if ((kbGetAge() > cAge4) && (kbResourceGet(cResourceGold) > 4000))
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);  
			 }
			 }
			 
			 
             break;
          }
		  
          case cCivXPSioux:
          {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpAxeRider, OttoHussarFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpBowRider, lightCavalryFactor);  
			 //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarRifle, lightInfantryFactor);
		  
             if (kbGetAge() < cAge3)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpBowRider, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpBowRider, lightInfantryFactor);    
			 }
			 
             /*if (kbGetAge() == cAge3) // && (kbCanAffordUnit(cUnitTypexpRifleRider, cEconomyEscrowID) == true))
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			 
				if (kbCanAffordUnit(cUnitTypexpRifleRider, cEconomyEscrowID) == true)
				{
				kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpRifleRider, RifleRiderFactor);
				}
				else
				{
				//kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarBow, lightInfantryFactor);  
				kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarRifle, lightInfantryFactor);
				kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpBowRider, heavyInfantryFactor);
				}
			 }*/
			 
             if (kbGetAge() > cAge2)  
			{
			//kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpRifleRider, RifleRiderFactor);
			}
             
             break;
          }
		  
          case cCivXPAztec:
          {                                      
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpCoyoteMan, heavyCavalryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMacehualtin, lightInfantryFactor);
			 
             if (kbGetAge() < cAge4)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpPumaMan, heavyInfantryFactor);  
			 }
			 
             if (kbGetAge() > cAge2)
			 {
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpJaguarKnight, JaguarKnightFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpEagleKnight, lightCavalryFactor);  
			 }
			 
             break;
          }
		  
          case cCivChinese:
          {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypOldHanArmy, lightInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypOldHanArmy, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypImperialArmy, AbusGunFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypImperialArmy, LancerFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypForbiddenArmy, heavyCavalryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypTerritorialArmy, TercioFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypTerritorialArmy, SiegeTrooperFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypStandardArmy, lightInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypStandardArmy, MahoutFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMingArmy, SamuraiFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMingArmy, lightCavalryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypBlackFlagArmy, lightInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypBlackFlagArmy, artilleryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMongolianArmy, lightCavalryFactor);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypFlameThrower, SiegeTrooperFactor);    

             if (kbGetAge() > cAge2)
			 {
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			 }
			 
             break;
          }
		  
          case cCivJapanese:
          {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypAshigaru, heavyInfantryFactor);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypYumi, lightInfantryFactor);    
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNaginataRider, heavyCavalryFactor);   
			 
             if (kbGetAge() > cAge2)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypKensei, SamuraiFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNaginataRider, heavyCavalryFactor); 
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypYabusame, lightCavalryFactor); 
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractDaimyo, coreUnitFactor); 
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			 if ((kbGetAge() > cAge4) && (kbResourceGet(cResourceGold) > 4000))
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor); 
			 } 
			 }       
			 
             break;
          }
		  
          case cCivIndians:
          {                
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractSowar, heavyCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractZamburak, lightCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractGurkha, lightInfantryFactor);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractSepoy, heavyInfantryFactor);
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractRajput, SamuraiFactor);     
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractMansabdar, coreUnitFactor);     
			 
             if (kbGetAge() > cAge2)
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractMahout, MahoutFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractHowdah, HowdahFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypUrumi, lightInfantryFactor);  
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			 }       
			 
             break;
          }
		  
          case cCivBritish:
          { 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);                  
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeLongbowman, lightInfantryFactor); 
			 
             if (kbGetAge() > cAge2)
			 {             
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor); 
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			 }
			 
			 if ((kbGetAge() > cAge4) && (kbResourceGet(cResourceGold) > 4000))
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);  
			 }
			       
			 
             break;
          }
          case cCivFrench:
          {
             if (kbGetAge() < cAge3)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCrossbowman, lightInfantryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, lightInfantryFactor);   
			 }
			 
			 
             if (kbGetAge() < cAge5)
			 {             
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor); 
			 }
			 
             if ((kbGetAge() > cAge2) &&  (kbGetAge() < cAge5))
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor);    
			 }
			 
             if (kbGetAge() > cAge2)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCuirassier, CuirassierFactor);   
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSkirmisher, lightInfantryFactor);
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			 if ((kbGetAge() > cAge4) && (kbResourceGet(cResourceGold) > 4000))
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor); 
			 } 
			 }
			 
             break;
           }
		   
           case cCivDutch:
           {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSkirmisher, lightInfantryFactor);
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, OttoHussarFactor);
			 
			 if (kbGetAge() < cAge3)
			 {                           
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, OttoHussarFactor);
			 }

			 if (kbGetAge() > cAge2)
			 {                
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor); 
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);   
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeFalconet, artilleryFactor);  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeRuyter, lightCavalryFactor);
			 //if ((kbGetAge() > cAge4) && (kbResourceGet(cResourceGold) > 4000))
			 //{
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor); 
			 //}
			 }
			 
             break;   
           }
		   
           case cCivSpanish:
           {
             if (kbGetAge() < cAge3)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, lightInfantryFactor);  
			 }
			 
             if (kbGetAge() < cAge4)
			 {  
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCrossbowman, lightInfantryFactor); 
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, lightInfantryFactor);   
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypePikeman, TercioFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeRodelero, EspadaFactor);  
			 }
			 
             if (kbGetAge() > cAge3)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSkirmisher, lightInfantryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor);  
			 }
			 
             if (kbGetAge() > cAge2)
			 {  
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSkirmisher, lightInfantryFactor); 
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor);
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			 kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeLancer, LancerFactor);
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor);  
			 if ((kbGetAge() > cAge4) && (kbResourceGet(cResourceGold) > 4000))
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);  
			 }   
			 }
			 
              break;
           }
		   
           case cCivGermans:
           {         
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeUhlan, OttoHussarFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDopplesoldner, SamuraiFactor);  
			 
             if (kbGetAge() < cAge3)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCrossbowman, lightInfantryFactor);     
			 }
			 
             if (kbGetAge() > cAge2)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSkirmisher, lightInfantryFactor); 
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeWarWagon, lightCavalryFactor); 
			 if ((kbGetAge() > cAge4) && (kbResourceGet(cResourceGold) > 4000))
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);  
			 }  
			 }
			 
             break;
           }
		   
           case cCivRussians:
           {
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCossack, OttoHussarFactor);                
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor);
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeStrelet, lightInfantryFactor);   
			 
             if (kbGetAge() > cAge2)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCossack, OttoHussarFactor); 
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			 if ((kbGetAge() > cAge4) && (kbResourceGet(cResourceGold) > 4000))
			 {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);  
			 } 
			 }
			 
             break;
           }
		   
           case cCivPortuguese:
           {
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, heavyInfantryFactor);     
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, heavyCavalryFactor);  
			 
             if (kbGetAge() < cAge3)
			 {  
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCrossbowman, lightInfantryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMusketeer, lightInfantryFactor);      
			 }
			 
             if (kbGetAge() > cAge2)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCacadore, lightInfantryFactor);          
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeDragoon, lightCavalryFactor);        
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeOrganGun, artilleryFactor); 
			 //if ((kbGetAge() > cAge4) && (kbResourceGet(cResourceGold) > 4000))
			 //{
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);  
			 //}
			 }
			 
             break;                
           }
		   
           case cCivOttomans:
           {
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbusGun, AbusGunFactor);      
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeJanissary, JanissaryFactor); 
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHussar, OttoHussarFactor);  
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);    
			 //if ((kbGetAge() > cAge4) && (kbResourceGet(cResourceGold) > 4000))
			 //{
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, gAbstractArtilleryUnit, artilleryFactor);  
			 //}     
             if (kbGetAge() > cAge2)
			 {  
             kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbusGun, AbusGunFactor);   
             //kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5);
			 }
             break;        
			 
           }  
       } 
       return;     
    }

    if (counterUnitMode == false)
    {   
       // No commands active. Go with our default biases...
       setStandardArmyPreference();
       //if (civIsAsian() == true)
       //{ 
          // Set preferences for consulate units
          setConsulateArmyPreference();
       //}      
   }
}




//==============================================================================
// initUnitPicker
//==============================================================================
int initUnitPicker(string name="BUG", int numberTypes=1, int minUnits=10,
   int maxUnits=20, int minPop=-1, int maxPop=-1, int numberBuildings=1,
   bool guessEnemyUnitType=false)
{   
   //Create it.
   int upID=kbUnitPickCreate(name);
   if (upID < 0)
      return(-1);

   //Default init.
   kbUnitPickResetAll(upID);

   kbUnitPickSetPreferenceWeight(upID, 1.0);
   if (gSPC == false)
      kbUnitPickSetCombatEfficiencyWeight(upID, 2.0);    // Changed from 1.0 to dilute the power of the preference weight.
   else
      kbUnitPickSetCombatEfficiencyWeight(upID, 1.0);    // Leave it at 1.0 to avoid messing up SPC balance
      
   kbUnitPickSetCostWeight(upID, 0.0);
   //Desired number units types, buildings.
   kbUnitPickSetDesiredNumberUnitTypes(upID, numberTypes, numberBuildings, true);
   //Min/Max units and Min/Max pop.
   kbUnitPickSetMinimumNumberUnits(upID, minUnits);   // Sets "need" level on attack plans
   kbUnitPickSetMaximumNumberUnits(upID, maxUnits);   // Sets "max" level on attack plans, sets "numberToMaintain" on train plans for primary unit,
                                                      // half that for secondary, 1/4 for tertiary, etc.
   kbUnitPickSetMinimumPop(upID, minPop); // Not sure what this does...
   kbUnitPickSetMaximumPop(upID, maxPop); // If set, overrides maxNumberUnits for how many of the primary unit to maintain.
   
   //Default to land units.
   kbUnitPickSetEnemyPlayerID(upID, aiGetMostHatedPlayerID());
   kbUnitPickSetAttackUnitType(upID, cUnitTypeLogicalTypeLandMilitary);
   kbUnitPickSetGoalCombatEfficiencyType(upID, cUnitTypeLogicalTypeLandMilitary);

   // Set the default target types and weights, for use until we've seen enough actual units.
   //kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeLogicalTypeLandMilitary, 1.0);
   kbUnitPickAddCombatEfficiencyType(upID, gEconUnit, 0.2);   // We need to build units that can kill settlers efficiently.
   kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeHussar, 0.2);    // Major component
   kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeMusketeer, 0.4); // Bigger component  
   kbUnitPickAddCombatEfficiencyType(upID, cUnitTypePikeman, 0.1);   // Minor component
   //kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeCrossbowman, 0.1);   // Minor component    
  
   xsEnableRule("siegeWeaponMonitor");
   //Done.
   return(upID);
}

int getMatchTarget()    // Find an enemy player buildingID to attack.
{
   int count = 0;
   int retVal = -1;
   static int unitQueryID = -1;

   //If we don't have the query yet, create one.
   if (unitQueryID < 0)
   {
      unitQueryID=kbUnitQueryCreate("navy target count");
      kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
      kbUnitQuerySetPlayerRelation(unitQueryID, cPlayerRelationEnemyNotGaia);
   }     
   kbUnitQuerySetUnitType(unitQueryID, cUnitTypeBuilding);
   kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
   kbUnitQueryResetResults(unitQueryID);
   count = kbUnitQueryExecute(unitQueryID); 
   //aiEcho("Enemy building: "+ count);
   if (count > 0)
   {
      retVal = kbUnitGetPlayerID(kbUnitQueryGetResult(unitQueryID,0));
   }
   
   return(retVal);
}


//==============================================================================
/*
   siegeWeaponMonitor
   
   make and update maintain plans for Siege Weapon

*/
//==============================================================================
rule siegeWeaponMonitor
inactive
minInterval 15
{
   if (aiTreatyActive() == true)
   {
      aiEcho("delayed because treaty is active.");
      return;
   }

   static int mortarPlan = -1;    
   static int ypHandMortarPlan = -1;
   static int ypMorutaruPlan = -1;
   static int ypSiegeElephantPlan = -1;
   static int xpRamPlan = -1;   
    
   if (civIsNative() == true)
   {     
      if (xpRamPlan < 0)
      {  xpRamPlan = createSimpleMaintainPlan(cUnitTypexpRam, 2, true, kbBaseGetMainID(cMyID), 2);  }
      else
      {  aiPlanSetVariableInt(xpRamPlan, cTrainPlanNumberToMaintain, 0, 2); }
   }
   if (civIsEuropean() == true)
   {
      if (mortarPlan < 0)
      {  mortarPlan = createSimpleMaintainPlan(cUnitTypeMortar, 2, true, kbBaseGetMainID(cMyID), 2);  }
      else
      {  aiPlanSetVariableInt(mortarPlan, cTrainPlanNumberToMaintain, 0, 2); }
   }
   if (civIsAsian() == true)
   {
      if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
      {
         if (ypHandMortarPlan < 0)
         {  ypHandMortarPlan = createSimpleMaintainPlan(cUnitTypeypHandMortar, 5, true, kbBaseGetMainID(cMyID), 5);  }
         else
         {  aiPlanSetVariableInt(ypHandMortarPlan, cTrainPlanNumberToMaintain, 0, 5); }
      }
      if (((kbGetCiv() == cCivSPCJapanese)||(kbGetCiv() == cCivJapanese)||(kbGetCiv() == cCivSPCJapaneseEnemy)))
      {  
         if (ypMorutaruPlan < 0)
         {  ypMorutaruPlan = createSimpleMaintainPlan(cUnitTypeypMorutaru, 2, true, kbBaseGetMainID(cMyID), 2);  }
         else
         {  aiPlanSetVariableInt(ypMorutaruPlan, cTrainPlanNumberToMaintain, 0, 2); }
      }
      if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
      {
         if (ypSiegeElephantPlan < 0)
         {  ypSiegeElephantPlan = createSimpleMaintainPlan(cUnitTypeypSiegeElephant, 2, true, kbBaseGetMainID(cMyID), 2);  }
         else
         {  aiPlanSetVariableInt(ypSiegeElephantPlan, cTrainPlanNumberToMaintain, 0, 2); }   
      }           
   }   
}


rule siegeWeaponManager
active
minInterval 15
{     

   if (aiTreatyActive() == true)
   {
      aiEcho("delayed because treaty is active.");
      return;
   }
  
   vector siegeWeaponVec = cInvalidVector;
   
   int siegeWeaponUnit = getUnit(gSiegeWeaponUnit, cMyID, cUnitStateAlive);   
      
   if (siegeWeaponUnit >= 0)
      siegeWeaponVec = kbUnitGetPosition(siegeWeaponUnit);
   else
      siegeWeaponVec = kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID));  
       
   int numUnit = kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive);
   if (kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive) > 0) 
   { 
      if (getMatchTarget() >= 0)  // There's something to attack :)
      {
         int attackPlan = aiPlanCreate("Mortar Attack plan", cPlanAttack);
         aiPlanSetVariableInt(attackPlan, cAttackPlanPlayerID, 0, getMatchTarget());
         aiPlanSetNumberVariableValues(attackPlan, cAttackPlanTargetTypeID, 3, true);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 0, cUnitTypeBuildingsThatShoot);          
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 1, cUnitTypeMilitaryBuilding);
         aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 2, cUnitTypeBuilding);
         aiPlanSetVariableVector(attackPlan, cAttackPlanGatherPoint, 0, siegeWeaponVec);
         aiPlanSetVariableFloat(attackPlan, cAttackPlanGatherDistance, 0, 100.0);
         aiPlanSetVariableInt(attackPlan, cAttackPlanRefreshFrequency, 0, 1);
         aiPlanSetDesiredPriority(attackPlan, 58);          
         aiPlanAddUnitType(attackPlan, gSiegeWeaponUnit, numUnit, numUnit, numUnit);
         aiPlanSetUnitStance(attackPlan, cUnitStanceAggressive);
         aiPlanSetInitialPosition(attackPlan, siegeWeaponVec);
         aiEcho("***** ATTACK, plan ID is +attackPlan *****"); 
         aiPlanSetActive(attackPlan, true);
      }
   }
}


//==============================================================================
/*
   moveDefenseReflex(vector, radius, baseID)
   
   Move the defend and reserve plans to the specified location
   Sets the gLandDefendPlan0 to a high pop count, so it steals units from the reserve plan,
   which will signal the AI to not start new attacks as no reserves are available.
*/
//==============================================================================
void moveDefenseReflex(vector location=cInvalidVector, float radius=-1.0, int baseID=-1)
{
   if (radius < 0.0)
      radius = cvDefenseReflexRadiusActive;
   if (location != cInvalidVector)
   {    
      aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0, location);
      aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, radius);  
      aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, radius - 10.0);
      aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary, 0, 0, 200);
      
      aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, location);
      aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, radius);    
      aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, radius - 10.0);
      aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary, 0, 0, 1);
      
      gDefenseReflex = true;
      gDefenseReflexBaseID = baseID;
      gDefenseReflexLocation = location;
      gDefenseReflexStartTime = xsGetTime();
      gDefenseReflexPaused = false;
   }
   aiEcho("******** Defense reflex moved to base "+baseID+" with radius "+radius+" and location "+location);
}

//==============================================================================
/*
   pauseDefenseReflex()
   
   The base (gDefenseReflexBaseID) is still under attack, but we don't have enough
   forces to engage.  Retreat to main base, set a small radius, and wait until we 
   have enough troops to re-engage through a moveDefenseReflex() call.
   Sets gLandDefendPlan0 to high troop count to keep reserve plan empty.
   Leaves the base ID and location untouched, even though units will gather at home.
*/
//==============================================================================
void pauseDefenseReflex(void)
{
   vector loc = kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID));
   if ( gForwardBaseState != cForwardBaseStateNone )
      loc = gForwardBaseLocation;
   
   aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0, loc);  
   aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusPassive);   
   aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusPassive - 10.0);
   
   aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, loc);
   aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusPassive);    
   aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusPassive - 10.0);   
   
   aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary, 0, 0, 200);
   aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary, 0, 0, 1);

   
   gDefenseReflexPaused = true;
   
   aiEcho("******** Defense reflex paused.");
}

//==============================================================================
/*
   endDefenseReflex()
   
   Move the defend and reserve plans to their default positions
*/
//==============================================================================
void endDefenseReflex(void)
{
   vector resLoc = kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID));
   vector defLoc = kbBaseGetLocation(cMyID,kbBaseGetMainID(cMyID));
   if ( gForwardBaseState != cForwardBaseStateNone )
   {
      resLoc = gForwardBaseLocation;
      defLoc = gForwardBaseLocation;
   }
   aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0, defLoc);  // Main base or forward base (if forward base exists)
   aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);  
   aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusActive - 10.0);
   aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary, 0, 0, 1);     // Defend plan will use 1 unit to defend against stray snipers, etc.
   
   aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, resLoc);  
   aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusPassive);   // Small radius
   aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusPassive - 10.0);
   aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary, 0, 0, 200);   // All unused troops
   
   aiEcho("******** Defense reflex terminated for base "+gDefenseReflexBaseID+" at location "+gDefenseReflexLocation);
   aiEcho("******** Returning to "+resLoc);
   aiEcho(" Forward base ID is "+gForwardBaseID+", location is "+gForwardBaseLocation);
   
   gDefenseReflex = false;
   gDefenseReflexPaused = false;
   gDefenseReflexBaseID = -1;
   gDefenseReflexLocation = cInvalidVector;
   gDefenseReflexStartTime = -1;
}

rule endDefenseReflexDelay    // Use this instead of calling endDefenseReflex in the createMainBase function, so that the new BaseID will be available.
inactive
minInterval 1
{
   xsDisableSelf();
   endDefenseReflex();
}


int baseBuildingCount(int baseID = -1)
{
   int retVal = -1;
   
   if (baseID >= 0)  // Check for buildings in the base, regardless of player ID (only baseOwner can have buildings there)
      retVal = kbBaseGetNumberUnits(kbBaseGetOwner(baseID), baseID, cPlayerRelationAny, cUnitTypeBuilding);
     
   return(retVal);
}

//==============================================================================
// useLevy
//==============================================================================
rule useLevy
inactive
group tcComplete
minInterval 37
{
   // Disable rule for native or Asian civs
   if ((civIsNative() == true) || (civIsAsian() == true))
   {
      xsDisableSelf();
      return;
   }

   // Check to see if town is being overrun.  If so, generate a plan
   // to 'research' levy.  If plan is active but enemies disappear, 
   // kill it.  Once research is complete, end this rule.
   
   static int levyPlan = -1;
   vector mainBaseVec = cInvalidVector;
   
   mainBaseVec =  kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   
   int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, mainBaseVec, 40.0);
   int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive, mainBaseVec, 40.0);

   
   /*
   if (kbTechGetStatus(cTechLevy) != cTechStatusActive) // this check does not work!
   {  // We're done, we've used levy
      aiEcho("   ** We've used levy, disabling useLevy rule.");
      xsDisableSelf();
      return;
   }  
   */
   
   if (levyPlan < 0) // No plan, see if we need one.
   {
      if (enemyCount >= (allyCount+6)) // We're behind by 6 or more
      {
         aiEcho("***** Starting a levy plan, there are "+enemyCount+" enemy units in my base against "+allyCount+" friendlies.");
         levyPlan = createSimpleResearchPlan(cTechLevy, getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority        
      }
   }
   else  // Plan exists, make sure it's still needed
   {
      if (enemyCount > (allyCount+2))
      {  // Do nothing
         aiEcho("   ** Still waiting for Levy.");
      }
      else
      {
         aiEcho("   ** Cancelling levy.");
         aiPlanDestroy(levyPlan);
         levyPlan = -1;
      }
   }
}


//==============================================================================
// mostHatedEnemy
// Determine who we should attack, checking control variables
//==============================================================================
rule mostHatedEnemy
minInterval 20
active
{
   if ( (cvPlayerToAttack > 0)) // && (kbHasPlayerLost(cvPlayerToAttack) == false) )
   {
      aiEcho("****  Changing most hated enemy from "+aiGetMostHatedPlayerID()+" to "+cvPlayerToAttack);
      aiSetMostHatedPlayerID(cvPlayerToAttack);
      return;
   }
   
   // For now, find your position in your team (i.e. 2nd of 3) and
   // target the corresponding player on the other team.  If the other
   // team is smaller, count through again.  (I.e. in a 5v2, player 5 on
   // one team will attack the 1st player on the other.)

   int ourTeamSize = 0;
   int theirTeamSize = 0;
   int myPosition = 0;
   int i=0;
   
   for (i=1; <cNumberPlayers)
   {
      //if (kbHasPlayerLost(i) == false)
      //{
         if ( kbGetPlayerTeam(i) == kbGetPlayerTeam(cMyID) )
         {  // Self or ally 
            ourTeamSize = ourTeamSize + 1;
            if ( i == cMyID )
               myPosition = ourTeamSize;   
         }
         else
         {
            theirTeamSize = theirTeamSize + 1;
         }
      //}
   }
   int targetPlayerPosition = 0;
   
   if (myPosition > theirTeamSize)
   {
      targetPlayerPosition = myPosition - (theirTeamSize * (myPosition/theirTeamSize));      // myPosition modulo theirTeamSize
      if (targetPlayerPosition == 0)
         targetPlayerPosition = theirTeamSize;  // Need to be in range 1...teamsize, not 0...(teamSize-1).
   }
   else
      targetPlayerPosition = myPosition;
   
   int playerCount = 0;
   // Find the corresponding enemy player
   for (i=1; <cNumberPlayers)
   {
      if ( /*(kbHasPlayerLost(i) == false) &&*/ (kbGetPlayerTeam(i) != kbGetPlayerTeam(cMyID) ) )
      {
         playerCount = playerCount + 1;
         if (playerCount == targetPlayerPosition)
         { 
            if (aiGetMostHatedPlayerID() != i)
               aiEcho("****  Changing most hated enemy from "+aiGetMostHatedPlayerID()+" to "+i);
            aiSetMostHatedPlayerID(i);
            if (gLandUnitPicker >= 0)
               kbUnitPickSetEnemyPlayerID(gLandUnitPicker, i); // Update the unit picker
         }
      }
   }
}


//==============================================================================
// initMil
//==============================================================================
void initMil(void)
{
   //Set the default attack response distance.
   aiSetAttackResponseDistance(40.0);

   // Choose a most-hated player
   xsEnableRule("mostHatedEnemy");

   // Call it immediately
   mostHatedEnemy();   

   //Auto gather our military units.
   aiSetAutoGatherMilitaryUnits(true);

  if (kbGetCiv() == cCivBritish)
   {      
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      //gLandPrimaryArmyUnit = cUnitTypeLongbowman;
      //gLandPrimaryArmyUnit = cUnitTypeHussar;
      //gLandPrimaryArmyUnit = cUnitTypeDragoon;
      gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeLongbowman;
      //gLandSecondaryArmyUnit = cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeDragoon;
      //gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      gLandTertiaryArmyUnit = cUnitTypeLongbowman;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeDragoon;
      //gLandPrimaryArmyUnit = cUnitTypeMusketeer;//  cUnitTypeHussar + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeLongbowman;
      //gLandSecondaryArmyUnit = cUnitTypeLongbowman;//  + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeLongbowman;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;//  + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeLongbowman;
   } 
   if (kbGetCiv() == cCivFrench)
   {
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      //gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      //gLandPrimaryArmyUnit = cUnitTypeCuirassier;
      //gLandPrimaryArmyUnit = cUnitTypeDragoon;
      gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;
      //gLandSecondaryArmyUnit = cUnitTypeCuirassier;
      //gLandSecondaryArmyUnit = cUnitTypeDragoon;
      gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeSkirmisher;
      //gLandTertiaryArmyUnit = cUnitTypeCuirassier;
      //gLandTertiaryArmyUnit = cUnitTypeDragoon;
      //gLandPrimaryArmyUnit = cUnitTypeMusketeer;//  cUnitTypeSkirmisher + cUnitTypeCuirassier + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;//  + cUnitTypeCuirassier + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeCuirassier;//  + cUnitTypeCuirassier + cUnitTypeMusketeer + cUnitTypeDragoon + cUnitTypeHussar;
   }
   if (kbGetCiv() == cCivGermans)
   {
      //gLandPrimaryArmyUnit = cUnitTypeDopplesoldner;
      gLandPrimaryArmyUnit = cUnitTypeUhlan;
      //gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      //gLandPrimaryArmyUnit = cUnitTypeWarWagon;
      //gLandSecondaryArmyUnit = cUnitTypeDopplesoldner;
      gLandSecondaryArmyUnit = cUnitTypeUhlan;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;
      //gLandSecondaryArmyUnit = cUnitTypeWarWagon;
      //gLandTertiaryArmyUnit = cUnitTypeDopplesoldner;
      gLandTertiaryArmyUnit = cUnitTypeUhlan;
      //gLandTertiaryArmyUnit = cUnitTypeSkirmisher;
      //gLandTertiaryArmyUnit = cUnitTypeWarWagon;
      //gLandPrimaryArmyUnit = cUnitTypeDopplesoldner;//  + cUnitTypeWarWagon + cUnitTypeSkirmisher + cUnitTypeUhlan;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;//  + cUnitTypeWarWagon + cUnitTypeSkirmisher + cUnitTypeUhlan;
      //gLandTertiaryArmyUnit = cUnitTypeWarWagon;//  + cUnitTypeWarWagon + cUnitTypeSkirmisher + cUnitTypeUhlan;
   }
   if (kbGetCiv() == cCivSpanish)
   {
      //gLandPrimaryArmyUnit = cUnitTypeLancer;
      //gLandPrimaryArmyUnit = cUnitTypeRodelero;
      //gLandPrimaryArmyUnit = cUnitTypePikeman;
      //gLandPrimaryArmyUnit = cUnitTypeWarDog;
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      //gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      //gLandPrimaryArmyUnit = cUnitTypeDragoon;
      //gLandSecondaryArmyUnit = cUnitTypeLancer;
      //gLandSecondaryArmyUnit = cUnitTypeRodelero;
      //gLandSecondaryArmyUnit = cUnitTypePikeman;
      //gLandSecondaryArmyUnit = cUnitTypeWarDog;
      gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeSkirmisher;
      //gLandSecondaryArmyUnit = cUnitTypeDragoon;
      //gLandTertiaryArmyUnit = cUnitTypeLancer;
      //gLandTertiaryArmyUnit = cUnitTypeRodelero;
      //gLandTertiaryArmyUnit = cUnitTypePikeman;
      //gLandTertiaryArmyUnit = cUnitTypeWarDog;
      gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeSkirmisher;
      //gLandTertiaryArmyUnit = cUnitTypeDragoon;
      //gLandPrimaryArmyUnit = cUnitTypeRodelero;//  + cUnitTypePikeman + cUnitTypeLancer + cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeLancer;//  + cUnitTypePikeman + cUnitTypeLancer + cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypePikeman;//  + cUnitTypePikeman + cUnitTypeLancer + cUnitTypeHussar;
   }
   if (kbGetCiv() == cCivPortuguese)
   {
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      //gLandPrimaryArmyUnit = cUnitTypeCacadore;
      //gLandPrimaryArmyUnit = cUnitTypeDragoon;
      //gLandPrimaryArmyUnit = cUnitTypeHussar;
      //gLandPrimaryArmyUnit = cUnitTypeOrganGun;
      gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeCacadore;
      //gLandSecondaryArmyUnit = cUnitTypeDragoon;
      //gLandSecondaryArmyUnit = cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeOrganGun;
      //gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeCacadore;
      //gLandTertiaryArmyUnit = cUnitTypeDragoon;
      gLandTertiaryArmyUnit = cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeOrganGun;
      //gLandPrimaryArmyUnit = cUnitTypeMusketeer; // + cUnitTypeCacadore + cUnitTypeDragoon + cUnitTypeOrganGun + cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeCacadore; // + cUnitTypeCacadore + cUnitTypeDragoon + cUnitTypeOrganGun + cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeDragoon; // + cUnitTypeCacadore + cUnitTypeDragoon + cUnitTypeOrganGun + cUnitTypeHussar;
      gAbstractArtilleryUnit = cUnitTypeOrganGun;
   }
   if (kbGetCiv() == cCivDutch)
   {
      gLandPrimaryArmyUnit = cUnitTypeSkirmisher;
      //gLandPrimaryArmyUnit = cUnitTypeHussar;
      //gLandPrimaryArmyUnit = cUnitTypeRuyter;
      //gLandPrimaryArmyUnit = cUnitTypeHalberdier;
      //gLandPrimaryArmyUnit = cUnitTypexpHorseArtillery;
      //gLandPrimaryArmyUnit = cUnitTypeFalconet;
      //gLandPrimaryArmyUnit = cUnitTypeGrenadier;
      gLandSecondaryArmyUnit = cUnitTypeSkirmisher;
      //gLandSecondaryArmyUnit = cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeRuyter;
      //gLandSecondaryArmyUnit = cUnitTypeHalberdier;
      //gLandSecondaryArmyUnit = cUnitTypexpHorseArtillery;
      //gLandSecondaryArmyUnit = cUnitTypeFalconet;
      //gLandSecondaryArmyUnit = cUnitTypeGrenadier;
      //gLandTertiaryArmyUnit = cUnitTypeSkirmisher;
      gLandTertiaryArmyUnit = cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeRuyter;
      //gLandTertiaryArmyUnit = cUnitTypeHalberdier;
      //gLandTertiaryArmyUnit = cUnitTypexpHorseArtillery;
      //gLandTertiaryArmyUnit = cUnitTypeFalconet;
      //gLandTertiaryArmyUnit = cUnitTypeGrenadier;
      //gLandPrimaryArmyUnit = cUnitTypeSkirmisher;//  + cUnitTypeRuyter + cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeRuyter;//  + cUnitTypeRuyter + cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;//  + cUnitTypeRuyter + cUnitTypeHussar;
      gGalleonUnit = cUnitTypeFluyt;
   }
   if (kbGetCiv() == cCivRussians)
   {
      //gLandPrimaryArmyUnit = cUnitTypeStrelet;
      //gLandPrimaryArmyUnit = cUnitTypeCossack;
      gLandPrimaryArmyUnit = cUnitTypeMusketeer;
      //gLandPrimaryArmyUnit = cUnitTypeGrenadier;
      //gLandPrimaryArmyUnit = cUnitTypeCavalryArcher;
      gLandSecondaryArmyUnit = cUnitTypeStrelet;
      //gLandSecondaryArmyUnit = cUnitTypeCossack;
      //gLandSecondaryArmyUnit = cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeGrenadier;
      //gLandSecondaryArmyUnit = cUnitTypeCavalryArcher;
      gLandTertiaryArmyUnit = cUnitTypeStrelet;
      //gLandTertiaryArmyUnit = cUnitTypeCossack;
      //gLandTertiaryArmyUnit = cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeGrenadier;
      //gLandTertiaryArmyUnit = cUnitTypeCavalryArcher;
      //gLandPrimaryArmyUnit = cUnitTypeStrelet;//  + cUnitTypeCossack + cUnitTypeMusketeer;
      //gLandSecondaryArmyUnit = cUnitTypeCossack;//  + cUnitTypeCossack + cUnitTypeMusketeer;
      //gLandTertiaryArmyUnit = cUnitTypeMusketeer;//  + cUnitTypeCossack + cUnitTypeMusketeer;
      gTowerUnit = cUnitTypeBlockhouse;
      gBarracksUnit = gTowerUnit;
   }
   if (kbGetCiv() == cCivOttomans)
   {
      gLandPrimaryArmyUnit = cUnitTypeJanissary;
      //gLandPrimaryArmyUnit = cUnitTypeAbusGun;
      //gLandPrimaryArmyUnit = cUnitTypeHussar;
      //gLandPrimaryArmyUnit = cUnitTypeCavalryArcher;
      //gLandPrimaryArmyUnit = cUnitTypeGrenadier;
      gLandSecondaryArmyUnit = cUnitTypeJanissary;
      //gLandSecondaryArmyUnit = cUnitTypeAbusGun;
      //gLandSecondaryArmyUnit = cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeCavalryArcher;
      //gLandSecondaryArmyUnit = cUnitTypeGrenadier;
      gLandTertiaryArmyUnit = cUnitTypeJanissary;
      //gLandTertiaryArmyUnit = cUnitTypeAbusGun;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeCavalryArcher;
      //gLandTertiaryArmyUnit = cUnitTypeGrenadier;
      //gLandPrimaryArmyUnit = cUnitTypeJanissary;//  + cUnitTypeAbusGun + cUnitTypeHussar;
      //gLandSecondaryArmyUnit = cUnitTypeAbusGun;//  + cUnitTypeAbusGun + cUnitTypeHussar;
      //gLandTertiaryArmyUnit = cUnitTypeHussar;//  + cUnitTypeAbusGun + cUnitTypeHussar; 
      gCaravelUnit = cUnitTypeGalley;
   }
   if (kbGetCiv() == cCivXPAztec)   
   {
      //gLandPrimaryArmyUnit = cUnitTypexpJaguarKnight;
      //gLandPrimaryArmyUnit = cUnitTypexpCoyoteMan;
      gLandPrimaryArmyUnit = cUnitTypexpMacehualtin;
      //gLandPrimaryArmyUnit = cUnitTypexpPumaMan;
      //gLandPrimaryArmyUnit = cUnitTypexpEagleKnight;
      //gLandSecondaryArmyUnit = cUnitTypexpJaguarKnight;
      gLandSecondaryArmyUnit = cUnitTypexpCoyoteMan;
      //gLandSecondaryArmyUnit = cUnitTypexpMacehualtin;
      //gLandSecondaryArmyUnit = cUnitTypexpPumaMan;
      //gLandSecondaryArmyUnit = cUnitTypexpEagleKnight;
      //gLandTertiaryArmyUnit = cUnitTypexpJaguarKnight;
      //gLandTertiaryArmyUnit = cUnitTypexpCoyoteMan;
      gLandTertiaryArmyUnit = cUnitTypexpMacehualtin;
      //gLandTertiaryArmyUnit = cUnitTypexpPumaMan;
      //gLandTertiaryArmyUnit = cUnitTypexpEagleKnight;
      //gLandPrimaryArmyUnit = cUnitTypexpJaguarKnight;//  + cUnitTypexpCoyoteMan + cUnitTypexpMacehualtin;
      //gLandSecondaryArmyUnit = cUnitTypexpCoyoteMan;//  + cUnitTypexpCoyoteMan + cUnitTypexpMacehualtin;
      //gLandTertiaryArmyUnit = cUnitTypexpMacehualtin;//  + cUnitTypexpCoyoteMan + cUnitTypexpMacehualtin;
      gAbstractArtilleryUnit = -1;
      gBarracksUnit = cUnitTypeWarHut;
      gTowerUnit = cUnitTypeWarHut;
      gTowerWagonUnit = cUnitTypeWarHutTravois;
      //gTowerUnit = cUnitTypeNoblesHut; 
      gExplorerUnit = cUnitTypexpAztecWarchief;
      //gCaravelUnit = cUnitTypeCanoe;      
      gGalleonUnit = cUnitTypexpWarCanoe;
      gFrigateUnit = cUnitTypexpTlalocCanoe;
   }   

   if (kbGetCiv() == cCivXPSioux)
   {  
      gLandPrimaryArmyUnit = cUnitTypexpAxeRider;
      //gLandPrimaryArmyUnit = cUnitTypexpBowRider;
      //gLandPrimaryArmyUnit = cUnitTypexpRifleRider;
      //gLandPrimaryArmyUnit = cUnitTypexpCoupRider;
      //gLandPrimaryArmyUnit = cUnitTypexpWarRifle;
      //gLandSecondaryArmyUnit = cUnitTypexpAxeRider;
      gLandSecondaryArmyUnit = cUnitTypexpBowRider;
      //gLandSecondaryArmyUnit = cUnitTypexpRifleRider;
      //gLandSecondaryArmyUnit = cUnitTypexpCoupRider;
      //gLandSecondaryArmyUnit = cUnitTypexpWarRifle;
      //gLandTertiaryArmyUnit = cUnitTypexpAxeRider;
      gLandTertiaryArmyUnit = cUnitTypexpBowRider;
      //gLandTertiaryArmyUnit = cUnitTypexpRifleRider;
      //gLandTertiaryArmyUnit = cUnitTypexpCoupRider;
      //gLandTertiaryArmyUnit = cUnitTypexpWarRifle;
      //gLandPrimaryArmyUnit = cUnitTypexpAxeRider;//  + cUnitTypexpBowRider + cUnitTypexpRifleRider;
      //gLandSecondaryArmyUnit = cUnitTypexpBowRider;//  + cUnitTypexpBowRider + cUnitTypexpRifleRider;
      //gLandTertiaryArmyUnit = cUnitTypexpRifleRider;//  + cUnitTypexpBowRider + cUnitTypexpRifleRider;
      gAbstractArtilleryUnit = -1;
      //gTowerUnit = cUnitTypeTeepee;
      gStableUnit = cUnitTypeCorral;
      gBarracksUnit = cUnitTypeWarHut;
      gTowerUnit = cUnitTypeWarHut;
      gTowerWagonUnit = cUnitTypeWarHutTravois;
      gExplorerUnit = cUnitTypexpLakotaWarchief;

      //gCaravelUnit = cUnitTypeCanoe;      
      gGalleonUnit = cUnitTypexpWarCanoe;
   }
     
   if ( kbGetCiv() == cCivXPIroquois )
   {  
      gLandPrimaryArmyUnit = cUnitTypexpTomahawk;
      //gLandPrimaryArmyUnit = cUnitTypexpMusketWarrior;
      //gLandPrimaryArmyUnit = cUnitTypexpMusketRider;
      //gLandPrimaryArmyUnit = cUnitTypexpMantlet;
      //gLandPrimaryArmyUnit = cUnitTypexpHorseman;
      gLandSecondaryArmyUnit = cUnitTypexpTomahawk;
      //gLandSecondaryArmyUnit = cUnitTypexpMusketWarrior;
      //gLandSecondaryArmyUnit = cUnitTypexpMusketRider;
      //gLandSecondaryArmyUnit = cUnitTypexpMantlet;
      //gLandSecondaryArmyUnit = cUnitTypexpHorseman;
      gLandPrimaryArmyUnit = cUnitTypexpTomahawk;
      //gLandTertiaryArmyUnit = cUnitTypexpMusketWarrior;
      //gLandTertiaryArmyUnit = cUnitTypexpMusketRider;
      //gLandTertiaryArmyUnit = cUnitTypexpMantlet;
      //gLandTertiaryArmyUnit = cUnitTypexpHorseman;
      //gLandPrimaryArmyUnit = cUnitTypexpTomahawk;//  + cUnitTypexpAenna + cUnitTypexpWarRifle + cUnitTypexpMantlet;
      //gLandSecondaryArmyUnit = cUnitTypexpMantlet;//  + cUnitTypexpAenna + cUnitTypexpWarRifle + cUnitTypexpMantlet;
      //gLandTertiaryArmyUnit = cUnitTypexpMusketWarrior;//  + cUnitTypexpAenna + cUnitTypexpWarRifle + cUnitTypexpMantlet; 
      gAbstractArtilleryUnit = cUnitTypexpLightCannon;
      gStableUnit = cUnitTypeCorral;
      gBarracksUnit = cUnitTypeWarHut;    
      gTowerUnit = cUnitTypeWarHut;            
      gTowerWagonUnit = cUnitTypeWarHutTravois;
      gExplorerUnit = cUnitTypexpIroquoisWarChief;
      gSiegeWeaponUnit = cUnitTypexpRam;
      //gCaravelUnit = cUnitTypeCanoe;      
      gGalleonUnit = cUnitTypexpWarCanoe;
   }

   if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
   {
      gLandPrimaryArmyUnit = cUnitTypeypOldHanArmy; // + cUnitTypeypTerritorialArmy + cUnitTypeypForbiddenArmy;
      gLandSecondaryArmyUnit = cUnitTypeypOldHanArmy; // + cUnitTypeypOldHanArmy + cUnitTypeypForbiddenArmy;
      gLandTertiaryArmyUnit = cUnitTypeypOldHanArmy; // + cUnitTypeypTerritorialArmy + cUnitTypeypOldHanArmy;
      //gLandSecondaryArmyUnit = cUnitTypeypTerritorialArmy; // + cUnitTypeypOldHanArmy + cUnitTypeypForbiddenArmy;
      //gLandTertiaryArmyUnit = cUnitTypeypForbiddenArmy; // + cUnitTypeypTerritorialArmy + cUnitTypeypOldHanArmy;
      gAbstractArtilleryUnit = cUnitTypeypFlameThrower;
      gBarracksUnit = cUnitTypeypWarAcademy;      
      gStableUnit = -1;
      gTowerUnit = cUnitTypeypCastle;
      gTowerWagonUnit = cUnitTypeYPCastleWagon;  
      gExplorerUnit = cUnitTypeAbstractChineseMonk; 
      gSiegeWeaponUnit = cUnitTypeypHandMortar;
      gCaravelUnit = cUnitTypeypFireship;
      gGalleonUnit = cUnitTypeypFuchuan;
      gFrigateUnit = cUnitTypeypWarJunk;     
   }
   
   if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) )
   {
      //gLandPrimaryArmyUnit = cUnitTypeypKensei;
      gLandPrimaryArmyUnit = cUnitTypeypAshigaru;
      //gLandPrimaryArmyUnit = cUnitTypeypYumi;
      //gLandPrimaryArmyUnit = cUnitTypeypYabusame;
      //gLandPrimaryArmyUnit = cUnitTypeypNaginataRider;
      //gLandSecondaryArmyUnit = cUnitTypeypKensei;
      gLandSecondaryArmyUnit = cUnitTypeypAshigaru;
      //gLandSecondaryArmyUnit = cUnitTypeypYumi;
      //gLandSecondaryArmyUnit = cUnitTypeypYabusame;
      //gLandSecondaryArmyUnit = cUnitTypeypNaginataRider;
      //gLandTertiaryArmyUnit = cUnitTypeypKensei;
      gLandTertiaryArmyUnit = cUnitTypeypAshigaru;
      //gLandTertiaryArmyUnit = cUnitTypeypYumi;
      //gLandTertiaryArmyUnit = cUnitTypeypYabusame;
      //gLandTertiaryArmyUnit = cUnitTypeypNaginataRider;
      //gLandPrimaryArmyUnit = cUnitTypeypAshigaru;//  + cUnitTypeypKensei + cUnitTypeypYumi;
      //gLandSecondaryArmyUnit = cUnitTypeypNaginataRider;//  + cUnitTypeypKensei + cUnitTypeypYumi;
      //gLandTertiaryArmyUnit = cUnitTypeypYumi;//  + cUnitTypeypKensei + cUnitTypeypYumi; 
      gAbstractArtilleryUnit = cUnitTypeypFlamingArrow;
      gBarracksUnit = cUnitTypeypBarracksJapanese;
      gStableUnit = cUnitTypeypStableJapanese;
      gTowerUnit = cUnitTypeypCastle;
      gTowerWagonUnit = cUnitTypeYPCastleWagon;      
      gExplorerUnit = cUnitTypeAbstractJapaneseMonk;
      gSiegeWeaponUnit = cUnitTypeypMorutaru;
      gCaravelUnit = cUnitTypeypFune;
      gGalleonUnit = cUnitTypeypAtakabune;
      gFrigateUnit = cUnitTypeypTekkousen;  
   }
   
   if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
   {
      gLandPrimaryArmyUnit = cUnitTypeAbstractSepoy;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractGurkha;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractRajput;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractSowar;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractZamburak;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractHowdah;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractMahout;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractSepoy;
      gLandSecondaryArmyUnit = cUnitTypeAbstractGurkha;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractRajput;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractSowar;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractZamburak;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractHowdah;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractMahout;
      gLandTertiaryArmyUnit = cUnitTypeAbstractSepoy;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractGurkha;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractRajput;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractSowar;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractZamburak;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractHowdah;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractMahout;
      //gLandPrimaryArmyUnit = cUnitTypeAbstractSepoy;//  + cUnitTypeAbstractGurkha + cUnitTypeAbstractSowar;
      //gLandSecondaryArmyUnit = cUnitTypeAbstractGurkha;//  + cUnitTypeAbstractGurkha + cUnitTypeAbstractSowar;
      //gLandTertiaryArmyUnit = cUnitTypeAbstractSowar;//  + cUnitTypeAbstractGurkha + cUnitTypeAbstractSowar; 
      gAbstractArtilleryUnit = -1;
      gBarracksUnit = cUnitTypeYPBarracksIndian;
      gStableUnit = cUnitTypeypCaravanserai;
      gTowerUnit = cUnitTypeypCastle;
      gTowerWagonUnit = cUnitTypeYPCastleWagon;
      gExplorerUnit = cUnitTypeAbstractIndianMonk;
      gSiegeWeaponUnit = cUnitTypeypSiegeElephant;      
   }
}

//==============================================================================
/* Defend0

   Create a defend plan, protect the main base.
*/
//==============================================================================
rule defend0
inactive
group startup
minInterval 15
{  
   
   if (gLandDefendPlan0 < 0)
   {
      gLandDefendPlan0 = aiPlanCreate("Primary Land Defend", cPlanDefend);
      aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary , 0, 0, 1);    // Small, until defense reflex
      
      aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);  
      aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusActive - 10.0);
      aiPlanSetVariableBool(gLandDefendPlan0, cDefendPlanPatrol, 0, false);
      aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, 40.0);
      aiPlanSetInitialPosition(gLandDefendPlan0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetUnitStance(gLandDefendPlan0, cUnitStanceDefensive);
      aiPlanSetVariableInt(gLandDefendPlan0, cDefendPlanRefreshFrequency, 0, 1);
      aiPlanSetVariableInt(gLandDefendPlan0, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
      aiPlanSetDesiredPriority(gLandDefendPlan0, 10);    // Very low priority, don't steal from attack plans
      aiPlanSetActive(gLandDefendPlan0); 
      aiEcho("Creating primary land defend plan");
   
      gLandReservePlan = aiPlanCreate("Land Reserve Units", cPlanDefend);
      aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary , 0, 5, 200);    // All mil units, high MAX value to suck up all excess
      
      aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
      if (kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)) == cInvalidVector)
        if (getUnit(cUnitTypeAIStart, cMyID) >= 0)   // If no mil gather point, but there is a start block, use it.
            aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeAIStart, cMyID)));
      if (aiPlanGetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0) == cInvalidVector) // If all else failed, use main base location.
         aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, kbBaseGetLocation(kbBaseGetMainID(cMyID)));
      aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, 60.0);    // Loose
      aiPlanSetVariableBool(gLandReservePlan, cDefendPlanPatrol, 0, false);
      aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, 40.0);
      aiPlanSetInitialPosition(gLandReservePlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetUnitStance(gLandReservePlan, cUnitStanceDefensive);
      aiPlanSetVariableInt(gLandReservePlan, cDefendPlanRefreshFrequency, 0, 1);
      aiPlanSetVariableInt(gLandReservePlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
      aiPlanSetDesiredPriority(gLandReservePlan, 5);    // Very very low priority, gather unused units.
      aiPlanSetActive(gLandReservePlan); 
      if (gMainAttackGoal >= 0)
         aiPlanSetVariableInt(gMainAttackGoal, cGoalPlanReservePlanID, 0, gLandReservePlan);
      aiEcho("Creating reserve plan");
      xsEnableRule("endDefenseReflexDelay"); // Reset to relaxed stances after plans have a second to be created.
   }
}






//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// General strategy (spans econ/mil)
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================






//==============================================================================
/* getActiveMissionCount(int missionType)
   
   Returns the number of active missions that match the optional type.  If no types
   is given, returns the total number of missions.
*/
//==============================================================================
/*int getActiveMissionCount(int missionType=-1)
{
   int retVal = 0;
   
   int missionCount = 0;
   int missionIndex = 0;
   int missionID = -1;
   
   for (missionIndex = 0; < aiPlanGetNumber(cPlanMission, -1, true))    // Step through all mission plans.  -1 means any state is OK.
   {
      missionID = aiPlanGetIDByIndex(cPlanMission, -1, true, missionIndex);
      if ( (missionType == -1) || (aiPlanGetVariableInt(missionID, cMissionPlanType, 0) == missionType) )   // No type specified, or type matches
         retVal = retVal + 1;
   }      
   
   return(retVal);
}*/


void setMilPopLimit(int age1=10, int age2=200, int age3=300, int age4=400, int age5=600)
{
   int limit = 10;
   int age = kbGetAge();
   if (age == cvMaxAge)
      age = cAge5;   // If we're at the highest allowed age, go for our full mil pop.
      // This overrides the normal settings, so an SPC AI capped at age 3 can use his full
      // military pop.
   switch(age)
   {
      case cAge1:
      {
         limit = age1;
         break;
      }
      case cAge2:
      {
         limit = age2;
         break;
      }
      case cAge3:
      {
         limit = age3;
         break;
      }
      case cAge4:
      {
         limit = age4;
         break;
      }
      case cAge5:
      {
         limit = age5;
         break;
      }
   }
   if ( (cvMaxArmyPop >= 0) && (cvMaxNavyPop >= 0) && (limit > (cvMaxArmyPop + cvMaxNavyPop)) )
      limit = cvMaxArmyPop+cvMaxNavyPop;     // Manual pop limits have been set
   
   if ( (cvMaxNavyPop <= 0) && (cvMaxArmyPop < limit) && (cvMaxArmyPop >= 0) )  // Only army pop set?
      limit = cvMaxArmyPop;
   
   aiSetMilitaryPop(limit);
}


//==============================================================================
/* rule popManager
   
   Set population limits based on age, difficulty and control variable settings
*/
//==============================================================================
rule popManager
active
minInterval 5
{
   float difficulty = aiGetWorldDifficulty();
   int intDifficulty = difficulty;
   int cvPopLimit = 200;      // Used to calculate implied total pop limit based on civ, army and navy components.
   
   if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
      cvPopLimit = 250;

   if ( (cvMaxCivPop >= 0) && (cvMaxArmyPop >= 0) && (cvMaxNavyPop >= 0) )    // All three are defined, so set a hard total
      cvPopLimit = cvMaxCivPop + cvMaxArmyPop + cvMaxNavyPop;
   
   int maxMil = -1;  // The full age-5 max military size...to be reduced in earlier ages to control runaway spending.

   switch(intDifficulty)
   {
      case cDifficultySandbox: // Sandbox
      {  // Typically 20 econ, 20 mil
	 gMaxPop = 40 + (30 * (difficulty - intDifficulty));     // Interpolate between integers
         if (gMaxPop > cvPopLimit)
            gMaxPop = cvPopLimit;
         aiSetEconomyPop(20);
         if ( (aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0) )
            aiSetEconomyPop(cvMaxCivPop);
         maxMil = gMaxPop - aiGetEconomyPop();
         setMilPopLimit(maxMil/8, maxMil/4, maxMil/2, maxMil, maxMil);
	 break;
      }
      case cDifficultyEasy: // Easiest
      {  // Typically 35 econ, 35 mil.
	 gMaxPop = 70 + (50 * (difficulty - intDifficulty));      // 70 at easy up to 120 at moderate
         if (gMaxPop > cvPopLimit)
            gMaxPop = cvPopLimit;
         aiSetEconomyPop(35);
         if (gSPC == true)
         {
            aiSetEconomyPop(25);
            gMaxPop = 55;
         }
         if ( (aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0) )
            aiSetEconomyPop(cvMaxCivPop);
         maxMil = gMaxPop - aiGetEconomyPop();
         setMilPopLimit(maxMil/8, maxMil/4, maxMil/2, maxMil, maxMil);
	 break;
      }
      case cDifficultyModerate: // Moderate
      {  // Typically 60 econ, 60 mil
	 gMaxPop = 120 + (80 * (difficulty - intDifficulty));      // 120 at moderate up to 200 at hard
         if (gMaxPop > cvPopLimit)
            gMaxPop = cvPopLimit;
         aiSetEconomyPop(60);
         if (gSPC == true)
         {
            aiSetEconomyPop(45);
            gMaxPop = 105;
         }
         if ( (aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0) )
            aiSetEconomyPop(cvMaxCivPop);
         maxMil = gMaxPop - aiGetEconomyPop();
         setMilPopLimit(maxMil/8, maxMil/4, maxMil/2, maxMil, maxMil);
	 break;
      }
      case cDifficultyHard: // Hard
      {  // Typically 80 econ, 120 mil.
         gMaxPop = cvPopLimit;
      
         if (kbGetCiv() == cCivDutch)           	  
           aiSetEconomyPop(50);
         else
         if (kbGetCiv() == cCivJapanese)           	  
           aiSetEconomyPop(75);
         else
         if (kbGetCiv() == cCivFrench)           	  
           aiSetEconomyPop(80);
         else
         if (kbGetCiv() == cCivGermans)           	  
           aiSetEconomyPop(140);
         else
         if (kbGetCiv() == cCivChinese)           	  
           aiSetEconomyPop(100);
         else
           aiSetEconomyPop(100);
       
         if ( (aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0) )
            aiSetEconomyPop(cvMaxCivPop);
         //maxMil = gMaxPop - aiGetEconomyPop(); //this is a wrong concept. for example, in DM game, we have 99 economy pop, but military pop should not be limited at 101.
         maxMil = gMaxPop;        
            if (gInitialStrategy == 0) // FI
              setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil);           
            if (gInitialStrategy == 1) // Rush (Attacker)
              setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil);
            if (gInitialStrategy == 2) // FF
              setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil);           
            if (gInitialStrategy == 3) // Economic Boomer (Turtle)
              setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil);       
	 break;
      }
      case cDifficultyExpert: // Expert
      {  // Typically 80 econ, 120 mil.
         gMaxPop = cvPopLimit;
      
         if (kbGetCiv() == cCivDutch)           	  
           aiSetEconomyPop(50);
         else
         if (kbGetCiv() == cCivJapanese)           	  
           aiSetEconomyPop(75);
         else
         if (kbGetCiv() == cCivFrench)           	  
           aiSetEconomyPop(80);
         else
         if (kbGetCiv() == cCivGermans)           	  
           aiSetEconomyPop(140);
         else
         if (kbGetCiv() == cCivChinese)           	  
           aiSetEconomyPop(100);
         else
           aiSetEconomyPop(100);
       
         if ( (aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0) )
            aiSetEconomyPop(cvMaxCivPop);
         //maxMil = gMaxPop - aiGetEconomyPop(); //this is a wrong concept. for example, in DM game, we have 99 economy pop, but military pop should not be limited at 101.
         maxMil = gMaxPop;        
            if (gInitialStrategy == 0) // FI
              setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil);           
            if (gInitialStrategy == 1) // Rush (Attacker)
              setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil);
            if (gInitialStrategy == 2) // FF
              setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil);           
            if (gInitialStrategy == 3) // Economic Boomer (Turtle)
              setMilPopLimit(0, maxMil, maxMil, maxMil, maxMil);       
	 break;
      }
   }
   /*
   gGoodArmyPop = aiGetMilitaryPop();
         if (kbGetCiv() == cCivJapanese) 
   gGoodArmyPop = 125;// 15 * kbGetAge() + 50;
         else
         if (kbGetCiv() == cCivFrench) 
   gGoodArmyPop = 120;// 12 * kbGetAge() + 60;
         else
         if (kbGetCiv() == cCivDutch) 
   gGoodArmyPop = 150;// 20 * kbGetAge() +50;
         else
         if (kbGetCiv() == cCivChinese) 
   gGoodArmyPop = 120;// 12 * kbGetAge() +60;
         else
         if (civIsNative() == true)
   gGoodArmyPop = 100;// 10 * kbGetAge() +50;
         else
	if (kbGetCiv() == cCivXPSioux) // ((kbGetCiv() == cCivOttomans) || (kbGetCiv() == cCivDutch) || (kbGetCiv() == cCivRussians) || (kbGetCiv() == cCivXPSioux) || (kbGetCiv() == cCivXPIroquois) || (kbGetCiv() == cCivXPAztec))
	gGoodArmyPop = 30 * kbGetAge() -50;// 10 * kbGetAge() +50;
	else*/
   gGoodArmyPop = aiGetMilitaryPop();
         if (kbGetCiv() == cCivJapanese) 
   gGoodArmyPop = 100 * kbGetAge() - 100;
         else
         if (kbGetCiv() == cCivFrench) 
   gGoodArmyPop = 100 * kbGetAge() - 100;
         else
         if (kbGetCiv() == cCivDutch) 
   gGoodArmyPop = 100 * kbGetAge() - 100;
         else
         if (kbGetCiv() == cCivChinese) 
   gGoodArmyPop = 100 * kbGetAge() - 100;
         else
         if (civIsNative() == true)
   gGoodArmyPop = 100 * kbGetAge() - 100;
         else
   gGoodArmyPop = 100 * kbGetAge() - 100;
   /*
   gGoodArmyPop = aiGetMilitaryPop();
         if (kbGetCiv() == cCivXPSioux) 
   gGoodArmyPop = 10 * kbGetAge() -5;
         else
   gGoodArmyPop = aiGetMilitaryPop();
		 if (kbGetAge() == cAge2)
		 {
	 gGoodArmyPop = 10;
		 }
		else
   gGoodArmyPop = aiGetMilitaryPop();
         if (kbGetCiv() == cCivJapanese) 
   gGoodArmyPop = 25 * kbGetAge() - 25;
         else
         if (kbGetCiv() == cCivFrench) 
   gGoodArmyPop = 24 * kbGetAge() -24;
         else
         if (kbGetCiv() == cCivDutch) 
   gGoodArmyPop = 30 * kbGetAge() -30;
         else
         if (kbGetCiv() == cCivChinese) 
   gGoodArmyPop = 24 * kbGetAge() -24;
         else
   gGoodArmyPop = 20 * kbGetAge() -20;*/
   
}


//==============================================================================
// findACompletedTownCenter
//
// Will find A Completed Town Center
//==============================================================================
bool findACompletedTownCenter()
{
   bool retVal = false;
   static int townCenterQuery = -1;
   if (townCenterQuery < 0)
   {
      townCenterQuery=kbUnitQueryCreate("Completed Town Center Query");
      kbUnitQuerySetIgnoreKnockedOutUnits(townCenterQuery, true);
   }  
   //Define the query
   if (townCenterQuery != -1)
   {
      kbUnitQuerySetPlayerRelation(townCenterQuery, -1);
      kbUnitQuerySetPlayerID(townCenterQuery, cMyID);
      kbUnitQuerySetUnitType(townCenterQuery, cUnitTypeTownCenter);
      kbUnitQuerySetState(townCenterQuery, cUnitStateAny);
      kbUnitQuerySetAscendingSort(townCenterQuery, true);   // Ascending distance from initial location	  
   }  
   else
      return(retVal);

   // Run the query
   kbUnitQueryResetResults(townCenterQuery);
   int count = kbUnitQueryExecute(townCenterQuery);
   int tcID = kbUnitQueryGetResult(townCenterQuery, 0);  
   
   if (tcID >=0)
      retVal = true;

   return(retVal);
}

//==============================================================================
/* townCenterComplete
   
   Wait until the town center is complete, then build other stuff next to it.
   In a start with a TC, this will fire very quickly.
   In a scenario with no TC, we do the best we can.

*/
//==============================================================================
rule townCenterComplete
inactive
minInterval 15
{
   // First, create a query if needed, then use it to look for a completed town center
   static int townCenterQuery = -1;
   if (townCenterQuery < 0)
   {
      townCenterQuery=kbUnitQueryCreate("Completed Town Center Query");
      kbUnitQuerySetIgnoreKnockedOutUnits(townCenterQuery, true);
      if (townCenterQuery < 0)
         aiEcho("****  Query create failed in townCenterComplete.");
	   //Define the query
	   if (townCenterQuery != -1)
	   {
		   kbUnitQuerySetPlayerID(townCenterQuery, cMyID);
         kbUnitQuerySetUnitType(townCenterQuery, cUnitTypeTownCenter);
         kbUnitQuerySetState(townCenterQuery, cUnitStateAlive);
	   }
   }

   // Run the query
   kbUnitQueryResetResults(townCenterQuery);
   int count = kbUnitQueryExecute(townCenterQuery);

   //-- If our startmode is one without a TC, wait until a TC is found.
	if ((count < 1) && (gStartMode != cStartModeScenarioNoTC) )
      return;
   
   int tcID = kbUnitQueryGetResult(townCenterQuery, 0);
   aiEcho("New TC is "+tcID+" at "+kbUnitGetPosition(tcID));
   

   if (tcID >= 0)
   {
      int tcBase = kbUnitGetBaseID(tcID);
      gMainBase = kbBaseGetMainID(cMyID);
      aiEcho(" TC base is "+tcBase+", main base is "+gMainBase);
      // We have a TC.  Make sure that the main base exists, and it includes the TC
      if ( gMainBase < 0 )
      {  // We have no main base, create one
         gMainBase = createMainBase(kbUnitGetPosition(tcID));
         aiEcho(" We had no main base, so we created one: "+gMainBase);
      }
      tcBase = kbUnitGetBaseID(tcID);  // in case base ID just changed
      if ( tcBase != gMainBase ) 
      {
         aiEcho(" TC "+tcID+" is not in the main base ("+gMainBase+".");
         aiEcho(" Setting base "+gMainBase+" to non-main, setting base "+tcBase+" to main.");
         kbBaseSetMain(cMyID, gMainBase, false);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHuntAggressive, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, gMainBase);
         aiRemoveResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, gMainBase);
         aiRemoveResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, gMainBase);
         kbBaseSetMain(cMyID, tcBase, true);         
         gMainBase = tcBase;
      }
   }
   else
   {
      aiEcho("No TC, leaving main base as it is.");
   }
   
   kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 2000.0);

   
   // Set up the escrows
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceFood, .70);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceWood, .50);   
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceGold, .30);
   kbEscrowSetPercentage(cEconomyEscrowID, cResourceShips, 0.0);
   kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 200);
   kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 200);
   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
   {
      kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 700); // Needed for banks
      kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 700);
   } 
   kbEscrowSetCap(cEconomyEscrowID, cResourceGold, 200);
   
   
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFood, .0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceWood, .50);  
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceGold, .0);
   kbEscrowSetPercentage(cMilitaryEscrowID, cResourceShips, 0.0);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceFood, 300);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceWood, 300);
   kbEscrowSetCap(cMilitaryEscrowID, cResourceGold, 300);
    
   kbEscrowCreate("VP Site", cResourceFood, .25, cRootEscrowID);     // Add an accelerator escrow
   gVPEscrowID = kbEscrowGetID("VP Site");   
   
   kbEscrowSetPercentage(gVPEscrowID, cResourceFood, 0.0);        
   kbEscrowSetPercentage(gVPEscrowID, cResourceWood, 0.0);        
   kbEscrowSetPercentage(gVPEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(gVPEscrowID, cResourceShips, 0.0);
   kbEscrowSetCap(gVPEscrowID, cResourceFood, 0);
   kbEscrowSetCap(gVPEscrowID, cResourceWood, 300);
   kbEscrowSetCap(gVPEscrowID, cResourceGold, 300);
   
   kbEscrowCreate("Age Upgrade", cResourceShips, 0.0, cRootEscrowID);     // Add an upgrade escrow
   gUpgradeEscrowID = kbEscrowGetID("Age Upgrade");    
   
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceFood, 0.0);        
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceWood, 0.0);        
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceGold, 0.0);
   kbEscrowSetPercentage(gUpgradeEscrowID, cResourceShips, 0.0);
   kbEscrowSetCap(gUpgradeEscrowID, cResourceFood, 0.0);
   kbEscrowSetCap(gUpgradeEscrowID, cResourceWood, 0.0);
   kbEscrowSetCap(gUpgradeEscrowID, cResourceGold, 0.0);
   
   kbEscrowAllocateCurrentResources();
 
   // Town center found, start building the other buildings
   xsDisableSelf();
   xsEnableRuleGroup("tcComplete");

   if (kbGetCiv() == cCivOttomans)
      xsEnableRule("ottomanMonitor");
  
   gSettlerMaintainPlan = createSimpleMaintainPlan(gEconUnit, xsArrayGetInt(gTargetSettlerCounts, kbGetAge()), true, kbBaseGetMainID(cMyID), 1);   
   if (kbGetCiv() == cCivOttomans)
      aiPlanSetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0, 0); // To not throw off resource planning
   
   if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)
   {      
      gWaterTransportUnitMaintainPlan = createSimpleMaintainPlan(gCaravelUnit, 2, true, kbBaseGetMainID(cMyID), 1);      
      xsEnableRule("navyManager");
      navyManager();
   }

   if (aiGetGameMode() == cGameModeDeathmatch)
      deathMatchSetup();   // Add a bunch of custom stuff for a DM jump-start.

   if (kbUnitCount(cMyID, cUnitTypeypDaimyoRegicide, cUnitStateAlive) > 0)   
      xsEnableRule("regicideMonitor");
      
   if ( (cRandomMapName=="Honshu" || cRandomMapName=="HonshuRegicide") || (cRandomMapName=="Ceylon") )
   {
      createSimpleBuildPlan(gDockUnit, 1, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      xsEnableRule("navyManager");
   }
   
   if ( (getAllyCount() > 0) && (civIsInAllyTeam(cCivJapanese) == true) )
      gJapaneseIsAlly = true;
   else
      gJapaneseIsAlly = false;

    if ( (getAllyCount() > 0) && (civIsInAllyTeam(cCivIndians) == true) )
      gIndianIsAlly = true;
   else
      gIndianIsAlly = false;

    if ( (getAllyCount() > 0) && (civIsInEnemyTeam(cCivJapanese) == true) )
      gJapaneseIsEnemy = true;
   else
      gJapaneseIsEnemy = false;   
}


rule useFactoryWagons
inactive
minInterval 25
{

   int wagon = getUnit(cUnitTypeFactoryWagon, cMyID, cUnitStateAlive);
   
   // Check if we have a factory wagon, but no factory build plan....
   if ( (wagon >= 0) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeFactory) < 0) )
   {
      int planID = createSimpleBuildPlan(cUnitTypeFactory, 1, 50, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0); //No settler builders
      aiPlanAddUnitType(planID, cUnitTypeFactoryWagon, 1, 1, 1);
   }
}

rule useRicePaddyWagons
inactive
minInterval 25
{
   // Use rice paddy wagons   
   int wagon = getUnit(cUnitTypeYPRicePaddyWagon, cMyID, cUnitStateAlive);
   
   // Check if we have a rice paddy wagon, but no build plan....
   if ( (wagon >= 0) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypRicePaddy) < 0) )
   {
      int planID = createSimpleBuildPlan(cUnitTypeypRicePaddy, 1, 50, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);  // No settler builders
      aiPlanAddUnitType(planID, cUnitTypeYPRicePaddyWagon, 1, 1, 1);
   }
}

rule useCoveredWagons
inactive
minInterval 15
{   
   int coveredWagon = -1;

   int planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeTownCenter);  
   if  ( (planID >= 0) && (aiPlanGetState(planID) != cPlanStateBuild) )
   {  aiPlanDestroy(planID);  }

   
   static int coveredwagonQuery = -1;
   coveredwagonQuery = createSimpleQuery(cMyID, gCoveredWagonUnit, cUnitStateAlive);
   kbUnitQueryResetResults(coveredwagonQuery);
   int wagonCount = kbUnitQueryExecute(coveredwagonQuery);
   float searchRange = 200.0 + 50*cNumberPlayers;
   static vector lastTCLoc = cInvalidVector;
   int j = 0;
   for (j=0; <wagonCount)
   {   
      coveredWagon = kbUnitQueryGetResult(coveredwagonQuery, j);
      // We need to figure out where to put the new TC.  Start with the current main base as an anchor.
      // From that, check all gold mines within 100 meters and on the same area group.  For each, see if there
      // is a TC nearby, if not, do it.  
      // If all gold mines fail, use the main base location and let it sort it out in the build plan, i.e. TCs repel, gold attracts, etc.
      static int mineQuery = -1;		
      mineQuery = createSimpleLocationQuery(0, cUnitTypeAbstractMine, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), searchRange);
      kbUnitQueryResetResults(mineQuery);
      int mineCount = kbUnitQueryExecute(mineQuery);
      int i = 0;
      int mineID = -1;
      vector loc = cInvalidVector;
      int mineAreaGroup = -1;
      int mainAreaGroup = kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      bool found = false;
      aiEcho("**** Starting TC placement search, found "+mineCount+" mines.");
      for (i=0; < mineCount)
      {  // Check each mine for a nearby TC, i.e. w/in 30 meters.
	 mineID = kbUnitQueryGetResult(mineQuery, i);
	 loc = kbUnitGetPosition(mineID);
	 if ((lastTCLoc != cInvalidVector)&&(distance(lastTCLoc, loc) < 30.0))
	   continue;
	 mineAreaGroup = kbAreaGroupGetIDByPosition(loc);
	 if ( (getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationAny, cUnitStateABQ, loc, 30.0) < 0) && (mineAreaGroup == mainAreaGroup) )
	 {
	    aiEcho("Found good mine at "+loc);
	    found = true;
	    lastTCLoc = loc;
	    break;
	 }
	 else
	 {
	    aiEcho("Ignoring mine at "+loc);
	 }
      }
      
      // If we found a mine without a nearby TC, use that mine's location.  If not, use the main base.
      if (found == false)
	loc = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
      
      gTCSearchVector = loc;
      
      aiEcho("Moving wagon to "+gTCSearchVector);
      //aiTaskUnitMove(coveredWagon, gTCSearchVector);
      startTCBuildPlan(gTCSearchVector); 
    }     
}

rule reInitGatherers
inactive
group tcComplete
minInterval 1
{
   int numCrates = -1;
   
   
   numCrates = kbUnitCount(cMyID, cUnitTypeAbstractResourceCrate,cUnitStateAlive) + kbUnitCount(0, cUnitTypeAbstractResourceCrate,cUnitStateAlive);
   if (numCrates > 0)
     return;
	 else
{
   updateFoodBreakdown();     // Reinit each gatherer breakdown in case initial pass didn't yet have proper "actual" assignments.
   updateWoodBreakdown();
   updateGoldBreakdown();
   xsDisableSelf();
}
}

vector shrineBuildPlaceSearch(void)
{
   vector loc = cInvalidVector;
   bool found = false;
   int numHuntableThere = 0;
   int numShrineThere = 0;
   int j = 0;
   int i = 0;

   static int huntableQuery = -1;
   huntableQuery = createSimpleQuery(0, cUnitTypeHuntable, cUnitStateAlive);
   kbUnitQueryResetResults(huntableQuery);
   int huntableCount = kbUnitQueryExecute(huntableQuery);
   int numStart = aiRandInt(huntableCount);
   int numRand = aiRandInt(huntableCount);
   int huntableID = -1;
   for (j=numStart; < numStart + huntableCount)
   {
      if (j >= huntableCount)
	i = j - huntableCount;
      else
	i = j;
      huntableID = kbUnitQueryGetResult(huntableQuery, i);
      loc = kbUnitGetPosition(huntableID);		
      numHuntableThere = getUnitCountByLocation(cUnitTypeHuntable, 0, cUnitStateAlive, loc, 8.0);
      numShrineThere = getUnitCountByLocation(cUnitTypeypShrineJapanese, cMyID, cUnitStateABQ, loc, 8.0);
      if (numHuntableThere < (numShrineThere * 4))
	continue; 				    
      if ((getAllyCount() > 0)&&(getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationAlly, cUnitStateAlive, loc, 120.0) >= 0))
	continue; 
      if (getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationEnemyNotGaia, cUnitStateAlive, loc, 40.0) >= 0)
	continue; 
      if (getUnitByLocation(cUnitTypeFortFrontier, cPlayerRelationEnemyNotGaia, cUnitStateAlive, loc, 40.0) >= 0)  
	continue;           
      if (getUnitByLocation(cUnitTypeMilitaryBuilding, cPlayerRelationEnemyNotGaia, cUnitStateAlive, loc, 40.0) >= 0)  
	continue;         
      found = true;
       break;	
   }      
   if (found == false)
     loc = cInvalidVector;

   return(loc);
}

//==============================================================================
/* House monitor

   Make sure we have a house build plan active, regardless of the number of houses.
*/
//==============================================================================
rule houseMonitor
inactive
group tcComplete
minInterval 10
{  
   //if ( (kbGetCiv() == cCivXPSioux) && (kbUnitCount(cMyID, gMarketUnit, cUnitStateAlive) > 0) )
   //   return;  
   
  // if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) >= 3))
  //    return;  // Dutch need bank before getting extra houses
 
   /* if ( (kbGetCiv() != cCivBritish)||(kbGetCiv() != cCivJapanese) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) == 1)  && (kbGetAge() < cAge2))
      return; 
	  
	  
   if ((kbGetCiv() != cCivBritish)||(kbGetCiv() != cCivJapanese) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) >= 1)  && (kbGetAge() < cAge2))
      return;  */
	  
   //if ((kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) > 2) && ((kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) < 1)
   //||(kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) < 1)))
   //   return;  

   int marketBuildPlanID = -1; 
   int houseBuildPlanID = -1;
   static int lastHousePlanTime = 0;
   static int lastShrineTime = 0;
   static bool housePlaceDetermined = false;
   static vector housePosition = cInvalidVector;

   //at first, determine the place.
   if (housePlaceDetermined == false)
   {
      static bool placeFound = true;
      int offSet = 45;
      vector myTCLocation = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
      vector normalVec = xsVectorNormalize(myTCLocation - kbGetMapCenter());
      if ((getAllyCount()>0)&&(cRandomMapName=="northwest territory"))
        normalVec = xsVectorNormalize(kbUnitGetPosition(getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID))-myTCLocation);
		
      housePosition = myTCLocation + normalVec * offSet;
		
      if ( (getAllyCount()>0) && ((cRandomMapName=="california") || (cRandomMapName=="carolina") || (cRandomMapName=="araucania")) )
      {
	 if (getUnitCountByLocation(cUnitTypeTownCenter, cPlayerRelationAlly, cUnitStateABQ, housePosition, 40.0) > 0)
	 {
	    normalVec = xsVectorNormalize(myTCLocation-kbUnitGetPosition(getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID)));
	    housePosition = myTCLocation + normalVec * offSet;
            gHousePosition = housePosition;
	 }
      }
		
      while ( (kbAreaGroupGetIDByPosition(housePosition) != kbAreaGroupGetIDByPosition(myTCLocation)) || (xsVectorGetY(housePosition) != xsVectorGetY(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) ) )
      {  
	 offSet = offSet - 1;
	 housePosition = myTCLocation + (normalVec * offSet);
	 if (offSet < 5)
	 {
	    placeFound = false;
	    break; 
	 }
      }
      housePlaceDetermined = true;
    }

  //  if ( (placeFound == true) && (xsGetTime() > 30*1000) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) > 0) )
 //	placeFound = false;    
			

    // market build plan is dealt with also here, to use the house build place. 
    marketBuildPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gMarketUnit);
    if ((marketBuildPlanID < 0) && (kbUnitCount(cMyID, gMarketUnit, cUnitStateABQ) < 1) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) > 1)) // (kbGetPop() > 15))
    {       
       if (placeFound == true)
	 marketBuildPlanID = createLocationBuildPlan(gMarketUnit, 1, 100, true, cEconomyEscrowID, housePosition, 1);
       else
	 marketBuildPlanID = createSimpleBuildPlan(gMarketUnit, 1, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
       aiEcho("Starting a market build plan.");
       return;
    }

    ////////then, with house build plan./////////

    if (kbGetCiv() == cCivXPSioux)
    {
       xsSetRuleMinIntervalSelf(30); 
       return;
    }
 
    if (kbGetBuildLimit(cMyID, gHouseUnit) < kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive))
      return;     // Don't build if we're at limit.  
   
    //Japanese shrine boom.
    if ( ((kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy)) )
    {
       houseBuildPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit);
       if ((houseBuildPlanID >= 0) && (xsGetTime() - lastShrineTime > 90000) && (lastShrineTime > 0))
       {
	  aiPlanDestroy(houseBuildPlanID);
	  houseBuildPlanID = -1;
       }
       if ((aiGetFallenExplorerID() < 0)||
	   (kbUnitIsType(aiGetFallenExplorerID(), cUnitTypeypMonkJapanese) == false)||
	   (kbUnitIsType(aiGetFallenExplorerID(), cUnitTypeypMonkJapanese2) == false))
       {
	  if ((agingUpToOrAbove(cAge2) == false) ||
	      (agingUpToOrAbove(cAge2) == true))
	  {			
	     vector shrineBuildPlace = shrineBuildPlaceSearch();
	     int numHuntableThere = getUnitCountByLocation(cUnitTypeHuntable, 0, cUnitStateAlive, shrineBuildPlace, 8.0);
	     int numShrineThere = getUnitCountByLocation(cUnitTypeypShrineJapanese, cMyID, cUnitStateABQ, shrineBuildPlace, 8.0);
	     if ( (shrineBuildPlace != cInvalidVector) &&
	          (numHuntableThere >= (numShrineThere * 4)))// &&
	         // (getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, shrineBuildPlace, 300.0) < 1) )
	     {
	        houseBuildPlanID = aiPlanCreate("shrineBuildPlanID ", cPlanBuild);	
	        aiPlanSetVariableInt(houseBuildPlanID, cBuildPlanBuildingTypeID, 0, gHouseUnit);	
	        aiPlanSetVariableVector(houseBuildPlanID, cBuildPlanCenterPosition, 0, shrineBuildPlace);
	        aiPlanSetVariableFloat(houseBuildPlanID, cBuildPlanCenterPositionDistance, 0, 600.0);
	        aiPlanAddUnitType(houseBuildPlanID, cUnitTypeAbstractJapaneseMonk, 1, 1, 1);
	        aiPlanSetMilitary(houseBuildPlanID, false);
	        aiPlanSetEconomy(houseBuildPlanID, true);	
	        aiPlanSetEscrowID(houseBuildPlanID, cEconomyEscrowID);
	        aiPlanSetDesiredPriority(houseBuildPlanID, 96);
	        aiPlanSetActive(houseBuildPlanID);
	        aiEcho("Starting a shrine build plan.");
	        //lastHousePlanTime = xsGetTime();				
	        lastShrineTime = xsGetTime();
	     }	
          }		
       }
       if ( (kbGetAge() < cAge2) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < 1) )
       {
          if (placeFound == true)
	     houseBuildPlanID = createLocationBuildPlan(gHouseUnit, 1, 90, true, cEconomyEscrowID, housePosition, 1);
	  else
	     houseBuildPlanID = createSimpleBuildPlan(gHouseUnit, 1, 89, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	  lastShrineTime = xsGetTime();
          return;
       }
       if (kbGetAge() >= cAge2)
       {
          if (placeFound == true)
	    houseBuildPlanID = createLocationBuildPlan(gHouseUnit, 1, 99, true, cEconomyEscrowID, housePosition, 1);
          else
	    houseBuildPlanID = createSimpleBuildPlan(gHouseUnit, 1, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
          lastHousePlanTime = xsGetTime();
          aiEcho("Starting a house build plan.");
          return;
       }    
       return;
    }
	
    int count = kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive);
    int max = kbGetBuildLimit(cMyID, gHouseUnit);
   
    count = max - count; // Count is number needed.
    if (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit) >= 0)
       count = count - 1;
    if (cMyCiv == cCivXPSioux)
       count = 0;
    
    houseBuildPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit);
    if ((houseBuildPlanID >= 0) && (xsGetTime() - lastHousePlanTime > 120000) && (lastHousePlanTime > 0))
    {
       aiPlanDestroy(houseBuildPlanID);
       houseBuildPlanID = -1;
    }   

    if ( (kbGetCiv() == cCivBritish) && (houseBuildPlanID < 0)) // && (count > 0 ) && (gInitialStrategy != 1) )
    {      
       if (placeFound == true)
         houseBuildPlanID = createLocationBuildPlan(gHouseUnit, count, 100, true, cEconomyEscrowID, housePosition, 1);
       else
	 houseBuildPlanID = createSimpleBuildPlan(gHouseUnit, count, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
       lastHousePlanTime = xsGetTime();
       aiEcho("Starting a house build plan.");
       return;		
    } 

       if ((houseBuildPlanID < 0) && (kbGetAge() == cAge1) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < 1))
    {
       if (placeFound == true)
	 houseBuildPlanID = createLocationBuildPlan(gHouseUnit, 1, 99, true, cEconomyEscrowID, housePosition, 1);
       else
	 houseBuildPlanID = createSimpleBuildPlan(gHouseUnit, 1, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
       lastHousePlanTime = xsGetTime();
       aiEcho("Starting a house build plan.");
       return;
    }
	else if ((houseBuildPlanID < 0) && (kbGetAge() == cAge1) && (agingUp() == true)  && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < 3))
    {
       if (placeFound == true)
	 houseBuildPlanID = createLocationBuildPlan(gHouseUnit, 1, 99, true, cEconomyEscrowID, housePosition, 1);
       else
	 houseBuildPlanID = createSimpleBuildPlan(gHouseUnit, 1, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
       lastHousePlanTime = xsGetTime();
       aiEcho("Starting a house build plan.");
       return;
    }
	else
	if ( (houseBuildPlanID < 0) && ( (kbGetPopCap()-kbGetPop()) < 30)) // ((30*kbGetAge()) - 30) ) && (kbGetAge() > cAge1)) // + (30*kbGetAge())) ) )
    {
       if (placeFound == true)
	 houseBuildPlanID = createLocationBuildPlan(gHouseUnit, 1, 99, true, cEconomyEscrowID, housePosition, 1);
       else
	 houseBuildPlanID = createSimpleBuildPlan(gHouseUnit, 1, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
       lastHousePlanTime = xsGetTime();
       aiEcho("Starting a house build plan.");
       return;
    }
	
	if ( (houseBuildPlanID < 0) && ( (kbGetPopCap()-kbGetPop()) < 30)) // ((30*kbGetAge()) - 30) ) && (kbGetAge() > cAge1)) // + (30*kbGetAge())) ) )
    {
       if (placeFound == true)
	 houseBuildPlanID = createLocationBuildPlan(gHouseUnit, 1, 99, true, cMilitaryEscrowID, housePosition, 1);
       else
	 houseBuildPlanID = createSimpleBuildPlan(gHouseUnit, 1, 99, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
       lastHousePlanTime = xsGetTime();
       aiEcho("Starting a house build plan.");
       return;
    }
}

//==============================================================================
/* Monastery monitor

   Make sure we have a Monastery around, and research healing upgrades for 
   Indians and Japanese. (All other upgrades are useless for the AI.)

*/
//==============================================================================
rule monasteryMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;

   // Disable rule for non-Asian civs
   if (civIsAsian() == false)
   {
      xsDisableSelf();
      return;
   }
   
   // Research monk for Chinese, Indians and Japanese
   if (kbTechGetStatus(cTechypMonasteryCriticalUpgrade) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryCriticalUpgrade);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryCriticalUpgrade, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryAttackSpeed) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryAttackSpeed);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryAttackSpeed, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryShaolinWarrior) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryShaolinWarrior);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryShaolinWarrior, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryDiscipleAura) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryDiscipleAura);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryDiscipleAura, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryImprovedHealing) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryImprovedHealing);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryImprovedHealing, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryStompUpgrade) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryStompUpgrade);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryStompUpgrade, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryIndianSpeed) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryIndianSpeed);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryIndianSpeed, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryJapaneseHealing) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryJapaneseHealing);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryJapaneseHealing, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryKillingBlowUpgrade) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryKillingBlowUpgrade);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryKillingBlowUpgrade, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryJapaneseCombat) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryJapaneseCombat);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryJapaneseCombat, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMonasteryRangedSplash) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryRangedSplash);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMonasteryRangedSplash, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
      return;
   }
}


//==============================================================================
/* BHG Consulate Japanese monitor

   Make sure we have a Consulate around.
   Research Consulate Techs as appropriate.

*/
//==============================================================================
rule consulateJapaneseMonitor
inactive
group tcComplete
minInterval 40
{
   // Disable rule for other civilizations
   if ((kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) && (cvOkToBuildConsulate == false)) 
   {
      xsDisableSelf();
      return;
   }
    
   if (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < 1)
      return;

   // Build a consulate if there is none
   //if ((kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypConsulate) < 0))
  // {
  //    createSimpleBuildPlan(cUnitTypeypConsulate, 1, 90, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
 //     aiEcho("Starting a new consulate build plan.");
 //  }

   static bool consulateTechObtainedBank = false;
   static bool consulateTechObtainedChurch = false;
   static bool consulateTechObtainedArsenal = false;
   static bool consulateTechObtainedFishingBoats = false;

   ////////////////////choose a flag////////////////////////////
   int upgradePlanID = -1;

   if (btRushBoom <= 0.0)
   {
     if ((kbGetAge() < cAge4)&&(xsGetTime() <= 900000))
       createSimpleResearchPlan(cTechypBigConsulatePortuguese, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 100);
     if (((kbGetAge() >= cAge4)&&(xsGetTime() > 780000))||(xsGetTime() > 900000))
       createSimpleResearchPlan(cTechypBigConsulateDutch, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 100);
   }
   else 
   {
     if ((kbGetAge() < cAge3)&&(xsGetTime() <= 900000))
       createSimpleResearchPlan(cTechypBigConsulatePortuguese, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 80);
     if ((kbGetAge() >= cAge3)||(kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive) > 15)||(xsGetTime() > 900000))
       createSimpleResearchPlan(cTechypBigConsulateDutch, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 80);
   } 
	
   if (consulateTechObtainedChurch == true)
   {
     createSimpleResearchPlan(cTechypBigConsulateSpanish, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 60);
     createSimpleResearchPlan(cTechypBigConsulateJapanese, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 60);	
     xsSetRuleMinIntervalSelf(60);
   }


   if (consulateTechObtainedFishingBoats == false)
   {
      if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) <= 0)
        consulateTechObtainedFishingBoats = true;
      if (gFishingBoatMaintainPlan >= 0)
        consulateTechObtainedFishingBoats = true;		 
      if (kbUnitCount(cMyID, cUnitTypeAbstractFishingBoat, cUnitStateAlive) > 0)
        consulateTechObtainedFishingBoats = true;
      if (consulateTechObtainedFishingBoats == true)
        return;
      if (kbTechGetStatus(cTechypConsulatePortugueseFishingFleet) == cTechStatusObtainable)
      {
	 upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulatePortugueseFishingFleet);
	 if (upgradePlanID >= 0)
	   aiPlanDestroy(upgradePlanID);
	 createSimpleResearchPlan(cTechypConsulatePortugueseFishingFleet, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 100);
      }
      return;       	   
   }
	
   if (consulateTechObtainedBank == false)
   {
      if ((kbUnitCount(cMyID, cUnitTypeypBankAsian, cUnitStateAny) > 0)||(kbUnitCount(cMyID, cUnitTypeypBankWagon, cUnitStateAny) > 0))
        consulateTechObtainedBank = true;
      if (consulateTechObtainedBank == true)
        return;
      if (kbTechGetStatus(cTechypConsulateDutchSaloonWagon) == cTechStatusObtainable)
      {
	 upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchSaloonWagon);
	 if (upgradePlanID >= 0)
           aiPlanDestroy(upgradePlanID);
         createSimpleResearchPlan(cTechypConsulateDutchSaloonWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 100);
      }
      return;
   }

	if (consulateTechObtainedArsenal == false)
	{
		if ((kbUnitCount(cMyID, cUnitTypeypArsenalAsian, cUnitStateAny) > 0)||(kbUnitCount(cMyID, cUnitTypeypArsenalWagon, cUnitStateAny) > 0))
			consulateTechObtainedArsenal = true;
        if (consulateTechObtainedArsenal == true)
		    return;
		if (kbTechGetStatus(cTechypConsulateDutchArsenalWagon) == cTechStatusObtainable)
		{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchArsenalWagon);
			if (upgradePlanID >= 0)
				aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechypConsulateDutchArsenalWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 70);
		}
		return;
    }
 
	if (consulateTechObtainedChurch == false)
	{
		if ((kbUnitCount(cMyID, cUnitTypeypChurch, cUnitStateAny) > 0)||(kbUnitCount(cMyID, cUnitTypeypChurchWagon, cUnitStateAny) > 0))
			consulateTechObtainedChurch = true;
		if (consulateTechObtainedChurch == true)
			return;	
		if (kbTechGetStatus(cTechypConsulateDutchChurchWagon) == cTechStatusObtainable)
		{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchChurchWagon);
			if (upgradePlanID >= 0)
				aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechypConsulateDutchChurchWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 70);
		}
		return;
	}
	 			 		 
	if ((kbTechGetStatus(cTechypConsulateJapaneseKoujou) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateAlive) >= 3))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateJapaneseKoujou);
		if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypConsulateJapaneseKoujou, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 70);
		return;
	}			 		 
	if (kbTechGetStatus(cTechypConsulateJapaneseMasterTraining) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateJapaneseMasterTraining);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateJapaneseMasterTraining, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }
   ///////////////////////// choose a flag /////////////////////////

  
   ////// Maximize export generation in Age 4 and above/////////////   
   /*static bool tacticTax10Set = false;
   if ((kbGetAge() >= cAge4) && (getHighestResourceAmount() > 5300) && (tacticTax10Set == false))
   {
      int consulateQueryID = -1;
       
      consulateQueryID = kbUnitQueryCreate("consulateGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(consulateQueryID, true);
      
      //Define a query to get consulate
      if (consulateQueryID != -1)
      {
         kbUnitQuerySetPlayerRelation(consulateQueryID, -1);
         kbUnitQuerySetPlayerID(consulateQueryID, cMyID);
         kbUnitQuerySetUnitType(consulateQueryID, cUnitTypeypConsulate);
         kbUnitQuerySetState(consulateQueryID, cUnitStateAlive);
         kbUnitQueryResetResults(consulateQueryID);
         int numberFound = kbUnitQueryExecute(consulateQueryID);

         // Set export gathering rate to +60 %
         if (numberFound > 0)
         {
            aiUnitSetTactic(kbUnitQueryGetResult(consulateQueryID, 0), cTacticTax10);
	    tacticTax10Set = true;
         }
      }
   }*/
   ////// Maximize export generation in Age 4 and above/////////////
   
   xsEnableRule("brigadeMonitor");  
  // xsEnableRule("consulateTechnologiesMonitor");
}

//==============================================================================
/* BHG Consulate Chinese monitor

   Make sure we have a Consulate around.
   Research Consulate Techs as appropriate.

*/
//==============================================================================
rule consulateChineseMonitor
inactive
group tcComplete
minInterval 40
{
    // Disable rule for other civilizations
    if ((kbGetCiv() != cCivChinese) && (kbGetCiv() != cCivSPCChinese) && (cvOkToBuildConsulate == false))
    {
       xsDisableSelf();
       return;
    }

    if (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < 1)
      return;

    // Build a consulate if there is none
    //if ((kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypConsulate) < 0))
   // {
   //   createSimpleBuildPlan(cUnitTypeypConsulate, 1, 90, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
    //  aiEcho("Starting a new consulate build plan.");
   // }
    
    static bool consulateTechObtainedFort = false;
    static bool consulateTechObtainedFactory = false;
    
    /////////// choose a consulate flag////////////////

    int upgradePlanID = -1;
      
    createSimpleResearchPlan(cTechypBigConsulateFrench, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 90);

    if (kbTechGetStatus(cTechypBigConsulateFrench) == cTechStatusActive)	
    {
	if (kbTechGetStatus(cTechypConsulateFrenchCoinCrates) == cTechStatusObtainable)
	{
	   upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchCoinCrates);
	   if (upgradePlanID >= 0)
	     aiPlanDestroy(upgradePlanID);
	     createSimpleResearchPlan(cTechypConsulateFrenchCoinCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 70);
	   return;
	}
        if (kbTechGetStatus(cTechypConsulateFrenchWoodCrates) == cTechStatusObtainable)
        {
           upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchWoodCrates);
           if (upgradePlanID >= 0)
             aiPlanDestroy(upgradePlanID);
             createSimpleResearchPlan(cTechypConsulateFrenchWoodCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
           return;
        }
	if (kbTechGetStatus(cTechypConsulateFrenchFoodCrates) == cTechStatusObtainable)
	{
	   upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchFoodCrates);
	   if (upgradePlanID >= 0)
	     aiPlanDestroy(upgradePlanID);
	     createSimpleResearchPlan(cTechypConsulateFrenchFoodCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 70);
	   return;
	}
    }

    if ((kbGetAge() < cAge4)&&(xsGetTime() < 780000))
      return;
		  
    createSimpleResearchPlan(cTechypBigConsulateRussians, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 80);
	//createSimpleResearchPlan(cTechypBigConsulateBritish, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 80);

    if ((kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAny) >= 1) || (kbUnitCount(cMyID, cUnitTypeFortWagon, cUnitStateAny) >=1))
      consulateTechObtainedFort = true;

    if (consulateTechObtainedFort == false)
    {
       if (kbTechGetStatus(cTechypConsulateRussianFortWagon) == cTechStatusObtainable)
       {
	  upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianFortWagon);
	  if (upgradePlanID >= 0)
	    aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechypConsulateRussianFortWagon, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 80);
	    //cvOkToBuildForts = true;
	  return;
       }
    }

    if ((kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAny) >= 1) || (kbUnitCount(cMyID, cUnitTypeFactoryWagon, cUnitStateAny) >= 1))
	  consulateTechObtainedFactory = true;

    if (consulateTechObtainedFactory == false)
    { 
       if (kbTechGetStatus(cTechypConsulateRussianFactoryWagon) == cTechStatusObtainable)
       {
	 upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianFactoryWagon);
	 if (upgradePlanID >= 0)
	   aiPlanDestroy(upgradePlanID);
	   createSimpleResearchPlan(cTechypConsulateRussianFactoryWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 80);
	   return;
       }
    }

    if (kbTechGetStatus(cTechypConsulateBritishRedcoats) == cTechStatusObtainable)
    {
       upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishRedcoats);
       if (upgradePlanID >= 0)
	 aiPlanDestroy(upgradePlanID);
	 upgradePlanID = createSimpleResearchPlan(cTechypConsulateBritishRedcoats, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 90);
	return;
    }
    if (kbTechGetStatus(cTechypConsulateBritishRogersRangers) == cTechStatusObtainable)
    {
	upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishRogersRangers);
	if (upgradePlanID >= 0)
	  aiPlanDestroy(upgradePlanID);
	  upgradePlanID = createSimpleResearchPlan(cTechypConsulateBritishRogersRangers, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 90);
	  return;
    }

    if ((consulateTechObtainedFactory == true) && (kbTechGetStatus(cTechypBigConsulateGermans) != cTechStatusActive))	
       createSimpleResearchPlan(cTechypBigConsulateGermans, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 80);

    if (kbTechGetStatus(cTechypBigConsulateGermans) == cTechStatusActive)
    {
       if (kbTechGetStatus(cTechypConsulateGermansFoodTrickle) == cTechStatusObtainable)
       {
	  upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansFoodTrickle);
	  if (upgradePlanID >= 0)
	    aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechypConsulateGermansFoodTrickle, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 90);	
	  return;
       }
       if (kbTechGetStatus(cTechypConsulateGermansWoodTrickle) == cTechStatusObtainable)
       {
          upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansWoodTrickle);
          if (upgradePlanID >= 0)       	
	    aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechypConsulateGermansWoodTrickle, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 90);
	  return;
       }
       if (kbTechGetStatus(cTechypConsulateGermansCoinTrickle) == cTechStatusObtainable)
       {
          upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansCoinTrickle);
          if (upgradePlanID >= 0)
	    aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechypConsulateGermansCoinTrickle, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 90);
          return;
       }
       xsSetRuleMinIntervalSelf(60);
    }
    
    /////////// choose a consulate flag////////////////

   ////// Maximize export generation in Age 4 and above///////////////
   /*static bool tacticTax10Set = false;
   if ((kbGetAge() >= cAge4) && (getHighestResourceAmount() > 5300) && (tacticTax10Set == false))
   {
      int consulateQueryID = -1;
       
      consulateQueryID = kbUnitQueryCreate("consulateGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(consulateQueryID, true);
      
      //Define a query to get consulate
      if (consulateQueryID != -1)
      {
         kbUnitQuerySetPlayerRelation(consulateQueryID, -1);
         kbUnitQuerySetPlayerID(consulateQueryID, cMyID);
         kbUnitQuerySetUnitType(consulateQueryID, cUnitTypeypConsulate);
         kbUnitQuerySetState(consulateQueryID, cUnitStateAlive);
         kbUnitQueryResetResults(consulateQueryID);
         int numberFound = kbUnitQueryExecute(consulateQueryID);

         // Set export gathering rate to +60 %
         if (numberFound > 0)
         {
            aiUnitSetTactic(kbUnitQueryGetResult(consulateQueryID, 0), cTacticTax10);
	    tacticTax10Set = true;
         }
      }
   }*/
   ////// Maximize export generation in Age 4 and above///////////////
   
   xsEnableRule("brigadeMonitor");  
   //xsEnableRule("consulateTechnologiesMonitor");   
}
	
//==============================================================================
/* BHG Consulate Indians monitor

   Make sure we have a Consulate around.
   Research Consulate Techs as appropriate.

*/
//==============================================================================
rule consulateIndiansMonitor
inactive
group tcComplete
minInterval 40
{
   // Disable rule for other civilizations
   if ((kbGetCiv() != cCivIndians) && (kbGetCiv() != cCivSPCIndians) && (cvOkToBuildConsulate == false))
   {
      xsDisableSelf();
      return;
   }
   
   if (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < 1)
     return;

   // Build a consulate if there is none
  // if ((kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypConsulate) < 0))
   //{
   //   createSimpleBuildPlan(cUnitTypeypConsulate, 1, 90, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
   //   aiEcho("Starting a new consulate build plan.");
   //}


    static bool consulateTechObtainedVillagers = false;
    static bool consulateTechObtainedFishingBoat = false;
  

    ////////////choose a consulate flag/////////////////////////
    int upgradePlanID = -1;

    if (gGoodFishingMap == true)
      createSimpleResearchPlan(cTechypBigConsulatePortuguese, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 100);
				
    if ((kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0) && (gFishingBoatMaintainPlan < 0) && (consulateTechObtainedFishingBoat == false))
    {
       if (kbUnitCount(cMyID, cUnitTypeAbstractFishingBoat, cUnitStateAny) > 0) 
	   consulateTechObtainedFishingBoat = true;

       if (consulateTechObtainedFishingBoat == true)
	  return;

       if (kbTechGetStatus(cTechypConsulatePortugueseFishingFleet) == cTechStatusObtainable)
       {
	  upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulatePortugueseFishingFleet);
	  if (upgradePlanID >= 0)
	    aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechypConsulatePortugueseFishingFleet, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 100);		
       }
       return;
    }

    /*if ((consulateTechObtainedVillagers == false) && (xsGetTime() < 60*1000*10))
    {
       if (kbUnitCount(cMyID, cUnitTypeSettler, cUnitStateAny) >= 3)       
	  consulateTechObtainedVillagers = true;

       if (consulateTechObtainedVillagers == true)
	     return;

       bool permission = false;
       if (gInitialStrategy <= 2)
	 if ((kbGetAge() >= cAge3)||((kbGetAge() == cAge2)&&(agingUpTo(cAge3)==true)))
	   permission = true;
       if (gInitialStrategy > 2)
	 if ((kbGetAge() >= cAge4)||((kbGetAge() == cAge3)&&(agingUpTo(cAge4)==true)))
	   permission = true;

       if (permission == true)
       {
	  createSimpleResearchPlan(cTechypBigConsulateOttomans, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 60); 
	  if (kbTechGetStatus(cTechypConsulateOttomansInfantrySpeed) == cTechStatusObtainable)
	  {
	     upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateOttomansInfantrySpeed);
	     if (upgradePlanID >= 0)
	       aiPlanDestroy(upgradePlanID);
	       createSimpleResearchPlan(cTechypConsulateOttomansInfantrySpeed, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 100);
	  }
       }
       return;
    }*/

    if (kbTechGetStatus(cTechypBigConsulateFrench) != cTechStatusActive)
    {
       createSimpleResearchPlan(cTechypBigConsulateFrench, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 60);
       //createSimpleResearchPlan(cTechypBigConsulateBritish, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 60);
       return;
    }

    xsSetRuleMinIntervalSelf(60);	

   if (kbTechGetStatus(cTechypConsulateOttomansSettlerCombat) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateOttomansSettlerCombat);
      if (upgradePlanID >= 0)
	aiPlanDestroy(upgradePlanID);
	createSimpleResearchPlan(cTechypConsulateOttomansSettlerCombat, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateOttomansGunpowderSiege) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateOttomansGunpowderSiege);
      if (upgradePlanID >= 0)
        aiPlanDestroy(upgradePlanID);
	createSimpleResearchPlan(cTechypConsulateOttomansGunpowderSiege, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   if (kbTechGetStatus(cTechypBigConsulateBritish) == cTechStatusActive)	
   {
      if (kbTechGetStatus(cTechypConsulateBritishRedcoats) == cTechStatusObtainable)
      {
         upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishRedcoats);
         if (upgradePlanID >= 0)
	   aiPlanDestroy(upgradePlanID);
	   upgradePlanID = createSimpleResearchPlan(cTechypConsulateBritishRedcoats, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 90);
         return;
      }	
      if (kbTechGetStatus(cTechypConsulateBritishRogersRangers) == cTechStatusObtainable)
      {
         upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishRogersRangers);
         if (upgradePlanID >= 0)
           aiPlanDestroy(upgradePlanID);
           upgradePlanID = createSimpleResearchPlan(cTechypConsulateBritishRogersRangers, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 90);
         return;
      }	
   }
   if (kbTechGetStatus(cTechypBigConsulateFrench) == cTechStatusActive)	
   {
	if (kbTechGetStatus(cTechypConsulateFrenchCoinCrates) == cTechStatusObtainable)
	{
	   upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchCoinCrates);
	   if (upgradePlanID >= 0)
	     aiPlanDestroy(upgradePlanID);
	     createSimpleResearchPlan(cTechypConsulateFrenchCoinCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 70);
	   return;
	}
        if (kbTechGetStatus(cTechypConsulateFrenchWoodCrates) == cTechStatusObtainable)
        {
           upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchWoodCrates);
           if (upgradePlanID >= 0)
             aiPlanDestroy(upgradePlanID);
             createSimpleResearchPlan(cTechypConsulateFrenchWoodCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
           return;
        }
	if (kbTechGetStatus(cTechypConsulateFrenchFoodCrates) == cTechStatusObtainable)
	{
	   upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchFoodCrates);
	   if (upgradePlanID >= 0)
	     aiPlanDestroy(upgradePlanID);
	     createSimpleResearchPlan(cTechypConsulateFrenchFoodCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 70);
	   return;
	}
   }

   /////////////choose a consulate flag/////////////////////////		 


   ////// Maximize export generation in Age 4 and above///////////////
  /* static bool tacticTax10Set = false;
   if ((kbGetAge() >= cAge4) && (getHighestResourceAmount() > 5300) && (tacticTax10Set == false))
   {
      int consulateQueryID = -1;
       
      consulateQueryID = kbUnitQueryCreate("consulateGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(consulateQueryID, true);
      
      //Define a query to get consulate
      if (consulateQueryID != -1)
      {
         kbUnitQuerySetPlayerRelation(consulateQueryID, -1);
         kbUnitQuerySetPlayerID(consulateQueryID, cMyID);
         kbUnitQuerySetUnitType(consulateQueryID, cUnitTypeypConsulate);
         kbUnitQuerySetState(consulateQueryID, cUnitStateAlive);
         kbUnitQueryResetResults(consulateQueryID);
         int numberFound = kbUnitQueryExecute(consulateQueryID);

         // Set export gathering rate to +60 %
         if (numberFound > 0)
         {
            aiUnitSetTactic(kbUnitQueryGetResult(consulateQueryID, 0), cTacticTax10);
			tacticTax10Set = true;
         }
      }
   }*/
   ////// Maximize export generation in Age 4 and above///////////////
   xsEnableRule("brigadeMonitor");  
   //xsEnableRule("consulateTechnologiesMonitor");
}

rule consulateTechnologiesMonitor
inactive
minInterval 40
{
      
   // Research consulate technologies one at a time
   // Unavailable techs are simply ignored
   int upgradePlanID = -1;

   // British technologies
   // (Redcoats, RogersRangers, LifeGuards)
   if (kbTechGetStatus(cTechypConsulateBritishRedcoats) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishRedcoats);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateBritishRedcoats, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateBritishRogersRangers) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishRogersRangers);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateBritishRogersRangers, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateBritishLifeGuards) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishLifeGuards);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateBritishLifeGuards, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Dutch technologies
   // (bank wagon, arsenal wagon, church wagon)
   if (kbTechGetStatus(cTechypConsulateDutchSaloonWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchSaloonWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateDutchSaloonWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateDutchArsenalWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchArsenalWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateDutchArsenalWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateDutchChurchWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchChurchWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateDutchChurchWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }

   // French technologies
   // (WoodCrates, CoinCrates, FoodCrates)
   if (kbTechGetStatus(cTechypConsulateFrenchWoodCrates) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchWoodCrates);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateFrenchWoodCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateFrenchCoinCrates) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchCoinCrates);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateFrenchCoinCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateFrenchFoodCrates) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchFoodCrates);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateFrenchFoodCrates, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }

   // German technologies
   // (FoodTrickle, WoodTrickle, CoinTrickle)
   if (kbTechGetStatus(cTechypConsulateGermansFoodTrickle) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansFoodTrickle);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateGermansFoodTrickle, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateGermansWoodTrickle) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansWoodTrickle);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateGermansWoodTrickle, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateGermansCoinTrickle) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansCoinTrickle);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateGermansCoinTrickle, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }

   // Japanese isolation technologies
   // (Clan offerings, MasterTraining)
   if ((kbTechGetStatus(cTechypConsulateJapaneseKoujou) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateAlive) >= 5))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateJapaneseKoujou);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateJapaneseKoujou, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateJapaneseMasterTraining) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateJapaneseMasterTraining);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateJapaneseMasterTraining, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Ottoman technologies
   // (Great bombards)
   if (kbTechGetStatus(cTechypConsulateOttomansGunpowderSiege) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateOttomansGunpowderSiege);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateOttomansGunpowderSiege, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Portuguese technologies
   // (Ironclad, FishingFleet)
   if ((kbTechGetStatus(cTechypConsulatePortugueseExpeditionaryFleet) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag, cUnitStateAlive) > 0))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulatePortugueseExpeditionaryFleet);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulatePortugueseExpeditionaryFleet, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypConsulatePortugueseFishingFleet) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag, cUnitStateAlive) > 0))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulatePortugueseFishingFleet);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulatePortugueseFishingFleet, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }

   // Russian technologies
   // (fort wagon, factory wagon, blockhouse wagon)
   if (kbTechGetStatus(cTechypConsulateRussianFortWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianFortWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateRussianFortWagon, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateRussianFactoryWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianFactoryWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateRussianFactoryWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateRussianOutpostWagon) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianOutpostWagon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateRussianOutpostWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }

   // Spanish technologies
   // (Mercantilism, FasterShipments, EnhancedProfits)
   if (kbTechGetStatus(cTechypConsulateSpanishMercantilism) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateSpanishMercantilism);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateSpanishMercantilism, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateSpanishFasterShipments) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateSpanishFasterShipments);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateSpanishFasterShipments, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypConsulateSpanishEnhancedProfits) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateSpanishEnhancedProfits);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypConsulateSpanishEnhancedProfits, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
      return;
   }
}


//==============================================================================
/* BHG Rickshaw monitor

   If theres a rickshaw, try to use it

*/
//==============================================================================
rule rickshawMonitor
inactive
group tcComplete
minInterval 25
{ 
  if (civIsAsian() == false) { //don't need to be here unless we're Asian
    xsDisableSelf();
    return;
  }
  
  if (kbUnitCount(cMyID, cUnitTypeYPMilitaryRickshaw, cUnitStateAlive) > 0)
    createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
    
  if (kbUnitCount(cMyID, cUnitTypeYPDojoWagon, cUnitStateAlive) > 0)
    createSimpleBuildPlan(cUnitTypeypDojo, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
}


//==============================================================================
/* BHG regicide monitor

   Pop the regent in the castle

*/
//==============================================================================
rule regicideMonitor
inactive
minInterval 36
{ 
  //if the castle is up, put the guy in it
  
  if (kbUnitCount(cMyID, cUnitTypeypCastleRegicide, cUnitStateAlive) > 0) {
    //gotta find the castle
     static int castleQueryID=-1;
     //If we don't have the query yet, create one.
     if (castleQueryID < 0)
     {
        castleQueryID=kbUnitQueryCreate("castleGetUnitQuery");
        kbUnitQuerySetIgnoreKnockedOutUnits(castleQueryID, true);
     }
    //Define a query to get all matching units
    if (castleQueryID != -1) {
      kbUnitQuerySetPlayerRelation(castleQueryID, -1);
      kbUnitQuerySetPlayerID(castleQueryID, cMyID);
      kbUnitQuerySetUnitType(castleQueryID, cUnitTypeypCastleRegicide);
      kbUnitQuerySetState(castleQueryID, cUnitStateAlive);
    }
    else {
      return;
    }
    
    //gotta find the regent
     static int regentQueryID=-1;
     //If we don't have the query yet, create one.
     if (regentQueryID < 0)
     {
        regentQueryID=kbUnitQueryCreate("regentGetUnitQuery");
        kbUnitQuerySetIgnoreKnockedOutUnits(regentQueryID, true);
     }
    //Define a query to get all matching units
    if (regentQueryID != -1) {
      kbUnitQuerySetPlayerRelation(regentQueryID, -1);
      kbUnitQuerySetPlayerID(regentQueryID, cMyID);
      kbUnitQuerySetUnitType(regentQueryID, cUnitTypeypDaimyoRegicide);
      kbUnitQuerySetState(regentQueryID, cUnitStateAlive);
    }
    else {
      return;
    }
  
    
    kbUnitQueryResetResults(castleQueryID);
    kbUnitQueryResetResults(regentQueryID);
    
    kbUnitQueryExecute(castleQueryID);
    kbUnitQueryExecute(regentQueryID);
    
    int index = 0;
    
    aiTaskUnitWork(kbUnitQueryGetResult(regentQueryID, index), kbUnitQueryGetResult(castleQueryID, index));
  }
  else {
    xsDisableSelf();
  }
}


//==============================================================================
/* BHG orchard monitor

   If we have a wagon, build an orchard immediately.

*/
//==============================================================================
rule orchardMonitor
inactive
group tcComplete
minInterval 26
{ 
  if (kbUnitCount(cMyID, cUnitTypeYPBerryWagon1, cUnitStateAlive) > 0) 
  {  createSimpleBuildPlan(cUnitTypeypBerryBuilding, 1, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);  }
}


//==============================================================================
/* Building monitor

   Make sure we have the right number of buildings, or at least a build plan,
   for each required building type.

*/
//==============================================================================
rule buildingMonitor
inactive
group tcComplete
minInterval 10
{
   int planID = -1;
   
   if (cvOkToBuild == false)
      return;
   
   if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      return;  
      
	  startGTowerBuildPlan();
	  
	  addGTowerBuildPlan();
	  
   if (civIsEuropean() == true)
   {  // if Dutch, add banks to the build limit
      if (kbGetCiv() == cCivDutch)
      {         
         static int lastBankPlanTime = 0;
	 int numDelta = kbGetBuildLimit(cMyID, cUnitTypeBank) - kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive); 
	 if (numDelta > 0)
	 { 
	    planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBank); 
	    if (planID < 0)
	    { 
		createSimpleBuildPlan(cUnitTypeBank, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
		aiEcho("Starting a bank build plan."); 
		lastBankPlanTime = xsGetTime();
	    }
	    if (planID >= 0)
	    {
		if ((aiPlanGetState(planID) != cPlanStateBuild)&&(xsGetTime()-lastBankPlanTime > 90000))
		  aiPlanDestroy(planID);
	    } 
	 }	 
      }
      
      if (kbGetAge() >= cAge2)
      {         
         static int lastFactoryPlanTime = 0;
	 int numDelta1 = kbGetBuildLimit(cMyID, cUnitTypeFactory) - kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateABQ); 
	 if (numDelta1 > 0)
	 { 
	    planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeFactory); 
	    if (planID < 0)
	    { 
		createSimpleBuildPlan(cUnitTypeFactory, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
		aiEcho("Starting a bank build plan."); 
		lastFactoryPlanTime = xsGetTime();
	    }
	    if (planID >= 0)
	    {
		if ((aiPlanGetState(planID) != cPlanStateBuild)&&(xsGetTime()-lastFactoryPlanTime > 90000))
		  aiPlanDestroy(planID);
	    } 
	 }	 
      }

      // At least one church
      if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
      {
	 static int lastChurchPlanTime = 0;
	 planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeChurch);
	 if (planID < 0)
	 {	
	    if (((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) >= 2))||
		((kbGetCiv() != cCivDutch) && (kbGetAge() >= cAge3)))
	    { 
		createSimpleBuildPlan(cUnitTypeChurch, 1, 90, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
		aiEcho("Starting a new church build plan.");
		lastChurchPlanTime = xsGetTime();
	    }
	 }
	 if (planID >= 0)
	 {
	    if ((aiPlanGetState(planID) != cPlanStateBuild) && (xsGetTime()-lastChurchPlanTime > 60000))
	      aiPlanDestroy(planID);
	    if ((aiPlanGetState(planID) == cPlanStateBuild) && (xsGetTime()-lastChurchPlanTime > 60000))
	      aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
	 }
      }
      // At least one arsenal (not for natives or Asians)
      if (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateABQ) < 1)
      {
	 static int lastArsenalPlanTime = 0;
	 planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeArsenal);
	 if ((planID < 0)&&(kbGetPop() > 60))
	 {
	    createSimpleBuildPlan(cUnitTypeArsenal, 1, 60, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	    aiEcho("Starting a new arsenal build plan.");
	    lastArsenalPlanTime = xsGetTime();
	 }
	 if (planID >= 0)
	 {
	    if ((aiPlanGetState(planID) != cPlanStateBuild) && (xsGetTime()-lastArsenalPlanTime > 60000))
	     aiPlanDestroy(planID);
	    if ((aiPlanGetState(planID) == cPlanStateBuild) && (xsGetTime()-lastArsenalPlanTime > 60000))
	     aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
	 }
      }
      // And how 'bout a capitol, as long as we're here.
      if (kbUnitCount(cMyID, cUnitTypeCapitol, cUnitStateABQ) < 1)
      {
	 static int lastCapitolPlanTime = 0;
	 planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCapitol);
	 if ((planID < 0) && (kbGetAge() > cAge4))
	 {
	    createSimpleBuildPlan(cUnitTypeCapitol, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	    aiEcho("Starting a new capitol build plan.");
	    lastCapitolPlanTime = xsGetTime();
	 }
	 if (planID >= 0)
	 {
	    if ((aiPlanGetState(planID) != cPlanStateBuild) && (xsGetTime()-lastCapitolPlanTime > 60000))
              aiPlanDestroy(planID);
	    if ((aiPlanGetState(planID) == cPlanStateBuild) && (xsGetTime()-lastCapitolPlanTime > 60000))
	      aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
	 }
      }
   }

   if (civIsAsian() == true)
   { 
      // Consulate
      if ((kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1) && (kbGetAge() >= cAge2))
      {			
	 static int lastConsulatePlanTime = 0;
	 planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypConsulate);
	 if (planID < 0)
	 {
	    if (kbGetAge() >= cAge2)
	    {
	       createSimpleBuildPlan(cUnitTypeypConsulate, 1, 90, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	       aiEcho("Starting a new consulate build plan.");
	       lastConsulatePlanTime = xsGetTime();
	    }
	 }
	 if (planID >= 0)
	 {
	    if ((aiPlanGetState(planID) != cPlanStateBuild) && (xsGetTime()-lastConsulatePlanTime > 60000))
	      aiPlanDestroy(planID);
	    if ((aiPlanGetState(planID) == cPlanStateBuild) && (xsGetTime()-lastConsulatePlanTime > 60000))
	      aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
	 }
      }
      //Monastery
      if (kbUnitCount(cMyID, cUnitTypeypMonastery, cUnitStateABQ) < 1)
      {
	 static int lastMonasteryPlanTime = 0;
	 planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypMonastery);
	 if ((planID < 0) && (kbGetAge() > cAge3)) 
	 {
	    createSimpleBuildPlan(cUnitTypeypMonastery, 1, 30, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	    aiEcho("Starting a new monastery build plan.");
	    lastMonasteryPlanTime = xsGetTime();
	 }
	 if (planID >= 0)
	 {
	    if ((aiPlanGetState(planID) != cPlanStateBuild) && (xsGetTime()-lastMonasteryPlanTime > 60000))
	      aiPlanDestroy(planID);
	    if ((aiPlanGetState(planID) == cPlanStateBuild) && (xsGetTime()-lastMonasteryPlanTime > 60000))
	      aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
	 }
      }
      /* If Indians, at least 2 sacred fields... 
      Note: Sacred fields construction handled by "sacredFieldMonitor", do not build sacred fields here...
      if (cMyCiv == cCivIndians)
      {      
         planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypSacredField);
         if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateAlive) < 2) )
         { 
            aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 15.0);
            createLocationBuildPlan(cUnitTypeypSacredField, 1, 65, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);            
            aiEcho("Starting a new sacred field build plan.");
         }       
      }*/
   }
       
   if ((civIsNative() == true) && (kbGetAge() >= cAge4))
   {
      // If native, at least one fire pit
      if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1)
      {
         static int lastFirePitPlanTime = 0;
         planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeFirePit);
         if (planID < 0)
         {
	    if ((cMyCiv == cCivXPAztec)||
	       ((cMyCiv != cCivXPAztec) && (agingUpToOrAbove(cAge3) == true)))
	    {
	       vector myTCLocation = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
	       vector normalVec = xsVectorNormalize(myTCLocation - kbGetMapCenter());
	       vector firePitPlace = myTCLocation + normalVec * 5;
	       planID = createLocationBuildPlan(cUnitTypeFirePit, 1, 100, true, cEconomyEscrowID, firePitPlace, 1); 
	       aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 25.0);
	       aiEcho("Starting a new firepit build plan."); 
	       lastFirePitPlanTime = xsGetTime();  
	    }
         }
         if (planID >= 0)
         {
	    if ((aiPlanGetState(planID) != cPlanStateBuild) && (xsGetTime()-lastFirePitPlanTime > 60000))
	      aiPlanDestroy(planID);
	    if ((aiPlanGetState(planID) == cPlanStateBuild) && (xsGetTime()-lastFirePitPlanTime > 60000))
	      aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
         }
      }      
   }

   //Set build permissions for militqry buildings with different initial strategies:
   bool buildPermission = false;
   if (aiGetGameMode() == cGameModeDeathmatch)  // DM mode, build military building ASAP         	
      buildPermission = true;
    
   if (gInitialStrategy == 1)  // Rush (Attacker)
   {
   //if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 2))
	//buildPermission = false;   
	//else
      if ( (kbGetAge() >= cAge2) || (agingUpTo(cAge2) == true) )      
	 buildPermission = true;         
   }  
   if (gInitialStrategy == 2)  // FF
   {
   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 2))
	buildPermission = false;   
	else
      if ( (kbGetAge() >= cAge2) || (agingUpTo(cAge2) == true) )      
	 buildPermission = true;       
    //  else     
	// buildPermission = false;     
    //  if ((kbGetCiv() == cCivXPIroquois) && (kbUnitCount(cMyID, cUnitTypexpBuilder, cUnitStateAlive) > 0))	
//	buildPermission = true;
   }
   if ((gInitialStrategy == 0) || (gInitialStrategy == 3))  // Turtler (Econ Builder) or FI
   {
   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 2))
	buildPermission = false;   
	else
      if (kbGetAge() >= cAge2)      
	 buildPermission = true;         
/*      else if ((kbGetAge() == cAge2) || (agingUpTo(cAge2) == true))      
	 buildPermission = true;         
      else      
	 buildPermission = false;      
      if ((kbGetCiv() == cCivXPIroquois) && (kbUnitCount(cMyID, cUnitTypexpBuilder, cUnitStateAlive) > 0))	
	buildPermission = true; */
   }
  
   if (buildPermission == true)
   {      
	  float currentWood=kbResourceGet(cResourceWood);     
      int numBarracks = 0;
      int numStable = 0;
      int numArtilleryDepot = 0;
      int numNoblesHut = kbGetBuildLimit(cMyID, cUnitTypeNoblesHut);
      float fVil = kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) + 1*kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive) + 5* kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) + .5 * kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive);
	
      if ((fVil <= 30.0) || (kbGetAge() == cAge2))
      {
         if (kbGetCiv() == cCivOttomans)
		 {
         numBarracks = 1;
         numArtilleryDepot = 1;
         numStable = 1;
		 }
		 else
         if (kbGetCiv() == cCivXPIroquois)
		 {
         numBarracks = 1;
         numArtilleryDepot = 0;
         numStable = 0;
		 }
		 else
         if (kbGetCiv() == cCivXPSioux)
		 {
         numBarracks = 0;
         numArtilleryDepot = 0;
         numStable = 2;
		 }
		 else
		 if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < 2))
		 {
         numBarracks = 1;
         numArtilleryDepot = 0;
         numStable = 1;
		 }
		 else
		 {
         numBarracks = 1;
         numArtilleryDepot = 0;
         numStable = 1;
         }
	  }
	  
      if ((fVil >= 30.0) && (fVil < 60.0) && (kbGetAge() > cAge2))
      {
	 numBarracks = 4;
	 numStable = 2;
	 numArtilleryDepot = 0;
         if (kbGetCiv() == cCivOttomans)
           numArtilleryDepot = 2;
      }
	  
      if ((fVil >= 60.0) && (fVil < 80.0) && (kbGetAge() > cAge3))
      {
         numBarracks = 12;
         if (kbGetCiv() == cCivChinese)
           numBarracks = 12;
         numStable = 12;            
         if ( (civIsNative() == true) || (civIsAsian() == true) )
           numStable = 12;
         numArtilleryDepot = 1;
         if (kbGetCiv() == cCivOttomans)
           numArtilleryDepot = 4;
	  }
		   
      if ((fVil >= 80.0) && (kbGetAge() >= cAge5))
      {
         numBarracks = 16;
         if (kbGetCiv() == cCivChinese)
           numBarracks = 16;
         numStable = 16;            
         if ( (civIsNative() == true) || (civIsAsian() == true) )
           numStable = 16;
         numArtilleryDepot = 1;
         if (kbGetCiv() == cCivOttomans)
           numArtilleryDepot = 4;
	  }
		   
      if ((fVil >= 80.0) && (kbGetAge() >= cAge5) && (xsGetTime() >= 40*60*1000))
      {
         numBarracks = 100;
         if (kbGetCiv() == cCivChinese)
           numBarracks = 100;
         numStable = 100;            
         if ( (civIsNative() == true) || (civIsAsian() == true) )
           numStable = 100;
         numArtilleryDepot = 20;
         if (kbGetCiv() == cCivOttomans)
           numArtilleryDepot = 100;
      }
	  
      if (aiGetGameMode() == cGameModeDeathmatch)
      {
	 numBarracks = 100;
         if (kbGetCiv() == cCivChinese)
           numBarracks = 100;
	 numStable = 100;
	 numArtilleryDepot = 20;	 
   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
         return;
      }

   if ((kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
         return;

      // Build tower units
      if ((kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) < kbGetBuildLimit(cMyID, gTowerUnit)) && (fVil > 20.0))
        addGTowerBuildPlan();
		
      if ((kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) < kbGetBuildLimit(cMyID, gTowerUnit)) && (fVil > 20.0))
        startGTowerBuildPlan();
		
      if ((kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) < kbGetBuildLimit(cMyID, gTowerUnit)) && (fVil > 60.0))
        addTowerBuildPlan();
      
      // If Aztecs, at least 5 Nobles Huts
      if ( (cMyCiv == cCivXPAztec) && (fVil > 70.0) )
      {                     
         planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeNoblesHut);
         if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeNoblesHut, cUnitStateAlive) < 5) )
         {  // Start a new one
            createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 65, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
            aiEcho("Starting a new nobles hut build plan.");
         }        
      }

      // If Sioux, at least 5 Teepee
      if ((cMyCiv == cCivXPSioux) && (fVil > 60.0) )
      {                     
         int teepeeBuildPlan = createLocationBuildPlan(cUnitTypeTeepee, 1, 60, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);			            
         aiPlanSetVariableFloat(teepeeBuildPlan, cBuildPlanCenterPositionDistance, 0, 300.0);              
	 aiPlanAddUnitType(teepeeBuildPlan, gEconUnit, 1, 1, 1);
      }

      // Build Barracks units
      if (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) < numBarracks)
      {
         static int lastBarracksPlanTime = 0;
	 planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gBarracksUnit);
	 if (planID < 0)
	 {
	    if ((kbGetCiv() != cCivXPIroquois)||
		((kbGetCiv() == cCivXPIroquois)&&(kbUnitCount(cMyID, cUnitTypexpBuilder, cUnitStateAlive) > 0)))
	    {
	       planID = createSimpleBuildPlan(gBarracksUnit, 1, 90, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
	       if (kbGetCiv() == cCivXPIroquois)
		 aiPlanAddUnitType(planID, cUnitTypexpBuilder, 1, 1, 1);			 
               else
	       if (kbGetCiv() == cCivJapanese)
		 aiPlanAddUnitType(planID, cUnitTypeYPMilitaryRickshaw, 1, 1, 1);			 
               else
		 aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
		 aiEcho("Starting a new barracks build plan.");
		 lastBarracksPlanTime = xsGetTime();  
	    }
	    if ((kbGetCiv() == cCivBritish) && (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) < 2))
	    {
	     planID = createSimpleBuildPlan(gBarracksUnit, 1, 90, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		 aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
		 aiEcho("Starting a new barracks build plan.");
		 lastBarracksPlanTime = xsGetTime();  
	    }
	    if (kbGetCiv() == cCivJapanese)
	    {
	     planID = createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 90, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		 aiPlanAddUnitType(planID, cUnitTypeYPMilitaryRickshaw, 1, 1, 1);	
		 aiEcho("Starting a new barracks build plan.");
		 lastBarracksPlanTime = xsGetTime();  
	    }
	    if ((kbGetCiv() == cCivJapanese) && (kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateAlive) < 2))
	    {
	     planID = createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 90, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		 aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
		 aiEcho("Starting a new barracks build plan.");
		 lastBarracksPlanTime = xsGetTime();  
	    }
	    if ((kbGetCiv() == cCivBritish) && (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) < 1))
	    {
	     planID = createSimpleBuildPlan(gStableUnit, 1, 90, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		 aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
		 aiEcho("Starting a new barracks build plan.");
		 lastBarracksPlanTime = xsGetTime();  
	    }
	    if ((kbGetCiv() == cCivJapanese) && (kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateAlive) < 1))
	    {
	     planID = createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 90, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		 aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
		 aiEcho("Starting a new barracks build plan.");
		 lastBarracksPlanTime = xsGetTime();  
	    }
	}
	 if (planID >= 0)
	 {
	    if ((aiPlanGetState(planID) != cPlanStateBuild) && (xsGetTime()-lastBarracksPlanTime > 60000))
	      aiPlanDestroy(planID);
	    if ((aiPlanGetState(planID) == cPlanStateBuild) && (xsGetTime()-lastBarracksPlanTime > 60000))
	      aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
	 }
      }
      // Build Stable units
      if (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) < numStable)
      {
	 static int lastStablePlanTime = 0;
	 planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gStableUnit);
	 if (planID < 0)
	 {
	    if (kbGetCiv() != cCivXPIroquois)//||
	      // ((kbGetCiv() == cCivXPIroquois)&&(kbUnitCount(cMyID, cUnitTypexpBuilder, cUnitStateAlive) > 0)))
	    {			 
	       planID = createSimpleBuildPlan(gStableUnit, 1, 80, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
	       //if (kbGetCiv() == cCivXPIroquois)
		// aiPlanAddUnitType(planID, cUnitTypexpBuilder, 1, 1, 1);			 
          //     else
		 aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
		 aiEcho("Starting a new stable build plan.");
		 lastStablePlanTime = xsGetTime();
	    }  
	 }
	 if (planID >= 0)
	 {
	    if ((aiPlanGetState(planID) != cPlanStateBuild) && (xsGetTime()-lastStablePlanTime > 60000))
	      aiPlanDestroy(planID);
	    if ((aiPlanGetState(planID) == cPlanStateBuild) && (xsGetTime()-lastStablePlanTime > 60000))
	      aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
	 }
      }
      // At two one artillery depot (not for French, Aztecs, Sioux or Asians)
      if (((civIsEuropean() == true) || (kbGetCiv() == cCivXPIroquois)) && (kbUnitCount(cMyID, gArtilleryDepotUnit, cUnitStateAlive) < numArtilleryDepot))
      {
	 static int lastyDepotPlanTime = 0;
	 planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gArtilleryDepotUnit);
	 if ((planID < 0)&&(kbGetAge() >= cAge3))
	 {
	    if ((kbGetCiv() != cCivXPIroquois) ||
                //(kbGetCiv() != cCivFrench) ||
	       ((kbGetCiv() == cCivXPIroquois)&&(kbUnitCount(cMyID, cUnitTypexpBuilder, cUnitStateAlive) > 0)))
	    {				 
	       planID = createSimpleBuildPlan(gArtilleryDepotUnit, 1, 60, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
	       if (kbGetCiv() == cCivXPIroquois)
		 aiPlanAddUnitType(planID, cUnitTypexpBuilder, 1, 1, 1);				 
               else
		 aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
		 aiEcho("Starting a new artillery depot build plan.");
	     	 lastyDepotPlanTime = xsGetTime(); 
	    } 
	 }
	 if (planID >= 0)
	 {
	    if ((aiPlanGetState(planID) != cPlanStateBuild) && (xsGetTime()-lastyDepotPlanTime > 60000))
	      aiPlanDestroy(planID);
	    if ((aiPlanGetState(planID) == cPlanStateBuild) && (xsGetTime()-lastyDepotPlanTime > 60000))
	      aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
	 }
      }
      // At least one Saloon
      if ((kbUnitCount(cMyID, cUnitTypeSaloon, cUnitStateAlive) < 1) && (civIsEuropean() == true) && (kbGetAge() >= 5) && (kbResourceGet(cResourceGold) < 4000))
      {
	 static int lastSaloonPlanTime = 0;
	 planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeSaloon);
	 if (planID < 0)
	 {
	    if ((kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 2) || (xsGetTime() > 60*1000*20))
	    {
	       createSimpleBuildPlan(cUnitTypeSaloon, 1, 10, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	       aiEcho("Starting a new Saloon build plan.");				
	       lastSaloonPlanTime = xsGetTime();
	    }
	 }
	 
	 if (planID >= 0)
	 {
	    if (kbGetAge() < cAge3)
	    {
	       aiPlanDestroy(planID);
	       planID = -1;
	    }
	    if ((aiPlanGetState(planID) != cPlanStateBuild) && (xsGetTime()-lastSaloonPlanTime > 60000))
	      aiPlanDestroy(planID);
	    if ((aiPlanGetState(planID) == cPlanStateBuild) && (xsGetTime()-lastSaloonPlanTime > 60000))
	      aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1);
	 }
      }


      //about tradingpost: the original AI always send 2~4 villagers far away to build.
      planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeTradingPost); 
      if (planID >= 0)
      {
		static int explorerQuery = -1;
		if (explorerQuery < 0)
		{
			explorerQuery = kbUnitQueryCreate("explorer Query");
			kbUnitQuerySetIgnoreKnockedOutUnits(explorerQuery, true);
			kbUnitQuerySetPlayerID(explorerQuery, cMyID);
			kbUnitQuerySetUnitType(explorerQuery, gExplorerUnit);
			kbUnitQuerySetState(explorerQuery, cUnitStateAlive);
		}
		kbUnitQueryResetResults(explorerQuery);
		int explorerCount = kbUnitQueryExecute(explorerQuery);

        if ((explorerCount < 2) && (aiGetFallenExplorerID() < 0))
		{
			aiPlanAddUnitType(planID, cUnitTypeCoureurCree, 0, 0, 0);
			aiPlanAddUnitType(planID, cUnitTypeSettler, 0, 0, 0); 
			aiPlanAddUnitType(planID, cUnitTypeSettlerNative, 0, 0, 0); 
			aiPlanAddUnitType(planID, cUnitTypePilgrim, 0, 0, 0);
			aiPlanAddUnitType(planID, cUnitTypeSettlerWagon, 0, 0, 0);
			aiPlanAddUnitType(planID, gEconUnit, 0, 0, 0);
			aiPlanAddUnitType(planID, gExplorerUnit, 1, 1, 1);
			return;
        }
        if ((kbGetCiv() == cCivJapanese)||(kbGetCiv() == cCivSPCJapanese)||(kbGetCiv() == cCivSPCJapaneseEnemy))
		{
		  if ((aiGetFallenExplorerID() < 0)||(kbUnitIsType(aiGetFallenExplorerID(), cUnitTypeypMonkJapanese) == false)||(kbUnitIsType(aiGetFallenExplorerID(), cUnitTypeypMonkJapanese2) == false))
		  {
            aiPlanAddUnitType(planID, cUnitTypeCoureurCree, 0, 0, 0);
            aiPlanAddUnitType(planID, cUnitTypeSettler, 0, 0, 0); 
            aiPlanAddUnitType(planID, cUnitTypeSettlerNative, 0, 0, 0); 
            aiPlanAddUnitType(planID, cUnitTypePilgrim, 0, 0, 0);
            aiPlanAddUnitType(planID, cUnitTypeSettlerWagon, 0, 0, 0);
            aiPlanAddUnitType(planID, gEconUnit, 0, 0, 0);
            aiPlanAddUnitType(planID, gExplorerUnit, 1, 1, 1);
			return;
		  }
		}
        else if ((kbGetCiv() == cCivIndians)||(kbGetCiv() == cCivSPCIndians))
		{
		  if ((aiGetFallenExplorerID() < 0)||(kbUnitIsType(aiGetFallenExplorerID(), cUnitTypeypMonkIndian) == false)||(kbUnitIsType(aiGetFallenExplorerID(), cUnitTypeypMonkIndian2) == false))
		  {
            aiPlanAddUnitType(planID, cUnitTypeCoureurCree, 0, 0, 0);
            aiPlanAddUnitType(planID, cUnitTypeSettler, 0, 0, 0); 
            aiPlanAddUnitType(planID, cUnitTypeSettlerNative, 0, 0, 0); 
            aiPlanAddUnitType(planID, cUnitTypePilgrim, 0, 0, 0);
            aiPlanAddUnitType(planID, cUnitTypeSettlerWagon, 0, 0, 0);
            aiPlanAddUnitType(planID, gEconUnit, 0, 0, 0);
            aiPlanAddUnitType(planID, gExplorerUnit, 1, 1, 1);
			return;
		  }
		}
        else if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 0)
		{
            aiPlanAddUnitType(planID, cUnitTypeCoureurCree, 0, 0, 0);
            aiPlanAddUnitType(planID, cUnitTypeSettler, 0, 0, 0); 
            aiPlanAddUnitType(planID, cUnitTypeSettlerNative, 0, 0, 0); 
            aiPlanAddUnitType(planID, cUnitTypePilgrim, 0, 0, 0);
            aiPlanAddUnitType(planID, cUnitTypeSettlerWagon, 0, 0, 0);
            aiPlanAddUnitType(planID, gEconUnit, 0, 0, 0);
            aiPlanAddUnitType(planID, gEconUnit, 1, 1, 1); 
			return;
		}
      }
   }  
}


//==============================================================================
/* xpBuilder monitor

   Use an idle xpBuilder to build as needed.

*/	
//==============================================================================
rule xpBuilderMonitor
inactive
group tcComplete
minInterval 13
{
   if (kbGetCiv() != cCivXPIroquois) 
   {
      xsDisableSelf();
      return;
   }
   
   static int activePlan = -1;
   
   if (activePlan != -1)   // We already have something active?
   {
      if ( (aiPlanGetState(activePlan) < 0) || (aiPlanGetState(activePlan) == cPlanStateNone) ) 
      {
         aiPlanDestroy(activePlan);
         activePlan = -1;  // Plan is bad, but didn't die.  It's dead now, so continue below.
      }
      else
      {
         return;  // Something is active, let it run.
      }
   }
   
   // If we get this far, there is no active plan.  See if we have a xpBuilder to use.
   int xpBuilderID = -1;
   int buildingToMake = -1;
   int buildertype = -1;
   if (kbUnitCount(cMyID, cUnitTypexpBuilderStart, cUnitStateAlive) > 0) 
   {
      xpBuilderID = getUnit(cUnitTypexpBuilderStart);
      buildingToMake = gHouseUnit;  // If all else fails, make a house since we can't make warhuts.
      buildertype = cUnitTypexpBuilderStart;
   }
   else 
   {
      xpBuilderID = getUnit(cUnitTypexpBuilder);
      buildingToMake = cUnitTypeWarHut;  // If all else fails, make a war hut.
      buildertype = cUnitTypexpBuilder;
   }

   if (xpBuilderID < 0)
      return;
   
   // We have a xpBuilder, and no plan to use it.  Find something to do with it.  
   // Simple logic.  Farm if less than 2.  War hut if less than 2.  Corral if < 2.
   // Plantations if less than 2 in Age 3 and above.   House if below build limit.
   // Siege Workshop if less than 2 in Age 3 and above.
   // One override....avoid farms in age 1, they're too slow.
   // Avoid war huts and corrals in Age 1 as starting travois cannot build them.
   if (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < kbGetBuildLimit(cMyID, gHouseUnit))
      buildingToMake = gHouseUnit;   
   else if ( (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < 3) && (kbGetAge() > cAge1) )
      buildingToMake = cUnitTypeWarHut;
   //else if ( (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) < 3) && (kbGetAge() > cAge1) )
   //   buildingToMake = cUnitTypeCorral;   
   else if ( (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) < 2) && (kbGetAge() > cAge2) )
      buildingToMake = cUnitTypeArtilleryDepot;
   else if ( (kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ) < 6) && (gTimeToFarm == true) ) 
      buildingToMake = gFarmUnit;
   else if ( (kbUnitCount(cMyID, gPlantationUnit, cUnitStateABQ) < 6) && (gTimeForPlantations == true) ) 
      buildingToMake = gPlantationUnit;

   if (buildingToMake >= 0)
   {
      activePlan = aiPlanCreate("Use an xpBuilder", cPlanBuild);
      // What to build
      aiPlanSetVariableInt(activePlan, cBuildPlanBuildingTypeID, 0, buildingToMake);

      // 1 meter separation for farms and plantations, 6 meter for everything else
      aiPlanSetVariableFloat(activePlan, cBuildPlanBuildingBufferSpace, 0, 6.0);
      if ((buildingToMake == gFarmUnit) || (buildingToMake == gPlantationUnit))
         aiPlanSetVariableFloat(activePlan, cBuildPlanBuildingBufferSpace, 0, 1.0);       
      if (buildingToMake == gHouseUnit)
         aiPlanSetVariableVector(activePlan, cBuildPlanCenterPosition, 0, gHousePosition);
      //Priority.
      aiPlanSetDesiredPriority(activePlan, 95);
      //Mil vs. Econ.
      if ( (buildingToMake == cUnitTypeWarHut) || 
           //(buildingToMake == cUnitTypeCorral) || 
           (buildingToMake == cUnitTypeArtilleryDepot) )

      {
         aiPlanSetMilitary(activePlan, true);
         aiPlanSetEconomy(activePlan, false);
      }
      else
      {
         aiPlanSetMilitary(activePlan, false);
         aiPlanSetEconomy(activePlan, true);
      }
      aiPlanSetEscrowID(activePlan, cEconomyEscrowID);
      aiPlanAddUnitType(activePlan, buildertype, 1, 1, 1);
      aiPlanSetBaseID(activePlan, kbBaseGetMainID(cMyID));

      //Go.
      aiPlanSetActive(activePlan);
   }
}

//==============================================================================
/* Native Dance Monitor

   Manage the number of natives dancing, and the 'tactic' they're dancing for.

const int cTacticFertilityDance=12;   Faster training
const int cTacticGiftDance=13;         Faster XP trickle
const int cTacticCityDance=14;
const int cTacticWaterDance=15;       Increases navy HP/attack
const int cTacticAlarmDance=16;        Town defense...
const int cTacticFounderDance=17;      xpBuilder units - Iroquois
const int cTacticMorningWarsDance=18;
const int cTacticEarthMotherDance=19;
const int cTacticHealingDance=20;
const int cTacticFireDance=21;
const int cTacticWarDanceSong=22;
const int cTacticGarlandWarDance=23;
const int cTacticWarChiefDance=24;    new war chief (Iroquois)
const int cTacticHolyDance=25;
const int cTacticWarChiefDanceSioux=28;    new war chief (Sioux)
const int cTacticWarChiefDanceAztec=29;    new war chief (Aztec)

*/
//==============================================================================
rule danceMonitor
inactive
group tcComplete
minInterval 60
{
    if (civIsNative() == false)
    {
       xsDisableSelf();
       return;
    }

    if ((kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateAlive) < 1) && (kbGetAge() >= cAge4))
      return;
   
    int numWarPriests = kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive);
    
    int tempDancers = 0;
    int popThreshold = 0;
    // healer maintain.
    int surgeonCount = kbUnitCount(cMyID, cUnitTypeSurgeon, cUnitStateAlive);
    int natMedicineManCount = kbUnitCount(cMyID, cUnitTypeNatMedicineMan, cUnitStateAlive);
    int xpMedicineManCount = kbUnitCount(cMyID, cUnitTypexpMedicineMan, cUnitStateAlive);
    static int lastTactic = -1;
    static int lastTacticTime = -1;
    static int lastWarChiefTime = -1;
    static int warChiefCount = 0;
   
    if (gNativeDancePlan < 0)
    {
       gNativeDancePlan = createNativeResearchPlan(cTacticNormal, 85, 1, 1, 1);
       aiPlanAddUnitType(gNativeDancePlan, cUnitTypexpMedicineManAztec, numWarPriests, numWarPriests, numWarPriests);
       aiPlanSetUnitStance(gNativeDancePlan, cUnitStanceDefensive);
       aiPlanSetDesiredPriority(gNativeDancePlan, 100);
       aiPlanSetActive(gNativeDancePlan); 
       lastTactic = cTacticNormal;
       lastTacticTime = xsGetTime();
    }

    // Use all available warrior priests as dancers
    aiPlanAddUnitType(gNativeDancePlan, cUnitTypexpMedicineManAztec, numWarPriests, numWarPriests, numWarPriests);
    aiPlanSetUnitStance(gNativeDancePlan, cUnitStanceDefensive);
    aiPlanSetDesiredPriority(gNativeDancePlan, 100);
  
    // Add a number of dancers equivalent to 1/5 of settler pop, rounded down
    // Make sure no more than 25 units are assigned in total
    int want = -1;
    if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) <= 25)
      want = 1; 
    else   
      want = 2 + kbUnitCount(cMyID, gEconUnit, cUnitStateAlive)/15;

    if (cMyCiv == cCivXPAztec)
    {
       if (want > 10 - numWarPriests)
	 want = 10 - numWarPriests;
    }

    aiPlanAddUnitType(gNativeDancePlan, gEconUnit, want/2, want, want*2);

    // war dance control.
    static int enemyPointQuery = -1;  
    enemyPointQuery = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeLogicalTypeLandMilitary, cUnitStateABQ);
    kbUnitQueryResetResults(enemyPointQuery);
    int enemyCount = kbUnitQueryExecute(enemyPointQuery);
    int enemyPointID = 0;
    vector enemyPointVector = cInvalidVector;
    int enemyPointCount = 0;
    int mySelfPointCount = 0;
    bool warDanceBool = false;
    int i = 0;
    for (i=0; <enemyCount)
    {
	enemyPointID = kbUnitQueryGetResult(enemyPointQuery, i);
	enemyPointVector = kbUnitGetPosition(enemyPointID);
	enemyPointCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, enemyPointVector, 30.0);
        mySelfPointCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cMyID, cUnitStateAlive, enemyPointVector, 50.0) - getUnitCountByLocation(cUnitTypexpMedicineManAztec, cMyID, cUnitStateAlive, enemyPointVector, 50.0);
	if ((mySelfPointCount>10)&&(enemyPointCount*2 > mySelfPointCount))
	{
	   warDanceBool = true;
	   break;
	}
    }

    // fire dance control.
    if (cMyCiv == cCivXPSioux)
    {	   
       enemyPointQuery = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeBuilding, cUnitStateABQ);
       kbUnitQueryResetResults(enemyPointQuery);
       int enemyBuindingCount = kbUnitQueryExecute(enemyPointQuery);
       int enemyPointBuildingCount = 0;
       bool fireDanceBool = false;
       for (i=0; <enemyBuindingCount)
       {
	   enemyPointID = kbUnitQueryGetResult(enemyPointQuery, i);
	   enemyPointVector = kbUnitGetPosition(enemyPointID);
           enemyPointBuildingCount = getUnitCountByLocation(cUnitTypeBuilding, cPlayerRelationEnemyNotGaia, cUnitStateAlive, enemyPointVector, 30.0);
	   enemyPointCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, enemyPointVector, 40.0);
	   mySelfPointCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cMyID, cUnitStateAlive, enemyPointVector, 30.0);
	   if ( (enemyPointBuildingCount >= 3) && (mySelfPointCount > 10) && (enemyPointCount * 4 < mySelfPointCount) )
	   {
	      fireDanceBool = true;
	      break;
           }
       }
    }

    switch (kbGetCiv())
    {
       case cCivXPSioux:
       {          
          // Select a tactic 
          if (kbGetAge() < cAge2) 
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticGiftDance);
             lastTactic = cTacticGiftDance;
             lastTacticTime = xsGetTime();    
             return;
          }

          // Recover war chief
          if (aiGetFallenExplorerID() >= 0)
          {	
	     aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarChiefDanceSioux);
	     lastTactic = cTacticWarChiefDanceSioux;	
	     lastTacticTime = xsGetTime();
	     return;
          }

          // Train units faster
          if ((aiPlanGetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0) > (kbUnitCount(cMyID, gEconUnit, cUnitStateABQ))) && (kbGetPop() < kbGetPopCap()))
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticFertilityDance);
             aiPlanAddUnitType(gNativeDancePlan, gEconUnit, want/2, want, want*2);
             lastTactic = cTacticFertilityDance;
             lastTacticTime = xsGetTime();
             return;
          }

          // It's time to start war dance
          if (warDanceBool == true)
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarDance);
             if ( (lastTactic != cTacticGarlandWarDance) && (lastTactic != cTacticWarDanceSong) )
	     {
		 tempDancers = enemyPointCount + mySelfPointCount - numWarPriests - 25;
		 if (tempDancers > 25-numWarPriests)
		   tempDancers = 25-numWarPriests;
		 if  (tempDancers > want)
		   aiPlanAddUnitType(gNativeDancePlan, gEconUnit, tempDancers, tempDancers, tempDancers);
             }
	     lastTactic = cTacticWarDance;
             lastTacticTime = xsGetTime();
             return;
          }
          // It's time to start fire dance
          if (fireDanceBool == true)
	  {
	     aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticFireDance);
	     if (lastTactic != cTacticWarDanceSong)
	     {
		tempDancers = 3 * enemyPointBuildingCount + mySelfPointCount - numWarPriests - 10;
		if (tempDancers > 25-numWarPriests)
		  tempDancers = 25-numWarPriests;
		if  (tempDancers > want)
		  aiPlanAddUnitType(gNativeDancePlan, gEconUnit, tempDancers, tempDancers, tempDancers);
	     }
	     lastTactic = cTacticWarDance;
	     lastTacticTime = xsGetTime();
	     return;
	  }
          /* Alarm dance if base is under attack
          if ( (gDefenseReflexBaseID == kbBaseGetMainID(cMyID)) && (kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) < 6))
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticAlarmDance);
	     lastTactic = cTacticAlarmDance;
	     lastTacticTime = xsGetTime();
	     return;
          } */
          
          // Spawn dog soldiers in age 4 or 5 (Sioux only)
          if ( (kbGetAge() >= cAge4) && (kbUnitCount(cMyID, cUnitTypexpDogSoldier, cUnitStateAlive) < 15) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 35) && (gDefenseReflexBaseID != kbBaseGetMainID(cMyID)))
          {
             popThreshold = kbGetPopCap() - 30;
	     if (kbGetPop() < popThreshold)
	     {
	        aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarDanceSong);
	        aiPlanAddUnitType(gNativeDancePlan, gEconUnit, (25-numWarPriests), (25-numWarPriests), (25-numWarPriests));
	        lastTactic = cTacticWarDanceSong;
	        lastTacticTime = xsGetTime();
	        return;
	     } 
	     if (kbGetPopCap() - kbGetPop() <= 0)
	     {
	        aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticGiftDance);
                aiPlanAddUnitType(gNativeDancePlan, gEconUnit, want/2, want, want*2);
	        lastTactic = cTacticGiftDance;
	        lastTacticTime = xsGetTime();   
	         return;
	     }
             return;  //don't strike out this 'return'!	   
          }
         /* if ((xpMedicineManCount < 2-natMedicineManCount-surgeonCount) && (2-natMedicineManCount-surgeonCount>0) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 40))
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticHolyDance);
             lastTactic = cTacticHolyDance;
             lastTacticTime = xsGetTime();
             return;
          }*/
          
          break;
       }
       case cCivXPIroquois:
       {        
          // Select a tactic 
          if (kbGetAge() < cAge2) 
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticGiftDance);
             lastTactic = cTacticGiftDance;
             lastTacticTime = xsGetTime();    
             return;
          }

          // Recover war chief
          if (aiGetFallenExplorerID() >= 0)
          {	
	     aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarChiefDance);
	     lastTactic = cTacticWarChiefDance;		
	     lastTacticTime = xsGetTime();
	     return;
          }         

          // Travois(Iroquois only)
          // To be used only if they still make sense, i.e. if there are buildings left to be erected(gXPBuilderNeeded > 0). 
          if ( (kbUnitCount(cMyID, cUnitTypexpBuilder, cUnitStateAlive) < kbGetAge()) && (gDefenseReflexBaseID != kbBaseGetMainID(cMyID)))
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticFounderDance);
             if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) - 5 < 6 - numWarPriests)
	       tempDancers = kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) - 5;
             else
	       tempDancers = 6 - numWarPriests;     
             if ((lastTactic != cTacticWarDance) &&(tempDancers > want))	      
	       aiPlanAddUnitType(gNativeDancePlan, gEconUnit, tempDancers, tempDancers, tempDancers);
	       lastTactic = cTacticFounderDance;
	       lastTacticTime = xsGetTime();
	     return;
          }

          // Train units faster
          if ((aiPlanGetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0) > (kbUnitCount(cMyID, gEconUnit, cUnitStateABQ))) && (kbGetPop() < kbGetPopCap()))
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticFertilityDance);
             aiPlanAddUnitType(gNativeDancePlan, gEconUnit, want/2, want, want*2);
             lastTactic = cTacticFertilityDance;
             lastTacticTime = xsGetTime();
             return;
          }

          // It's time to start war dance
          if (warDanceBool == true)
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarDance);
             if ( (lastTactic != cTacticGarlandWarDance) && (lastTactic != cTacticWarDanceSong) )
	     {
		 tempDancers = enemyPointCount + mySelfPointCount - numWarPriests - 25;
		 if (tempDancers > 25-numWarPriests)
		   tempDancers = 25-numWarPriests;
		 if  (tempDancers > want)
		   aiPlanAddUnitType(gNativeDancePlan, gEconUnit, tempDancers, tempDancers, tempDancers);
             }
	     lastTactic = cTacticWarDance;
             lastTacticTime = xsGetTime();
             return;
          }
          // increase population capacity (Iroquois only)
          if ( (kbGetAge() >= cAge3) && 
               (gMaxPop - kbGetPop()<=1) &&
	       ((lastTactic != cTacticEarthMotherDance) || 
               ((lastTactic == cTacticEarthMotherDance) && 
                (kbGetPopCap()-kbGetPop()>=1))))
          {
	     aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticEarthMotherDance);
	     //aiPlanAddUnitType(gNativeDancePlan, gEconUnit, (25-numWarPriests), (25-numWarPriests), (25-numWarPriests));
	     lastTactic = cTacticEarthMotherDance;
	     lastTacticTime = xsGetTime();
	     return;
          }           
          /* Alarm dance if base is under attack
          if ( (gDefenseReflexBaseID == kbBaseGetMainID(cMyID)) && (kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) < 6))
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticAlarmDance);
	     lastTactic = cTacticAlarmDance;
	     lastTacticTime = xsGetTime();
	     return;
          } 
          
          if ((xpMedicineManCount < 2-natMedicineManCount-surgeonCount) && (2-natMedicineManCount-surgeonCount>0) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 40))
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticHolyDance);
             lastTactic = cTacticHolyDance;
             lastTacticTime = xsGetTime();
             return;
          }*/
          
          break;
       }
       case cCivXPAztec:
       {      
          // Select a tactic 
          if (kbGetAge() < cAge2) 
          {
             aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticGiftDance);
             lastTactic = cTacticGiftDance;
             lastTacticTime = xsGetTime();    
             return;
          }

          // Recover war chief
          if (aiGetFallenExplorerID() >= 0)
          {	
	     aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarChiefDanceAztec);
	     lastTactic = cTacticWarChiefDanceAztec;	
	     lastTacticTime = xsGetTime();
	     return;
          }

          // Spawn warrior priests to the limit(10) (Aztecs only).
          if (kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive) < 10)
          {
             static bool MilitaryGatherPointShift = false;
             static vector tempVector = cInvalidVector;
             if (MilitaryGatherPointShift == false)
             {	     
	        tempVector = kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID));
	        MilitaryGatherPointShift = true;
             }
             if (lastTactic == cTacticHolyDanceAztec)
	        kbBaseSetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID), kbUnitGetPosition(getUnit(cUnitTypeFirePit)));	
             else
	        kbBaseSetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID), tempVector);

             bool permitDance = false;
             if (btRushBoom <= 0.0)
             {
	        if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 35)
	          permitDance = true;
             }
             else if  (btRushBoom > 0.0)
             {
	        if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 25)
	          permitDance = true;
             }

             if ((permitDance == true) && (gDefenseReflexBaseID != kbBaseGetMainID(cMyID)))
             {
	        aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticHolyDanceAztec);
	        if (kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive) < 8)
	        aiPlanAddUnitType(gNativeDancePlan, gEconUnit, (25-numWarPriests), (25-numWarPriests), (25-numWarPriests));
	        lastTactic = cTacticHolyDanceAztec;
	        lastTacticTime = xsGetTime();
             }
             return;
           }

           // Train units faster
           if ((aiPlanGetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0) > (kbUnitCount(cMyID, gEconUnit, cUnitStateABQ))) && (kbGetPop() < kbGetPopCap()))
           {
              aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticFertilityDance);
              aiPlanAddUnitType(gNativeDancePlan, gEconUnit, want/2, want, want*2);
              lastTactic = cTacticFertilityDance;
              lastTacticTime = xsGetTime();
              return;
           }

           // It's time to start war dance
           if (warDanceBool == true)
           {
              aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarDance);
              if ( (lastTactic != cTacticGarlandWarDance) && (lastTactic != cTacticWarDanceSong) )
	      {
		  tempDancers = enemyPointCount + mySelfPointCount - numWarPriests - 25;
		  if (tempDancers > 25-numWarPriests)
		    tempDancers = 25-numWarPriests;
		  if  (tempDancers > want)
		    aiPlanAddUnitType(gNativeDancePlan, gEconUnit, tempDancers, tempDancers, tempDancers);
              }
	      lastTactic = cTacticWarDance;
              lastTacticTime = xsGetTime();
              return;
           }

           // It's time to start healing dance
           if ( (kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive) >= 7) && (lastTactic != cTacticWarDance) && (gDefenseReflexBaseID != kbBaseGetMainID(cMyID)))
           {
              if (getPlayerArmyHPs(cMyID, true)/getPlayerArmyHPs(cMyID, false) < 0.9)
              {
	         aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticHealingDance);
	         lastTactic = cTacticWarDance;
	         lastTacticTime = xsGetTime();
	         return;

              }
           }
           /* Alarm dance if base is under attack
           if ( (gDefenseReflexBaseID == kbBaseGetMainID(cMyID)) && (kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) < 6))
           {
              aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticAlarmDance);
	      lastTactic = cTacticAlarmDance;
	      lastTacticTime = xsGetTime();
	      return;
           } */
           
           // Spawn skull knights in age 4 or 5 (Aztecs only)
           if ( (kbGetAge() >= cAge4) && (kbUnitCount(cMyID, cUnitTypexpSkullKnight, cUnitStateAlive) < 20) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 35) && (gDefenseReflexBaseID != kbBaseGetMainID(cMyID)))
           {
              popThreshold = kbGetPopCap() - 30;
              if (kbGetPop() < popThreshold)
              {
	         aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticGarlandWarDance);
	         aiPlanAddUnitType(gNativeDancePlan, gEconUnit, (22-numWarPriests), (22-numWarPriests), (22-numWarPriests));
	         lastTactic = cTacticGarlandWarDance;
	         lastTacticTime = xsGetTime();
	         return;
              }
              if (kbGetPopCap() - kbGetPop() <= 0)
              {
	         aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticGiftDance);
                 aiPlanAddUnitType(gNativeDancePlan, gEconUnit, want/2, want, want*2);
	         lastTactic = cTacticGiftDance;
	         lastTacticTime = xsGetTime();   
                 return;
              }
              return; //don't strike out this 'return'!
           }
           
           break;
        }
    }
}


//==============================================================================
/* Rice Paddy Monitor

   Switch from Food to Coin.

cTacticPaddyFood
cTacticPaddyCoin

*/
//==============================================================================
rule ricepaddyMonitor
inactive
group tcComplete
minInterval 15
{
   if (civIsAsian() == false)
   {
      xsDisableSelf();
      return;
   }
       
   //gotta get all of the paddies
   static int paddyQueryID=-1;
   
   //If we don't have the query yet, create one.
   if (paddyQueryID < 0)
   {
      paddyQueryID=kbUnitQueryCreate("paddyGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(paddyQueryID, true);
   }

   //Define a query to get all matching units
   if (paddyQueryID != -1)
   {
       kbUnitQuerySetPlayerRelation(paddyQueryID, -1);
       kbUnitQuerySetPlayerID(paddyQueryID, cMyID);
       kbUnitQuerySetUnitType(paddyQueryID, cUnitTypeypRicePaddy);
       kbUnitQuerySetState(paddyQueryID, cUnitStateAlive);
   }
   else
     return;

    kbUnitQueryResetResults(paddyQueryID);
    int numberFound=kbUnitQueryExecute(paddyQueryID);
    int index = 0;
    //Get our current resources.
    float currentFood=kbResourceGet(cResourceFood);
    float currentWood=kbResourceGet(cResourceWood);
    float currentGold=kbResourceGet(cResourceGold);
    // Select a tactic
    static int lastricefood = 0;
   
    int foodriceNeeded = 1 + kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive)*0.5;
    float percentOnGold = aiGetResourceGathererPercentage(cResourceGold, cRGPActual);
   
    if (currentGold < (currentFood*1.2)/4)
    {  foodriceNeeded--;  }
    //if (percentOnGold < 0.45) 
    //{  foodriceNeeded--;  }
  
    if (foodriceNeeded != lastricefood)
    {
        lastricefood = foodriceNeeded;
        for (index = 0; <foodriceNeeded) 
        {
           //change the rice to food
           aiUnitSetTactic(kbUnitQueryGetResult(paddyQueryID, index), cTacticPaddyFood);
        }
        for (index = foodriceNeeded; < numberFound) 
        {
           //change the rice to coin
           aiUnitSetTactic(kbUnitQueryGetResult(paddyQueryID, index), cTacticPaddyCoin);
        }
    }
}


//==============================================================================
/* Shrine Monitor

   Uses shrine wagons to build shrines. In Age 3 and above shrine production
   is cycled through the resource options once per minute.

*/
//==============================================================================
rule shrineMonitor
inactive
group tcComplete
minInterval 21
{
   // Disable for anybody but Japanese
   if (kbGetCiv() != cCivJapanese)
   {
      xsDisableSelf();
      return;
   }
   
   // Cycle through resource generation options
   static int shrineTactic = -1;
   
   // Define a query to get all matching units
   int shrineQueryID=-1;
   shrineQueryID=kbUnitQueryCreate("shrineGetUnitQuery");
   kbUnitQuerySetIgnoreKnockedOutUnits(shrineQueryID, true);
   if (shrineQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(shrineQueryID, -1);
      kbUnitQuerySetPlayerID(shrineQueryID, cMyID);
      kbUnitQuerySetUnitType(shrineQueryID, cUnitTypeypShrineJapanese);
      kbUnitQuerySetState(shrineQueryID, cUnitStateAlive);
      kbUnitQueryResetResults(shrineQueryID);
      int numberFound=kbUnitQueryExecute(shrineQueryID);
      if (numberFound > 0)
      {
         shrineTactic = shrineTactic + 1;
         if (shrineTactic > 8)
            shrineTactic = 0;
         switch(shrineTactic)
         {
            case 0:
            {
               aiUnitSetTactic(kbUnitQueryGetResult(shrineQueryID, 0), cTacticShrineFood);
               break;
            }
            case 3:
            {
               aiUnitSetTactic(kbUnitQueryGetResult(shrineQueryID, 0), cTacticShrineWood);
               break;
            }
            case 6:
            {
               aiUnitSetTactic(kbUnitQueryGetResult(shrineQueryID, 0), cTacticShrineCoin);
               break;
            }
            default:
            {
               aiUnitSetTactic(kbUnitQueryGetResult(shrineQueryID, 0), cTacticShrineXP);
               break;
            }
         }
      }
   }   
}


//==============================================================================
/* rule defenseReflex

   Monitor each VP site that we own, plus our main base.  Move and reconfigure 
   the defense and reserve plans as needed.

   At rest, the defend plan has only one unit, is centered on the main base, and
   is used to send one unit after trivial invasions, typically a scouting unit. 
   The reserve plan has a much larger MAX number, so it gets all the remaining units.
   It is centered on the military gather point with a conservative radius, to avoid
   engaging units far in front of the main base.

   When defending a base in a defense reflex, the defend plan gets a high MAX number
   so that it takes units from the reserve plan.  The low unit count in reserve 
   acts as a signal to not launch new attacks, as troops aren't available.  The 
   defend plan and reserve plan are relocated to the endangered base, with an aggressive
   engage radius.

   The search, active engage and passive engage radii are set by global 
   control variables, cvDefenseReflexRadiusActive, cvDefenseReflexRadiusPassive, and
   cvDefenseReflexSearchRadius.
   
   Once in a defense reflex, the AI stays in it until that base is cleared, unless
   it's defending a non-main base, and the main base requires defense.  In that case,
   the defense reflex moves back to the main base.
   
   pauseDefenseReflex() can only be used when already in a defense reflex.  So valid 
   state transitions are:

   none to defending       // start reflex with moveDefenseReflex(), sets all the base/location globals.
   defending to paused     // use pauseDefenseReflex(), takes no parms, uses vars set in prior moveDefenseReflex call.
   defending to end        // use endDefenseReflex(), clears global vars
   paused to end           // use endDefenseReflex(), clears global vars
   paused to defending     // use moveDefenseReflex(), set global vars again.

*/
//==============================================================================
// 

rule defenseReflex
inactive
minInterval 15
group startup
{
   int armySize = aiPlanGetNumberUnits(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary) + aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
   int enemyArmySize = -1;
   static int lastHelpTime = -60000;
   static int lastHelpBaseID = -1;
   int i = 1;
   int unitID = -1;
   int protoUnitID = -1;
   int player = 1;
   bool panic = false;  // Indicates need for call for help
   
   static int enemyArmyQuery = -1;
   if (enemyArmyQuery < 0)
   {  // Initialize the queryID
      enemyArmyQuery = kbUnitQueryCreate("Enemy army query");
      kbUnitQuerySetIgnoreKnockedOutUnits(enemyArmyQuery, true);
      kbUnitQuerySetPlayerRelation(enemyArmyQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetUnitType(enemyArmyQuery, cUnitTypeLogicalTypeLandMilitary);
      kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
      kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);   // Ignore units we think are under fog
   }
   
   // Check main base first
   kbUnitQuerySetPosition(enemyArmyQuery,  kbBaseGetLocation(cMyID,  kbBaseGetMainID(cMyID)));
   kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius);   
   kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
   kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
   kbUnitQueryResetResults(enemyArmyQuery);
   enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
   if (enemyArmySize >= 2)
   {  // Main base is under attack
      aiEcho("******** Main base ("+kbBaseGetMainID(cMyID)+") under attack.");
      aiEcho("******** Enemy count "+enemyArmySize+", my army count "+armySize);      
      if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      {  // We're already in a defense reflex for the main base
         if (  ((armySize * 1.5) < enemyArmySize)  && (enemyArmySize - armySize > 6.0) )  // Army at least 1.5x my size and more than 6 units total.
         {  // Too big to handle
            if (gDefenseReflexPaused == false)
            {  // We weren't paused, do it
               pauseDefenseReflex();
            }
            // Consider a call for help
            panic = true;
            if ( ((xsGetTime() - lastHelpTime) < 150000) && (lastHelpBaseID == gDefenseReflexBaseID) )  // We called for help in the last five minutes, and it was this base
               panic = false;
            if ( ((xsGetTime() - lastHelpTime) < 60000) && (lastHelpBaseID != gDefenseReflexBaseID) )  // We called for help anywhere in the last minute
               panic = false;
            
            if (panic == true)
            {
               sendStatement(cPlayerRelationAlly, cAICommPromptToAllyINeedHelpMyBase, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
               aiEcho("     I'm calling for help.");
               lastHelpTime = xsGetTime();
            }
         } 
         else
         {  // Size is OK to handle, shouldn't be in paused mode.
            if (gDefenseReflexPaused == true)   // Need to turn it active
            {
               moveDefenseReflex( kbBaseGetLocation(cMyID,  kbBaseGetMainID(cMyID)), cvDefenseReflexRadiusActive, kbBaseGetMainID(cMyID));
            }
         }
      }
      else  // Defense reflex wasn't set to main base.
      {  // Need to set the defense reflex to home base...doesn't matter if it was inactive or guarding another base, home base trumps all.
          moveDefenseReflex( kbBaseGetLocation(cMyID,  kbBaseGetMainID(cMyID)), cvDefenseReflexRadiusActive, kbBaseGetMainID(cMyID));
         // This is a new defense reflex in the main base.  Consider making a chat about it.
         int enemyPlayerID = kbUnitGetPlayerID(kbUnitQueryGetResult(enemyArmyQuery, 0));
         if ( (enemyPlayerID > 0) && (kbGetAge() > cAge1) ) 
         {  // Consider sending a chat as long as we're out of age 1.
            int enemyPlayerUnitCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, enemyPlayerID, cUnitStateAlive, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID), 50.0);
            if ( (enemyPlayerUnitCount > (2 * gGoodArmyPop)) && (enemyPlayerUnitCount > (3* armySize)) )
            {  // Enemy army is big, and we're badly outnumbered
               sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseOverrun, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
               aiEcho("Sending OVERRUN prompt to player "+enemyPlayerID+", he has "+enemyPlayerUnitCount+" units.");
               aiEcho("I have "+armySize+" units, and "+gGoodArmyPop+" is a good army size.");
               return;
            }
            if (enemyPlayerUnitCount > (2 * gGoodArmyPop))
            {  // Big army, but I'm still in the fight
               sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseLarge, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
               aiEcho("Sending LARGE ARMY prompt to player "+enemyPlayerID+", he has "+enemyPlayerUnitCount+" units.");
               aiEcho("I have "+armySize+" units, and "+gGoodArmyPop+" is a good army size.");
               return;
            }
            if (enemyPlayerUnitCount > gGoodArmyPop)
            {
               // Moderate size
               sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseMedium, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
               aiEcho("Sending MEDIUM ARMY prompt to player "+enemyPlayerID+", he has "+enemyPlayerUnitCount+" units.");
               aiEcho("I have "+armySize+" units, and "+gGoodArmyPop+" is a good army size.");
               return;
            }
            if ( (enemyPlayerUnitCount < gGoodArmyPop) && (enemyPlayerUnitCount < armySize) )
            {  // Small, and under control
               sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseSmall, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
               aiEcho("Sending SMALL ARMY prompt to player "+enemyPlayerID+", he has "+enemyPlayerUnitCount+" units.");
               aiEcho("I have "+armySize+" units, and "+gGoodArmyPop+" is a good army size.");
               return;
            }
         }
      }
      return;  // Do not check other bases
   }
   
   // If we're this far, the main base is OK.  If we're in a defense reflex, see if we should stay in it, or change from passive to active.
   
   if (gDefenseReflex == true) // Currently in a defense mode, let's see if it should remain
   {
      kbUnitQuerySetPosition(enemyArmyQuery, gDefenseReflexLocation);
      kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius);  
      kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
      kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
      kbUnitQueryResetResults(enemyArmyQuery);
      enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
      aiEcho("******** Defense reflex in base "+gDefenseReflexBaseID+" at "+gDefenseReflexLocation);
      aiEcho("******** Enemy unit count: "+enemyArmySize+", my unit count (defend+reserve) = "+armySize);
      for (i=0; < enemyArmySize)
      {
         unitID = kbUnitQueryGetResult(enemyArmyQuery, i);
         protoUnitID = kbUnitGetProtoUnitID(unitID);
         if (i < 2)
            aiEcho("    "+unitID+" "+kbGetProtoUnitName(protoUnitID)+" "+kbUnitGetPosition(unitID));
      }

      if (enemyArmySize < 2)
      {  // Abort, no enemies, or just one scouting unit
         aiEcho("******** Ending defense reflex, no enemies remain.");
         endDefenseReflex();
         return;
      }      

      if (baseBuildingCount(gDefenseReflexBaseID) <= 0)
      {  // Abort, no buildings
         aiEcho("******** Ending defense reflex, base "+gDefenseReflexBaseID+" has no buildings.");
         endDefenseReflex();
         return;
      }
      
      if ( kbBaseGetOwner(gDefenseReflexBaseID) <= 0)
      {  // Abort, base doesn't exist
         aiEcho("******** Ending defense reflex, base "+gDefenseReflexBaseID+" doesn't exist.");
         endDefenseReflex();
         return;
      }
      
      // The defense reflex for this base should remain in effect.
      // Check whether to start/end paused mode.
      int unitsNeeded = gGoodArmyPop;        // At least a credible army to fight them
      if (unitsNeeded > (enemyArmySize/2))   // Or half their force, whichever is less.
         unitsNeeded = enemyArmySize/2;
      bool shouldPause = false;
      if ( (armySize < unitsNeeded) && ( (armySize * 1.5) < enemyArmySize) )
         shouldPause = true;  // We should pause if not paused, or stay paused if we are
      
      if (gDefenseReflexPaused == false)
      {  // Not currently paused, do it
         if (shouldPause == true)
         {
            pauseDefenseReflex();
            aiEcho("******** Enemy count "+enemyArmySize+", my army count "+armySize);
         }
      }
      else
      {  // Currently paused...should we remain paused, or go active?
         if ( shouldPause == false )
         {
            moveDefenseReflex(gDefenseReflexLocation, cvDefenseReflexRadiusActive, gDefenseReflexBaseID);   // Activate it 
            aiEcho("******** Enemy count "+enemyArmySize+", my army count "+armySize);
         }
      }
      if (shouldPause == true)
      {  // Consider a call for help
         panic = true;
         if ( ((xsGetTime() - lastHelpTime) < 300000) && (lastHelpBaseID == gDefenseReflexBaseID) )  // We called for help in the last five minutes, and it was this base
            panic = false;
         if ( ((xsGetTime() - lastHelpTime) < 60000) && (lastHelpBaseID != gDefenseReflexBaseID) )  // We called for help anywhere in the last minute
            panic = false;
         
         if (panic == true)
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyINeedHelpMyBase, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
            aiEcho("     I'm calling for help.");
            lastHelpTime = xsGetTime();
         }         
      }
      return;  // Done...we're staying in defense mode for this base, and have paused or gone active as needed.
   }

   
   // Not in a defense reflex, see if one is needed
 
   // Check other bases
   int baseCount = -1;
   int baseIndex = -1;
   int baseID = -1;

   baseCount = kbBaseGetNumber(cMyID);
   unitsNeeded = gGoodArmyPop/2;
   if (baseCount > 0)
   {
      for(baseIndex=0; < baseCount) 
      {
         baseID = kbBaseGetIDByIndex(cMyID, baseIndex);         
         if (baseID == kbBaseGetMainID(cMyID))
            continue;   // Already checked main at top of function
         
         if (baseBuildingCount(baseID) <= 0)
         {
            aiEcho("Base "+baseID+" has no buildings.");
            continue;   // Skip bases that have no buildings
         }

         // Check for overrun base
         kbUnitQuerySetPosition(enemyArmyQuery,  kbBaseGetLocation(cMyID, baseID));
         kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius); 
         kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
         kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
         kbUnitQueryResetResults(enemyArmyQuery);
         enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
         // Do I need to call for help?

         if ( (enemyArmySize >= 2)  )
         {  // More than just a scout...set defense reflex for this base
            moveDefenseReflex(kbBaseGetLocation(cMyID, baseID), cvDefenseReflexRadiusActive, baseID);
            
            aiEcho("******** Enemy count is "+enemyArmySize+", my army size is "+armySize);                  

            if ( (enemyArmySize > (armySize * 1.5)) && (enemyArmySize - armySize > 6.0))   // Double my size, get help...
            {
               panic = true;
               if ( ((xsGetTime() - lastHelpTime) < 300000) && (lastHelpBaseID == baseID) )  // We called for help in the last five minutes, and it was this base
                  panic = false;
               if ( ((xsGetTime() - lastHelpTime) < 60000) && (lastHelpBaseID != baseID) )  // We called for help anywhere in the last minute
                  panic = false;
               
               if (panic == true)
               {
                  // Don't kill other missions, this isn't the main base.  Just call for help.
                  sendStatement(cPlayerRelationAlly, cAICommPromptToAllyINeedHelpMyBase, kbBaseGetLocation(cMyID, baseID));
                  aiEcho("I'm calling for help.");
                  lastHelpTime = xsGetTime();
               }
                  
            }
            return;     // If we're in trouble in any base, ignore the others.
         } 
      }  // For baseIndex...
   }
}

rule shouldIMigrate
inactive
minInterval 17
group startup
{   
   int armySize = aiPlanGetNumberUnits(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary) + aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);  
   int enemyArmySize = -1;   
   bool migrate = false;
   static int enemyArmyQuery = -1;
   if (enemyArmyQuery < 0)
   {  // Initialize the queryID
      enemyArmyQuery = kbUnitQueryCreate("Enemy army query");
      kbUnitQuerySetIgnoreKnockedOutUnits(enemyArmyQuery, true);
      kbUnitQuerySetPlayerRelation(enemyArmyQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetUnitType(enemyArmyQuery, cUnitTypeLogicalTypeLandMilitary);
      kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
      kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);   // Ignore units we think are under fog
   }
   
   static int allyArmyQuery = -1;
   int allyArmySize = -1;
   if (allyArmyQuery < 0)
   {
      allyArmyQuery = kbUnitQueryCreate("Ally army query ");
      kbUnitQuerySetIgnoreKnockedOutUnits(allyArmyQuery, true);
      kbUnitQuerySetPlayerRelation(allyArmyQuery, cPlayerRelationAlly);
      kbUnitQuerySetUnitType(allyArmyQuery, cUnitTypeLogicalTypeLandMilitary);
      kbUnitQuerySetState(allyArmyQuery, cUnitStateAlive);      
   }
        
   // Check main base first
   kbUnitQuerySetPosition(enemyArmyQuery,  kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
   kbUnitQuerySetPosition(allyArmyQuery, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
   kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius);
   kbUnitQuerySetMaximumDistance(allyArmyQuery, cvDefenseReflexRadiusActive + 5.0);
   kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
   kbUnitQuerySetSeeableOnly(allyArmyQuery, true);
   kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
   kbUnitQuerySetState(allyArmyQuery, cUnitStateAlive);
   kbUnitQueryResetResults(enemyArmyQuery);
   kbUnitQueryResetResults(allyArmyQuery);
   enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
   allyArmySize = kbUnitQueryExecute(allyArmyQuery);

   if (enemyArmySize < 2)
      return;
   
   if (enemyArmySize >= 2)
   {  
      // Enemy army size at least 3x my size and more than 20 units total. Thus, we migrate
      if ( (((armySize+allyArmySize) * 3.0) < enemyArmySize) && (enemyArmySize - (armySize+allyArmySize) > 20) )
      {  // Too big to handle                      
         xsEnableRule("createNewBase");               
      }           
   }   
}

//==============================================================================
/*
   createHomeBase

   If there is a completed town center, use it.  Failing that, Wait until the 
   town center is complete, then build other stuff next to it.

*/
//==============================================================================
rule createNewBase
inactive
minInterval 15
{
   // First, create a query if needed, then use it to look for a completed town center
   static int townCenterQuery = -1;
   if (townCenterQuery < 0)
   {
      townCenterQuery=kbUnitQueryCreate("Completed Town Center Query");
      kbUnitQuerySetIgnoreKnockedOutUnits(townCenterQuery, true);
   }  
   //Define the query
   if (townCenterQuery != -1)
   {
      kbUnitQuerySetPlayerRelation(townCenterQuery, -1);
      kbUnitQuerySetPlayerID(townCenterQuery, cMyID);
      kbUnitQuerySetUnitType(townCenterQuery, cUnitTypeTownCenter);
      kbUnitQuerySetState(townCenterQuery, cUnitStateAlive);	  
   }  
   
   // Run the query
   kbUnitQueryResetResults(townCenterQuery);
   int count = kbUnitQueryExecute(townCenterQuery);
       
   if (count < 1) 
      return;  

   for (i=0; < count)
   {
      int tcID = kbUnitQueryGetResult(townCenterQuery, i);
      aiEcho("New TC is "+tcID+" at "+kbUnitGetPosition(tcID));
   }

   if (findACompletedTownCenter() == true)  
   {      
      int tcBase = kbUnitGetBaseID(tcID);
      gMainBase = kbBaseGetMainID(cMyID);      
      aiEcho(" TC base is "+tcBase+", main base is "+gMainBase);
      // We have a TC.  Make sure that the main base exists, and it includes the TC
      if ( gMainBase < 0 )
      {  // We have no main base, create one
         gMainBase = createMainBase(kbUnitGetPosition(tcID));
         aiEcho(" We had no main base, so we created one: "+gMainBase);
      }
      tcBase = kbUnitGetBaseID(tcID);  // in case base ID just changed
      if ( tcBase != gMainBase ) 
      {
         aiEcho(" TC "+tcID+" is not in the main base ("+gMainBase+".");
         aiEcho(" Setting base "+gMainBase+" to non-main, setting base "+tcBase+" to main.");
         kbBaseSetMain(cMyID, gMainBase, false);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHuntAggressive, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, gMainBase);
         aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, gMainBase);
         aiRemoveResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, gMainBase);
         aiRemoveResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, gMainBase);
         kbBaseSetMain(cMyID, tcBase, true);
         kbBaseSetSettlement(cMyID, tcBase, true);
         gMainBase = tcBase;
      }               
   }
   else
   {
      aiEcho(" Wait until the town center is complete ");
      return; 
   }

   // Town center found, start building the other buildings
   xsDisableSelf();
}

//==============================================================================
/*
   selectCaptain

   Updates the global gIAmCaptain bool.  Also sets the gCaptainPlayerNumber int.
   Algorithm is brain-dead simple.
   I am captain if I am the lowest-numbered AI player on a team with no 
   human players.  Otherwise, I am not captain.

*/
//==============================================================================
rule selectCaptain
active
minInterval 30
{
   int player = -1;
   bool amCaptain = false;  // Unless proven otherwise
   bool humanTeammate = false;   // Set true if/when a human teammate is found
   int captainsNumber = -1;   // Set when we find a captain


   for (player = 1; < cNumberPlayers)
   {
      if (kbHasPlayerLost(player) == false)
      {
         if (kbIsPlayerAlly(player) == true)
         {
            // if this player is human, that's the captainsNumber
            if ( (kbIsPlayerHuman(player) == true) && (kbHasPlayerLost(player) == false) && (humanTeammate == false) )
            {
               amCaptain = false;         // AI player is definitely not human
               captainsNumber = player;
               humanTeammate = true;
            }
            else
            {  // This is an AI player or a human player other than the first.  If it's not me and has a lower number and there's no human yet, he's captain.
               if( (kbIsPlayerHuman(player) == false) && (kbHasPlayerLost(player) == false)  && (humanTeammate == false) )
               {
                  if ( (player <= cMyID) && (captainsNumber < 0) )   // He's <= me and there's no captain yet
                  {
                     captainsNumber = player;
                     if (player == cMyID)
                        amCaptain = true;    // I'm the captain...unless human player is found later.
                  }
               }
            }
         }
      }
   }  // End for(player) loop.
   if ( (captainsNumber != gCaptainPlayerNumber) || (gIAmCaptain != amCaptain) )
   {  // Something changed
      aiEcho("***  Old captain was "+gCaptainPlayerNumber+", new captain is "+captainsNumber);
      gCaptainPlayerNumber = captainsNumber;
      gIAmCaptain = amCaptain;
   }
}

int getMapID(void)
{
   int mapIndex = 0;
   for (mapIndex = 0; < xsArrayGetSize(gMapNames))
   {
      if ( xsArrayGetString(gMapNames, mapIndex) == cRandomMapName )
      {
         return(mapIndex);
      }
   }
   return(-1);
}

//==============================================================================
/* initPersonality()
   
   A function to set defaults that need to be in place before the loader file's
   preInit() function is called.  
*/
//==============================================================================
void initPersonality(void)
{   
   int civ = kbGetCiv();
   if (civ == cCivTheCircle)
      civ = cCivBritish;
   if (civ == cCivPirate)
      civ = cCivBritish;
   if (civ == cCivSPCAct3)
      civ = cCivBritish;
   if (civ == cCivSPCIndians)
      civ = cCivIndians;
   if (civ == cCivSPCChinese)
      civ = cCivChinese;
   if (civ == cCivSPCJapanese)
      civ = cCivJapanese;
   // Set behavior traits
   aiEcho("My civ is "+civ);
   
   switch(civ)
   {
      case cCivBritish:    // Elizabeth:  Infantry oriented boomer, favors natives
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.2;
         btBiasInf = 0.7;
         btBiasArt = 0.1;
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivFrench:     // Napoleon:  Cav oriented, balanced, favors natives
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.5;
         btBiasInf = 0.4;
         btBiasArt = 0.1;
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivSpanish:    // Isabella:  Rusher, disdains trading posts
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.4;
         btBiasInf = 0.5;
         btBiasArt = 0.1;
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivRussians:   // Ivan:  Infantry oriented turtler
      {    // Slight boomer, he needs the econ in age 2 to keep settlers training.
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.2;
         btBiasInf = 0.7;
         btBiasArt = 0.1;
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivGermans:    // Cavalry oriented rusher
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.4;
         btBiasInf = 0.5;
         btBiasArt = 0.1;
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivDutch:      // Turtler, boomish, huge emphasis on trade
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.4;
         btBiasInf = 0.4;
         btBiasArt = 0.1;
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivPortuguese: // Artillery oriented boomer, favors trade   
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.3;
         btBiasInf = 0.5;
         btBiasArt = 0.2;  // TODO - boost artillery
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivOttomans:   // Artillery oriented, balanced
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.3;
         btBiasInf = 0.4;
         btBiasArt = 0.3;  // TODO - boost artillery 
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivXPSioux:   // Extreme rush, ignores trade routes
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.9;
         btBiasInf = 0.1;
         btBiasArt = 0.0;  
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivXPIroquois:   // Balanced, trade and native bias.
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.2;
         btBiasInf = 0.7;
         btBiasArt = 0.1;   
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivXPAztec:   // Chaotic, but usually light boom, defensive.
      {
         btRushBoom = 0.9;
         if (aiRandInt(10) < 3)
            btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         if (aiRandInt(10) < 3)
            btOffenseDefense = 0.9;
         btBiasCav = 0.0;
         btBiasInf = 1.0;
         btBiasArt = 0.0;  
         btBiasNative = -1.0;
         if (aiRandInt(10) < 3)
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         if (aiRandInt(10) < 3)
            btBiasTrade = 0.0;
         break;
      }
      case cCivChinese:   // Kangxi:  Infantry oriented turtler
      {
         btRushBoom = 0.9;   // Slight boomer, he needs the econ in age 2 to keep settlers training.
         btOffenseDefense = 0.9;
         btBiasCav = 0.1;
         btBiasInf = 0.8;
         btBiasArt = 0.1;
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivJapanese:   // Extreme rush, ignores trade routes
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.1;
         btBiasInf = 0.8;
         btBiasArt = 0.1;  
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
      case cCivIndians:    // Cavalry oriented rusher
      {
         btRushBoom = 0.9;
         btOffenseDefense = 0.9;
         btBiasCav = 0.4;
         btBiasInf = 0.5;
         btBiasArt = 0.1;
         btBiasNative = -1.0;
         btBiasTrade = 0.0;
         break;
      }
   }
   
   // randomize AI personalities for non-SPC/campaign games
   if (gSPC == false)
   {     
      gInitialStrategy = 1;
      
      // This AI randomly chooses from one of the six other personalities, and sets the 
      // variables accordingly.
      int choice = -1;
      choice = aiRandInt(4);     // 0..3 

      switch(choice)
      { /*
          case 0:  // Boomer
          {
               //btRushBoom = -0.5;
               //btOffenseDefense = 0.8;
               btRushBoom = -0.9;
               btOffenseDefense = -0.4;
               gInitialStrategy = 0;
               aiEcho("Choosing personality: FI");
               break;
          } */
          case 1:  // Rusher (Aggressive Rusher)
          {
               //btRushBoom = 0.8;
               //btOffenseDefense = 0.5; 
               btRushBoom = 0.9;
               btOffenseDefense = 0.9;
               gInitialStrategy = 1;             
               aiEcho("Choosing personality: Attacker");
               break;
          } /*
          case 2:  // Balanced
          {                
               //btRushBoom = 0.3;
               //btOffenseDefense = 0.5;
               btRushBoom = -0.4;
               btOffenseDefense = -0.2; 
               gInitialStrategy = 2;
               aiEcho("Choosing personality:  FF");
               break;
          }  
          case 3:  // Economic Boomer
          {               
               //btRushBoom = -0.9;
               //btOffenseDefense = 0.6;
               btRushBoom = -0.9;
               btOffenseDefense = -0.4; 
               gInitialStrategy = 3;
               aiEcho("Choosing personality:  Turtle");
               break;
          }   */
      }

      // Randomizing native bias
      // Native bias can be changed randomly, but will remain in the 0.0 - 1.0 area
      // Basic values of 0.0 or 1.0 won't be changed in two out of three cases
      // A basic value of 0.5 becomes almost completely random
      int nativeBiasRandomizer = aiRandInt(10);
      if (nativeBiasRandomizer < 1) // 10 % probability
      {
         btBiasNative = btBiasNative - 0.0;
         aiEcho("Native bias reduced by 1.0");
      }
      else if (nativeBiasRandomizer < 3) // 20 % probability
      {
         btBiasNative = btBiasNative - 0.0;
         aiEcho("Native bias reduced by 0.5");
      }
      else if (nativeBiasRandomizer < 7) // 40 % probability
      {
         aiEcho("Native bias unchanged");
      }
      else if (nativeBiasRandomizer < 9) // 20 % probability
      {
         btBiasNative = btBiasNative + 0.0;
         aiEcho("Native bias increased by 0.5");
      }
      else // 10 % probability
      {
         btBiasNative = btBiasNative + 0.0;
         aiEcho("Native bias increased by 1.0");
      }

      // Keep native bias in the 0.0 - 1.0 area
      if (btBiasNative > 1.0)
         btBiasNative = 1.0;
      if (btBiasNative < -0.5)
         btBiasNative = -0.5;
      aiEcho("Native bias set to "+btBiasNative);
   }

   // Set default politician choices
   aiSetPoliticianChoice(cAge2, aiGetPoliticianListByIndex(cAge2, 0));  // Just grab the first available
   aiSetPoliticianChoice(cAge3, aiGetPoliticianListByIndex(cAge3, 0));
   aiSetPoliticianChoice(cAge4, aiGetPoliticianListByIndex(cAge4, 0));
   aiSetPoliticianChoice(cAge5, aiGetPoliticianListByIndex(cAge5, 0));
  

   //-- See who we are playing against.  If we have played against these players before, seed out unitpicker data, and then chat some.
   //XS_HELP("float aiPersonalityGetGameResource(int playerHistoryIndex, int gameIndex, int resourceID): Returns the given resource from the gameIndex game. If gameIndex is -1, this will return the avg of all games played.")
   //XS_HELP("int aiPersonalityGetGameUnitCount(int playerHistoryIndex, int gameIndex, int unitType): Returns the unit count from the gameIndex game. If gameIndex is -1, this will return the avg of all games played.")
   // To understand my opponent's unit biases, I'll have to do the following:
   //          1)  Store the opponents civ each game
   //          2)  On game start, look up his civ from last game
   //          3)  Based on his civ, look up how many units he made of each class (inf, cav, art), compare to 'normal'.
   //          4)  Set unitPicker biases to counter what he's likely to send.  
   
	int numPlayerHistories = aiPersonalityGetNumberPlayerHistories();
	aiEcho("PlayerHistories: "+numPlayerHistories);
	for (pid = 1; < cNumberPlayers)
	{
		//-- Skip ourself.
		if (pid == cMyID)
			continue;

		//-- get player name
		string playerName = kbGetPlayerName(pid);
		aiEcho("PlayerName: "+playerName);

		//-- have we played against them before.
		int playerHistoryID = aiPersonalityGetPlayerHistoryIndex(playerName);
		if(playerHistoryID == -1)
		{
			aiEcho("PlayerName: Never played against");
			//-- Lets make a new player history.
			playerHistoryID = aiPersonalityCreatePlayerHistory(playerName);
         if (kbIsPlayerAlly(pid) == true)
            sendStatement(pid, cAICommPromptToAllyIntro); 
         else
            sendStatement(pid, cAICommPromptToEnemyIntro);
			if(playerHistoryID == -1)
			{
				aiEcho("PlayerName: Failed to create player history for "+playerName);
				continue;
			}
			aiEcho("PlayerName: Created new history for "+playerName);
		}
		else
		{
			//-- get how many times we have played against them.
			float totalGames = aiPersonalityGetPlayerGamesPlayed(playerHistoryID, cPlayerRelationAny);
			float numberGamePlayedAgainst = aiPersonalityGetPlayerGamesPlayed(playerHistoryID, cPlayerRelationEnemy);
			float numberGamesTheyWon = aiPersonalityGetTotalGameWins(playerHistoryID, cPlayerRelationEnemy);
			float myWinLossRatio = 1.0 - (numberGamesTheyWon/numberGamePlayedAgainst);
			aiEcho("PlayedAgainst: "+numberGamePlayedAgainst);
			aiEcho("TimesTheyWon: "+numberGamesTheyWon);
			aiEcho("MyWinLossRatio: "+myWinLossRatio);

			bool iWonOurLastGameAgainstEachOther = aiPersonalityGetDidIWinLastGameVS(playerHistoryID);
			//bool weWonOurLastGameTogether; <-- cant do yet.
         

			//-- get how fast they like to attack
         // Minus one game index gives an average.
			int avgFirstAttackTime = aiPersonalityGetGameFirstAttackTime(playerHistoryID, -1);
			aiEcho("Player's Avg first Attack time: "+avgFirstAttackTime);

			int lastFirstAttackTime = aiPersonalityGetGameFirstAttackTime(playerHistoryID, totalGames-1);
			aiEcho("Player's Last game first Attack time: "+lastFirstAttackTime);

			//-- save some info.
			aiPersonalitySetPlayerUserVar(playerHistoryID, "myWinLossPercentage", myWinLossRatio);
			//-- test, get the value back out
			float tempFloat = aiPersonalityGetPlayerUserVar(playerHistoryID, "myWinLossPercentage");
         
         // Consider chats based on player history...
         // First, combinations of "was ally last time" and "am ally this time"
         bool wasAllyLastTime = true;
         bool isAllyThisTime = true;
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "wasMyAllyLastGame") == 0.0)
            wasAllyLastTime = false;
         if (kbIsPlayerAlly(pid) == false)
            isAllyThisTime = false;
         bool difficultyIsHigher = false;
         bool difficultyIsLower = false;
         float lastDifficulty = aiPersonalityGetPlayerUserVar(playerHistoryID, "lastGameDifficulty");
         if (lastDifficulty >= 0.0)
         {
            if (lastDifficulty > aiGetWorldDifficulty())
               difficultyIsLower = true;
            if (lastDifficulty < aiGetWorldDifficulty())
               difficultyIsHigher = true;
         }
         bool iBeatHimLastTime = false;
         bool heBeatMeLastTime = false;
         bool iCarriedHimLastTime = false;
         bool heCarriedMeLastTime = false;
  
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "heBeatMeLastTime") == 1.0) // STORE ME
            heBeatMeLastTime = true;         
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iBeatHimLastTime") == 1.0) // STORE ME
            iBeatHimLastTime = true;
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime") == 1.0) // STORE ME
            iCarriedHimLastTime = true;
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime") == 1.0) // STORE ME
            heCarriedMeLastTime = true;
         
        
         if (wasAllyLastTime == false)
         {
            if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iBeatHimLastTime") == 1.0) // STORE ME
               iBeatHimLastTime = true;
            if (aiPersonalityGetPlayerUserVar(playerHistoryID, "heBeatMeLastTime") == 1.0) // STORE ME
               heBeatMeLastTime = true;
         }
         
         bool iWonLastGame = false;
         if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iWonLastGame") == 1.0) // STORE ME
            iWonLastGame = true;
         
        
         if (isAllyThisTime)
         {  // We are allies
            if (difficultyIsHigher == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenDifficultyHigher);
            if (difficultyIsLower == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenDifficultyLower);
            if (iCarriedHimLastTime == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenICarriedHimLastGame);
            if (heCarriedMeLastTime == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenHeCarriedMeLastGame);
            if (iBeatHimLastTime == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenIBeatHimLastGame);
            if (heBeatMeLastTime == true)
               sendStatement(pid, cAICommPromptToAllyIntroWhenHeBeatMeLastGame);

            aiEcho("Last map ID was "+aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID"));
            if ( (getMapID() >= 0) && (getMapID() == aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID")) )
            {
               sendStatement(pid, cAICommPromptToAllyIntroWhenMapRepeats);
               aiEcho("Last map ID was "+aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID"));
            }
            if (wasAllyLastTime)
            {               
               aiEcho(playerName + " was my ally last game and is my ally this game.");
               if (iWonLastGame == false)
                  sendStatement(pid, cAICommPromptToAllyIntroWhenWeLostLastGame);
               else
                  sendStatement(pid, cAICommPromptToAllyIntroWhenWeWonLastGame);
            }
            else
            {
               aiEcho(playerName + " was my enemy last game and is my ally this game.");
            }
         }
         else
         {  // We are enemies
            if (difficultyIsHigher == true)
               sendStatement(pid, cAICommPromptToEnemyIntroWhenDifficultyHigher);
            if (difficultyIsLower == true)
               sendStatement(pid, cAICommPromptToEnemyIntroWhenDifficultyLower);
            if ( (getMapID() >= 0) && (getMapID() == aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID")) )
               sendStatement(pid, cAICommPromptToEnemyIntroWhenMapRepeats);
            if (wasAllyLastTime)
            {
               aiEcho(playerName + " was my ally last game and is my enemy this game.");
            }
            else
            {
               aiEcho(playerName + " was my enemy last game and is my enemy this game.");
               // Check if he changed the odds
               // First, see if enemyCount is the same, but ally count is down
               int enemyCount = aiPersonalityGetPlayerUserVar(playerHistoryID, "myEnemyCount");
               int allyCount = aiPersonalityGetPlayerUserVar(playerHistoryID, "myAllyCount");
               if (enemyCount == getEnemyCount())
               {
                  if (allyCount > getAllyCount())  // I have fewer allies now
                     sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsEasier);  // He wimped out
                  if (allyCount < getAllyCount()) // I have more allies now
                     sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsHarder);  // He upped the difficulty
               }
               // Next, see if allyCount is the same, but enemyCount is smaller
               if (allyCount == getAllyCount())
               {
                  if (enemyCount > getEnemyCount())  // I have fewer enemies now
                     sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsHarder);  // He upped the difficulty
                  if (enemyCount < getEnemyCount()) // I have more enemies now
                     sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsEasier);  // He wimped out
               }               
            }
         }         
      }
      
      // Save info about this game
      aiPersonalitySetPlayerUserVar(playerHistoryID, "lastGameDifficulty", aiGetWorldDifficulty());
      int wasAlly = 0;
      if (kbIsPlayerAlly(pid)==true)
         wasAlly = 1;
      else
      {  // He is an enemy, remember the odds (i.e. 1v3, 2v2, etc.)
         aiPersonalitySetPlayerUserVar(playerHistoryID, "myAllyCount", getAllyCount());
         aiPersonalitySetPlayerUserVar(playerHistoryID, "myEnemyCount", getEnemyCount());         
      }
      aiPersonalitySetPlayerUserVar(playerHistoryID, "wasMyAllyLastGame", wasAlly);
      aiPersonalitySetPlayerUserVar(playerHistoryID, "lastMapID", getMapID());    
   }
}


void gameOverHandler(int nothing = 0)
{
   bool iWon = false;
	if(kbHasPlayerLost(cMyID) == false)
		iWon = true;

	aiEcho("Game is over.");
   aiEcho("Have I lost returns "+kbHasPlayerLost(cMyID));
   if(iWon == false)
      aiEcho("I lost.");
   else
      aiEcho("I won.");
   
	for (pid = 1; < cNumberPlayers)
	{
		//-- Skip ourself.
		if (pid == cMyID)
			continue;

		//-- get player name
		string playerName = kbGetPlayerName(pid);
		aiEcho("PlayerName: "+playerName);

		//-- Does a record exist?
		int playerHistoryID = aiPersonalityGetPlayerHistoryIndex(playerName);
		if(playerHistoryID == -1)
		{
			aiEcho("PlayerName: Never played against");
			//-- Lets make a new player history.
			playerHistoryID = aiPersonalityCreatePlayerHistory(playerName);
      }
      
      
/* Store the following user vars:
      heBeatMeLastTime
      iBeatHimLastTime
      iCarriedHimLastTime
      heCarriedMeLastTime
      iWonLastGame
*/            
      if (iWon == true)
      {  // I won
         aiPersonalitySetPlayerUserVar(playerHistoryID, "iWonLastGame", 1.0);
         if (kbIsPlayerEnemy(pid) == true)
         {
            aiPersonalitySetPlayerUserVar(playerHistoryID, "iBeatHimLastTime", 1.0);
            aiPersonalitySetPlayerUserVar(playerHistoryID, "heBeatMeLastTime", 0.0);
            aiEcho("This player was my enemy.");
         }
      }
      else
      {  // I lost
         aiPersonalitySetPlayerUserVar(playerHistoryID, "iWonLastGame", 0.0);
         if (kbIsPlayerEnemy(pid) == true)
         {
            aiPersonalitySetPlayerUserVar(playerHistoryID, "iBeatHimLastTime", 0.0);
            aiPersonalitySetPlayerUserVar(playerHistoryID, "heBeatMeLastTime", 1.0);
            aiEcho("This player was my enemy.");
         }
      }
      if (kbIsPlayerAlly(pid) == true)
      {  // Was my ally
         if ( aiGetScore(cMyID) > (2 * aiGetScore(pid)) )   
         {  // I outscored him badly
            aiPersonalitySetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime", 1.0);
            aiEcho("I carried my ally.");
         }
         else
            aiPersonalitySetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime", 0.0);
         if ( aiGetScore(pid) > (2 * aiGetScore(cMyID) ) )
         {  // My ally carried me.
            aiEcho("My ally carried me.");
            aiPersonalitySetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime", 1.0);
         }
         else
            aiPersonalitySetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime", 0.0);
      }
      else
      {
         aiPersonalitySetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime", 0.0);
         aiPersonalitySetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime", 0.0);
      }
      
   }
   
}


//==============================================================================
/* SPCInit()
   
   A function to set defaults that need to be in place before the loader file's
   preInit() function is called.  
*/
//==============================================================================
void SPCInit(void)
{
   // Taunt defaults to true, but needs to be false in scenario games.
   if (gSPC == true)
      cvOkToTaunt = false;
/*
   if (kbGetCiv() == cCivFrench)
   {
      int i = 0;
      for (i=0; <=cAge5)
      {  // Need fewer coureurs
         xsArraySetInt(gTargetSettlerCounts, i, xsArrayGetInt(gTargetSettlerCounts, i) * 0.9);
      }
   } */

   if ( (cRandomMapName == "amazonia") || 
        (cRandomMapName == "caribbean") || 
        (cRandomMapName == "Ceylon") || 
        (cRandomMapName == "Borneo") || 
        (cRandomMapName == "Honshu") )
   {
      aiSetWaterMap(true);
      gWaterMap = true;
   }
}



int gCardNames = -1;       // Array of strings, handy name for this card.
int gCardStates = -1;      // Array of chars (strings), A = avail, N = Not avail, P = Purchased, D = in deck (and purchased)
int gCardPriorities = -1;  // Array of ints, used for selecting cards into deck.  

const int maxCards = 100;
const int deckSize = 25;
//const int pointsForLevel2 = 5;   // First five cards must be level 1
//const int pointsForLevel3 = 25;  // Cards 6..25 must be levels 1 or 2

rule buyCards
inactive
minInterval 1
{
   static int pass = 0; // Pass 0, init arrays.  Pass 1, buy cards.  Pass 2, create deck.
	static int startingSP = -1;
   if (startingSP < 0)
      startingSP = kbResourceGet(cResourceSkillPoints) - 15;   // XS won't allow float initialization of const ints, also subtract first 15 free cards.
   int remainingSP = kbResourceGet(cResourceSkillPoints) - 15;  
   int SPSpent = startingSP - remainingSP;
   int myLevel = 0;
   //if (SPSpent >= 10)
   //   myLevel = 10;
   //if (SPSpent >= 25)
      myLevel = 121;
   int totalCardCount = aiHCCardsGetTotal();
   aiEcho("My starting level is "+myLevel+", my SP remaining is "+remainingSP);
      
   switch(pass)      // Break processing load into 3 passes:  init, buy, deck.
   {
      case 0:  // Init arrays
      {
         gCardNames = xsArrayCreateString(maxCards, " ", "Card names");
         gCardStates = xsArrayCreateString(maxCards, "P", "Card states");  
         gCardPriorities = xsArrayCreateInt(maxCards, 0, "Card priorities");
         
         for (i=0; < totalCardCount)
         {  // First, set maximum priority for the "best" cards 
            // 'Advanced Trading Post', 'Royal Decree', 'Advanced Arsenal', 'New Ways' & 'Advanced Balloon',
            // plus '2 Grove Rickshaws' & 'Shogun Tokugawa'
            if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipUrumi1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipUrumi2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipUrumiTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipUrumiRegiment") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCAdvancedArsenal") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryHitpointsGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNewWaysIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNewWaysSioux") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGermantownFarmers") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipShogunate") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoAizu") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoSatsuma")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDuelingSchoolTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFencingSchool")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCBannerSchool") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAccupuncture")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchool") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCFencingSchoolIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCRidingSchoolIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFencingSchoolGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchoolGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchoolGerman2") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryCombatChinese") ||
		        (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryDamageChinese") ||
		        (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryHitpointsChinese")||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedConsulate") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedConsulateIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCIncreasedTribute") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCOldHanArmyReforms") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCWesternReforms") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFactory") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNationalRedoubt") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNationalRedoubt") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRobberBarons") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFactoryGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRobberBaronsGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
                //(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates3") ||                 
                //(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates3German") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGuildArtisans") ||
                //((civIsAsian() == false) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPLandGrab")) ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBanks2") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBanks1") ||                 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPThoroughbreds") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryDamageFrenchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightCombat") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightHitpoints") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarHutTraining") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryDamageIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryCombatIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryHitpointsIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryDamageIroquoisIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryCombatDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryHitpointsDutchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryDamageDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeDiscipline") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPConservativeTactics") ||         
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCTerritorialArmyCombat") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCHanAntiCavalryBonus") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCForbiddenArmyArmor") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCManchuCombat") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAshigaruDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAshigaruAntiCavalryDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiRange") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNaginataAntiInfantryDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNaginataHitpoints") ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYabusameDamage") ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYabusameAntiArtilleryDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCGurkhaAid") ||                
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCEastIndiaCompany") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCamelFrightening") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCInfantrySpeedHitpointsTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantLimit") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantCombatIndians") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantTrampling") ||
			    (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCamelDamageIndians") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCMeleeDamageIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCommandSkill") ||	
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryDamageSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryHitpointsSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryCombatSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPMustangs") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxYanktonSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxSanteeSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxYanktonSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxSanteeSupport") ||
                //(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxTwoKettleSupport") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryDamageIroquois") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryHitpointsIroquois") ||		 		
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryHitpointsIroquois") ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeCombat") ||		
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightDamage") ||		 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightHitpoints") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPScorchedEarth") ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPRuthlessness") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleHuitzilopochtli") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleXipeTotec") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleTlaloc") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleQuetzalcoatl") || 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierHitpointsBritishTeam") ||                 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierDamageBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierCombatBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryDamageBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryHitpointsBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryDamageFrenchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCWildernessWarfare") ||		 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsFrench") ||		                  
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCost") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCombatOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCLightArtilleryHitpointsOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryHitpointsOttomanTeam") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryDamageOttoman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryHitpointsPortugueseTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryHitpointsPortugueseTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryDamagePortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryCombatPortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDragoonCombatPortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGenitours") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDutchEastIndiaCompany") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryDamageDutch") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryCombatDutch") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatDutch") ||	 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBetterBanks") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCStreletsCombatRussian") ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRansack") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatRussian") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUniqueCombatRussian") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPIndustrialRevolution") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryDamageSpanishTeam") ||
                //(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatSpanish") ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryHitpointsSpanish") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryCombatSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCaballeros") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryDamageSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsSpanish") ||   
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryDamageGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryHitpointsGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUhlanCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSpahis4") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSpahis3") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFalconets3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxYanktonSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxSanteeSupport") ||
				((kbGetCiv() == cCivOttomans) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCEngineeringSchool")) ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryDamageGermanTeam"))
                    xsArraySetInt(gCardPriorities, i, 10);         

/*
         for (i=0; < totalCardCount)
         {  // First, set maximum priority for the "best" cards 
            // 'Advanced Trading Post', 'Royal Decree', 'Advanced Arsenal', 'New Ways' & 'Advanced Balloon',
            // plus '2 Grove Rickshaws' & 'Shogun Tokugawa'
            if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNewWaysIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNewWaysSioux") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGermantownFarmers") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipShogunate") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoAizu") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoSatsuma")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDuelingSchoolTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFencingSchool")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCBannerSchool") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAccupuncture")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchool") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCFencingSchoolIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCRidingSchoolIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFencingSchoolGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchoolGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchoolGerman2") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryCombatChinese") ||
		        (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryDamageChinese") ||
		        (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryHitpointsChinese")||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedConsulate") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedConsulateIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCIncreasedTribute") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCOldHanArmyReforms") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCWesternReforms") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFactory") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRobberBarons") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFactoryGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRobberBaronsGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates3") ||                 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates3German") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGuildArtisans") ||
                //((civIsAsian() == false) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPLandGrab")) ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBanks2") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBanks1") ||                 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPThoroughbreds") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryDamageFrenchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightCombat") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightHitpoints") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarHutTraining") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryDamageIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryCombatIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryHitpointsIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryDamageIroquoisIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryCombatDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryHitpointsDutchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryDamageDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeDiscipline") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPConservativeTactics") ||         
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCTerritorialArmyCombat") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCHanAntiCavalryBonus") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCForbiddenArmyArmor") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCManchuCombat") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAshigaruDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAshigaruAntiCavalryDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiRange") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNaginataAntiInfantryDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNaginataHitpoints") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYabusameDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYabusameAntiArtilleryDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCGurkhaAid") ||                
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCEastIndiaCompany") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCamelFrightening") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCInfantrySpeedHitpointsTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantLimit") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantCombatIndians") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantTrampling") ||
			    (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCamelDamageIndians") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCMeleeDamageIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCommandSkill") ||	
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryDamageSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryHitpointsSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryCombatSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPMustangs") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxYanktonSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxSanteeSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxTwoKettleSupport") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryDamageIroquois") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryHitpointsIroquois") ||		 		
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryHitpointsIroquois") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeCombat") ||		
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightDamage") ||		 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightHitpoints") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPScorchedEarth") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPRuthlessness") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleHuitzilopochtli") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleXipeTotec") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleTlaloc") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleQuetzalcoatl") || 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierHitpointsBritishTeam") ||                 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierDamageBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierCombatBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryDamageBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryHitpointsBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryDamageFrenchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCWildernessWarfare") ||		 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsFrench") ||		                  
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCost") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCombatOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCLightArtilleryHitpointsOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryHitpointsOttomanTeam") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryDamageOttoman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryHitpointsPortugueseTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryHitpointsPortugueseTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryDamagePortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryCombatPortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDragoonCombatPortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGenitours") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDutchEastIndiaCompany") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryDamageDutch") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryCombatDutch") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatDutch") ||	 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBetterBanks") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCStreletsCombatRussian") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRansack") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatRussian") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUniqueCombatRussian") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPIndustrialRevolution") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryDamageSpanishTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryCombatSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCaballeros") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryDamageSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryHitpointsSpanish") ||    
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryDamageGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryHitpointsGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUhlanCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSpahis4") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSpahis3") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFalconets3") ||
				((kbGetCiv() == cCivOttomans) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCEngineeringSchool")) ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryDamageGermanTeam"))
                    xsArraySetInt(gCardPriorities, i, 9);     					
					
					
         for (i=0; < totalCardCount)
         {  // First, set maximum priority for the "best" cards 
            // 'Advanced Trading Post', 'Royal Decree', 'Advanced Arsenal', 'New Ways' & 'Advanced Balloon',
            // plus '2 Grove Rickshaws' & 'Shogun Tokugawa'
            if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNewWaysIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNewWaysSioux") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGermantownFarmers") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipShogunate") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoAizu") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoSatsuma")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDuelingSchoolTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFencingSchool")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCBannerSchool") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAccupuncture")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchool") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCFencingSchoolIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCRidingSchoolIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFencingSchoolGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchoolGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchoolGerman2") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryCombatChinese") ||
		        (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryDamageChinese") ||
		        (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryHitpointsChinese")||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedConsulate") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedConsulateIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCIncreasedTribute") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCOldHanArmyReforms") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCWesternReforms") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFactory") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRobberBarons") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFactoryGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRobberBaronsGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates3") ||                 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates3German") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGuildArtisans") ||
                //((civIsAsian() == false) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPLandGrab")) ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBanks2") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBanks1") ||                 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPThoroughbreds") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryDamageFrenchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightCombat") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightHitpoints") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarHutTraining") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryDamageIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryCombatIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryHitpointsIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryDamageIroquoisIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryCombatDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryHitpointsDutchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryDamageDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeDiscipline") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPConservativeTactics") ||         
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCTerritorialArmyCombat") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCHanAntiCavalryBonus") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCForbiddenArmyArmor") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCManchuCombat") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAshigaruDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAshigaruAntiCavalryDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiRange") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNaginataAntiInfantryDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNaginataHitpoints") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYabusameDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYabusameAntiArtilleryDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCGurkhaAid") ||                
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCEastIndiaCompany") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCamelFrightening") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCInfantrySpeedHitpointsTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantLimit") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantCombatIndians") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantTrampling") ||
			    (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCamelDamageIndians") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCMeleeDamageIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCommandSkill") ||	
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryDamageSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryHitpointsSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryCombatSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPMustangs") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxYanktonSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxSanteeSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxTwoKettleSupport") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryDamageIroquois") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryHitpointsIroquois") ||		 		
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryHitpointsIroquois") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeCombat") ||		
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightDamage") ||		 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightHitpoints") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPScorchedEarth") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPRuthlessness") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleHuitzilopochtli") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleXipeTotec") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleTlaloc") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleQuetzalcoatl") || 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierHitpointsBritishTeam") ||                 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierDamageBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierCombatBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryDamageBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryHitpointsBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryDamageFrenchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCWildernessWarfare") ||		 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsFrench") ||		                  
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCost") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCombatOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCLightArtilleryHitpointsOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryHitpointsOttomanTeam") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryDamageOttoman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryHitpointsPortugueseTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryHitpointsPortugueseTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryDamagePortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryCombatPortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDragoonCombatPortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGenitours") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDutchEastIndiaCompany") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryDamageDutch") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryCombatDutch") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatDutch") ||	 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBetterBanks") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCStreletsCombatRussian") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRansack") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatRussian") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUniqueCombatRussian") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPIndustrialRevolution") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryDamageSpanishTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryCombatSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCaballeros") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryDamageSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryHitpointsSpanish") ||    
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryDamageGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryHitpointsGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUhlanCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSpahis4") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSpahis3") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFalconets3") ||
				((kbGetCiv() == cCivOttomans) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCEngineeringSchool")) ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryDamageGermanTeam"))
                    xsArraySetInt(gCardPriorities, i, 8);     
					
					
         for (i=0; < totalCardCount)
         {  // First, set maximum priority for the "best" cards 
            // 'Advanced Trading Post', 'Royal Decree', 'Advanced Arsenal', 'New Ways' & 'Advanced Balloon',
            // plus '2 Grove Rickshaws' & 'Shogun Tokugawa'
            if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNewWaysIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNewWaysSioux") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGermantownFarmers") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipShogunate") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoAizu") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoSatsuma")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDuelingSchoolTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFencingSchool")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCBannerSchool") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAccupuncture")||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchool") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCFencingSchoolIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCRidingSchoolIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFencingSchoolGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchoolGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchoolGerman2") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryCombatChinese") ||
		        (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryDamageChinese") ||
		        (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryHitpointsChinese")||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedConsulate") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedConsulateIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCIncreasedTribute") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCOldHanArmyReforms") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCWesternReforms") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFactory") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRobberBarons") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFactoryGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRobberBaronsGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates3") ||                 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates3German") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGuildArtisans") ||
                //((civIsAsian() == false) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPLandGrab")) ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBanks2") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBanks1") ||                 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPThoroughbreds") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryDamageFrenchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightCombat") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightHitpoints") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarHutTraining") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryDamageIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryCombatIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryHitpointsIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryDamageIroquoisIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryCombatDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryHitpointsDutchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryDamageDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeDiscipline") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPConservativeTactics") ||         
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCTerritorialArmyCombat") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCHanAntiCavalryBonus") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCForbiddenArmyArmor") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCManchuCombat") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAshigaruDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAshigaruAntiCavalryDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiRange") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNaginataAntiInfantryDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNaginataHitpoints") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYabusameDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYabusameAntiArtilleryDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCGurkhaAid") ||                
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCEastIndiaCompany") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCamelFrightening") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCInfantrySpeedHitpointsTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantLimit") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantCombatIndians") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantTrampling") ||
			    (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCamelDamageIndians") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCMeleeDamageIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCommandSkill") ||	
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryDamageSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryHitpointsSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryCombatSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPMustangs") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxYanktonSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxSanteeSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxTwoKettleSupport") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryDamageIroquois") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryHitpointsIroquois") ||		 		
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryHitpointsIroquois") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeCombat") ||		
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightDamage") ||		 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightHitpoints") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPScorchedEarth") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPRuthlessness") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleHuitzilopochtli") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleXipeTotec") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleTlaloc") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleQuetzalcoatl") || 
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierHitpointsBritishTeam") ||                 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierDamageBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierCombatBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryDamageBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryHitpointsBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryDamageFrenchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCWildernessWarfare") ||		 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsFrench") ||		                  
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCost") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCombatOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCLightArtilleryHitpointsOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryHitpointsOttomanTeam") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryDamageOttoman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryHitpointsPortugueseTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryHitpointsPortugueseTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryDamagePortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryCombatPortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDragoonCombatPortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGenitours") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDutchEastIndiaCompany") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryDamageDutch") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryCombatDutch") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatDutch") ||	 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBetterBanks") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCStreletsCombatRussian") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRansack") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatRussian") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUniqueCombatRussian") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPIndustrialRevolution") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryDamageSpanishTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryCombatSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCaballeros") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryDamageSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryHitpointsSpanish") ||    
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryDamageGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryHitpointsGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUhlanCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSpahis4") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSpahis3") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFalconets3") ||
				((kbGetCiv() == cCivOttomans) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCEngineeringSchool")) ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryDamageGermanTeam"))
                    xsArraySetInt(gCardPriorities, i, 7);     
					*/

                //((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCEngineeringSchoolTeam")) ||  
                //(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxNakotaSupport") ||
                //(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarChiefIroquois2") ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarChiefIroquois1") || 
                //(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarChiefAztec1") ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarChiefSioux1") ||	
                //kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCExoticHardwoodsIndians") ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPRangefinding") ||
				//((kbGetCiv() == cCivOttomans) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCEngineeringSchool")) ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSpawnStrelet") ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnicorne") ||
				//((gNavyMap == false) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPMilitaryReforms")) ||	
                //((gNavyMap == false) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSevastopol")) ||
                //((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArchaicTrainingTeam")) ||
				//((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSpahisTeam")) ||
				//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSpahis1") ||
                //((gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSchooners")) ||
                //((gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSchoonersIndians")) ||
                //((gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSchoonersJapanese")) ||
                //((gNavyMap == true) && (getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCheapFishingBoatTeam")) ||					

            // List of "best" cards also includes 'Agrarianism' for Indians
            // (A bug in aiHCDeckAddCardToDeck() keeps 'Foreign Logging' from being added.)
           // if (kbGetCiv() == cCivIndians)
           // {
           //    if (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAgrarianism")
           //            xsArraySetInt(gCardPriorities, i, 10);  // "Best" cards, pri 10
           // }
		   
		   /*
            // Now, set priorities for the prerequisite cards for the "best" ones.
            // These will be ignored later on.
            if (kbResourceGet(cResourceSkillPoints) >= 5)
            {  // Prerequisites for '2 Grove Rickshaws', only for HC level >= 5.
               if (kbGetTechName(aiHCCardsGetCardTechID(i)) == "*") // "YPHCShipGroveWagonIndians2")
                       xsArraySetInt(gCardPriorities, i, 10);  // Prerequisite cards, pri 10
            }
            
            if (kbResourceGet(cResourceSkillPoints) >= 15)
            {  // Prerequisites for 'Royal Decree', 'Advanced Arsenal', 'New Ways' and 'Shogun Tokugawa', only for HC level >= 15.
               if (kbGetTechName(aiHCCardsGetCardTechID(i)) == "*")  "HCDutchEastIndiaCompany"))  ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates3") ||                   
                   ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatHouse") && (kbGetCiv() == cCivXPIroquois)) ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoAizu") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoSatsuma")) 
                       xsArraySetInt(gCardPriorities, i, 10);  // Prerequisite cards, pri 10
            }
            if (kbResourceGet(cResourceSkillPoints) >= 25)
            {  // Prerequisites for 'Advanced Trading Post' and Indian 'Agrarism', only for HC level >= 25.
               if (kbGetTechName(aiHCCardsGetCardTechID(i)) == "*")  "HCXPEconomicTheory") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCapitalism") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCoinCratesAztec3") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPDistributivism") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPConservativeTactics") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates4") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarHutTraining") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSawmillsIndians")) 
                       xsArraySetInt(gCardPriorities, i, 10);  // Prerequisite cards, pri 10 
            }
			*/
			
            if (kbResourceGet(cResourceSkillPoints) >= 40)
            {  // Prerequisites for 'Advanced Balloon', only for HC level >= 40.
               if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipLongbowmen1") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipLongbowmen2") ||
				   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxYanktonSupport") ||
				   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxSanteeSupport") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipLongbowmen3") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipLongbowmen4") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleHuitzilopochtli") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleXipeTotec") || 
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleTlaloc") || 
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows"))
                       xsArraySetInt(gCardPriorities, i, 10);   // Prerequisite card, pri 10
            }

            // For all other cards, set priorities based on unit type.
            string tempString = "";
            int unit = aiHCCardsGetCardUnitType(i);
            int tech = aiHCCardsGetCardTechID(i);
            int age = aiHCCardsGetCardAgePrereq(i);
            if ((unit == cUnitTypeSettler) || 
                (unit == cUnitTypeCoureur) || 
                (unit == cUnitTypeSettlerWagon) || 
                (unit == cUnitTypeSettlerNative) ||
                (unit == cUnitTypeypSettlerAsian) || 
                (unit == cUnitTypeypSettlerJapanese))
            {
		if (age < cAge2) // for age 1
		{
		   if (aiHCCardsGetCardUnitCount(i) > 2) 
                     xsArraySetInt(gCardPriorities, i, 9);  // 3 Settler card for age1 cards, pri 9
		   else if ((aiHCCardsGetCardUnitCount(i) == 2) && (kbGetCiv() == cCivGermans))
                     xsArraySetInt(gCardPriorities, i, 9);  // 2 Settler Wagon card for age1 cards, pri 9
                   else if (aiHCCardsGetCardUnitCount(i) == 2)
                     xsArraySetInt(gCardPriorities, i, 5);  // make sure 3 Settler cards win over 2 Settler cards...                
                }

                if (age >= cAge2) // for age 2 or about
                {
                   if (aiHCCardsGetCardUnitCount(i) >= 5) 
                     xsArraySetInt(gCardPriorities, i, 9);  // 5 Settler card for age2 cards, pri 9
		   else if ((aiHCCardsGetCardUnitCount(i) == 4) && (kbGetCiv() == cCivFrench))
                     xsArraySetInt(gCardPriorities, i, 9);  // 4 Coureur card for age2 cards, pri 9
                   else
		     xsArraySetInt(gCardPriorities, i, 5);  // make sure 5 Settler cards win over 4 Settler cards... 
                }
            }

            if ( (xsArrayGetInt(gCardPriorities, i) == 0) && (aiHCCardsGetCardCount(i) > 2) )
            {
	       if (age > cAge3)
                 xsArraySetInt(gCardPriorities, i, 0);  // Infinite cards, pri 8
            }

            if (xsArrayGetInt(gCardPriorities, i) == 0)
            {
               if ( (unit == cUnitTypeFortWagon) ||
                    (unit == cUnitTypeFactoryWagon) ||
                    (unit == gCoveredWagonUnit) )                   
                     xsArraySetInt(gCardPriorities, i, 10);  // Fort, Factory, Dojo and Covered Wagons, pri 7
               if ( (unit == cUnitTypeOutpostWagon) || (unit == cUnitTypeYPCastleWagon) )
                  xsArraySetInt(gCardPriorities, i, 0);               
            } 
            if ( (xsArrayGetInt(gCardPriorities, i) == 0) && (unit >= 0) )
            {  // Some type of unit, pri 6 for resources, 5 for others
               if (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractResourceCrate) == true)
               {
                  xsArraySetInt(gCardPriorities, i, 6);  // Resource
				  
		  if ( (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates2") || 
                       (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFoodCrates2") ||
                       (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates2") )
		  {
		     xsArraySetInt(gCardPriorities, i, 4);
		  }
	       }
               else
                  xsArraySetInt(gCardPriorities, i, 5);  // Generic unit
            }           
            if ( (xsArrayGetInt(gCardPriorities, i) == 5) && (unit >= 0) )
            {  // Demote cows, sheep and surgeons to 0, non-mil units to 4, ships to 0 on land maps.
               if ((kbProtoUnitIsType(cMyID, unit, cUnitTypeLogicalTypeLandMilitary) == false) || (aiHCCardsGetCardUnitCount(i) < 3))
                  xsArraySetInt(gCardPriorities, i, 2);  // Non-military unit (including explorer dogs and uhlan pairs)
               if ((kbProtoUnitIsType(cMyID, unit, cUnitTypeHerdable) == true) || (kbProtoUnitIsType(cMyID, unit, cUnitTypeMissionary) == true) || (kbProtoUnitIsType(cMyID, unit, cUnitTypeSurgeon) == true))
                  xsArraySetInt(gCardPriorities, i, 0);  // Herdables, missionaries or surgeons.              
               if ( (gNavyMap == false) && ( (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractWarShip) == true) || (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractFishingBoat) == true) ) )
                  xsArraySetInt(gCardPriorities, i, 0);  // Navy units on land?  Not good.              
            }

            // Set priority to 0 for cards to be avoided if possible
            if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFrontierDefenses") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFrontierDefenses2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoveredWagons2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFastHousesTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCConestogaWagonsTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBastionsTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryHitpointsSpanish") || 
                //(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFortVauban") ||
                //(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPUnlockFort2") ||
                //(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPUnlockFort2German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFalconets1German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMortars1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMortars2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMortars1German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMortars2German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMortarsTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipPetards1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipDemolitionSquadGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipRams1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPIroquoisMohawkSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSiege") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYabusameDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYabusameAntiArtilleryDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSpies1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSpies2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSpies3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSpies1German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSpiesTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleTezcatlipoca") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipBears") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipBearsTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCougars") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCoyotes") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCoyotesTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipGrizzlies") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipJaguars1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipJaguars2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipJaguars3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipJaguarsTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipWolves") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCoinCratesAztec2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCoinCratesAztec4") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCoinCratesAztec5") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipMedicineMen2Aztec") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipMixedCrates4") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCratesInf1Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCratesInf2Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCratesInf3Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCratesInf4Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCExpandedTradingPost") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCExpandedTradingPostIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoveredWagonsChina") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoveredWagons2Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSacredFieldHealing") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCBazaar") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCExpandedMarket") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCommoditiesMarket") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedMonastery") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedMonasteryIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipBerryWagon1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipBerryWagon2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipRicePaddyWagon1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipRicePaddyWagon2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipRicePaddyWagon3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCrates3Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoinCrates3Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCrates5Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCTeamCoinCrates1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoinCrates1Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoinCrates1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipFoodCrates1Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipFoodCrates1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoinCrates2Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoinCrates2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCrates2Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCrates2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipFoodCrates2Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipFoodCrates2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoinCrates2Indians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoinCrates2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFoodCrates1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates2German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates2German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFoodCrates2German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFoodCrates2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFoodCrates4German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFoodCrates4") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates4German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates4") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates2German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipMorutaru1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates5") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFoodCrates5") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates5") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPHuronAllies1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCherokeeAllies1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPHuronAllies1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCrates5Indians") ||
                (aiHCCardsGetCardUnitType(i) == cUnitTypeMercType1) ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipMorutaru2"))
                    xsArraySetInt(gCardPriorities, i, 0);  // Cards to be avoided, pri 0

            // Set priority to 0 for castle wagon cards to be specifically avoided for Japanese,
            // depending on whether this is a team game or not (only for HC level <= 30)
            if ((kbGetCiv() == cCivJapanese) && (kbResourceGet(cResourceSkillPoints) <= 30))
            {
               if (getAllyCount() > 0)
               {
                  if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons1") ||
                      (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons3"))
                          xsArraySetInt(gCardPriorities, i, 10);  // Re-evaluated as prerequisite cards, pri 10 (ignored later)
               }
               else
               {
                  if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagonsTeam") ||
                      (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagonsTeam2") ||
                      (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons3"))
                          xsArraySetInt(gCardPriorities, i, 0);  // Cards to be avoided, pri 0
               }
            }
            
            // Set priority to 0 for cards to be specifically avoided for Russians, as a bug
            // in aiHCDeckAddCardToDeck() keeps 'Advanced Balloon' from being added
            if (kbGetCiv() == cCivRussians)
            {
               if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPAdvancedBalloon") ||
                   (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipBalloons"))
                       xsArraySetInt(gCardPriorities, i, 0);  // Cards to be avoided, pri 0
            }

            // Set priority to 0 for card to be specifically avoided for Indians, as a bug
            // in aiHCDeckAddCardToDeck() keeps 'Foreign Logging' from being added
            if (kbGetCiv() == cCivIndians)
            {
               if (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCForeignLogging") 
                      xsArraySetInt(gCardPriorities, i, 0);  // Card to be avoided, pri 0
            }

            // Set priority to 0 for card to be specifically avoided for Japanese, as a bug
            // in aiHCDeckAddCardToDeck() keeps '2 Team Castle Wagons' from being added
            if (kbGetCiv() == cCivJapanese)
            {
               if (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagonsTeam2") 
                      xsArraySetInt(gCardPriorities, i, 0);  // Card to be avoided, pri 0
            }


            // Set priority to 0 for archaic soldier cards in ages 3 and 4
            if ((aiHCCardsGetCardAgePrereq(i) == cAge5) || (aiHCCardsGetCardAgePrereq(i) == cAge3) ||  (aiHCCardsGetCardAgePrereq(i) == cAge4) ||  (aiHCCardsGetCardAgePrereq(i) == cAge2) ||  (aiHCCardsGetCardAgePrereq(i) == cAge1))
            {
               if ((aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractRajput) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeCrossbowman) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeStrelet) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeSkirmisher) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeHalberdier) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeGrenadier) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypexpWarBow) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypexpWarClub) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypexpWarRifle) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeDopplesoldner) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractPet)) //||
				   //(aiHCCardsGetCardUnitType(i) == cUnitTypeMercType1) ||
				   //(aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractHandInfantry))
                       xsArraySetInt(gCardPriorities, i, 0);  // Units to be to be avoided, pri 0
            }
			
            // Set priority to 0 for archaic soldier cards in ages 3 and 4
            if ((aiHCCardsGetCardAgePrereq(i) == cAge5) || (aiHCCardsGetCardAgePrereq(i) == cAge3) ||  (aiHCCardsGetCardAgePrereq(i) == cAge4))
            {
               if ((aiHCCardsGetCardUnitType(i) == cUnitTypePikeman) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeCrossbowman) ||
                   //(aiHCCardsGetCardUnitType(i) == cUnitTypeLongbowman) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeStrelet) ||
                   //(aiHCCardsGetCardUnitType(i) == cUnitTypeypYumi) ||
                   //(aiHCCardsGetCardUnitType(i) == cUnitTypeypQiangPikeman) ||
                   //(aiHCCardsGetCardUnitType(i) == cUnitTypeypChuKoNu) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeSkirmisher) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeHalberdier) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeGrenadier) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypexpWarBow) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypexpWarClub) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeDopplesoldner) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeRodelero)) //||
				   //(aiHCCardsGetCardUnitType(i) == cUnitTypeMercType1) ||
				   //(aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractHandInfantry))
                       xsArraySetInt(gCardPriorities, i, 0);  // Units to be to be avoided, pri 0
            }
			
            if ((aiHCCardsGetCardAgePrereq(i) == cAge5) || (aiHCCardsGetCardAgePrereq(i) == cAge4))
            {
               if ((aiHCCardsGetCardUnitType(i) == cUnitTypePikeman) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeCrossbowman) ||
                   //(aiHCCardsGetCardUnitType(i) == cUnitTypeLongbowman) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeStrelet) ||
                   //(aiHCCardsGetCardUnitType(i) == cUnitTypeypYumi) ||
                   //(aiHCCardsGetCardUnitType(i) == cUnitTypeypQiangPikeman) ||
                   //(aiHCCardsGetCardUnitType(i) == cUnitTypeypChuKoNu) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeSkirmisher) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeHalberdier) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypexpCoyoteMan) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypexpMacehualtin) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypexpPumaMan) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeGrenadier) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypexpWarBow) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypexpWarClub) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeDopplesoldner) ||
                   (aiHCCardsGetCardUnitType(i) == cUnitTypeRodelero)) //||
				   //(aiHCCardsGetCardUnitType(i) == cUnitTypeMercType1) ||
				   //(aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractHandInfantry))
                       xsArraySetInt(gCardPriorities, i, 0);  // Units to be to be avoided, pri 0
            }
			
            if ((aiHCCardsGetCardAgePrereq(i) == cAge4))
            {
               if ((aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractInfantry) ||
				   (aiHCCardsGetCardUnitType(i) == cUnitTypeAbstractRangedCavalry))
                       xsArraySetInt(gCardPriorities, i, 0);  // Units to be to be avoided, pri 0
            }

            if ( (xsArrayGetInt(gCardPriorities, i) == 0) && (xsArrayGetString(gCardStates, i)=="P") )
            {  // We own this card, but it's not in the categories above, and won't be flagged when we do our purchases.
               // So, give it a P1 just to distinguish it from others.
               xsArraySetInt(gCardPriorities, i, 1);
            }
            if ((kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy))
            {  
               if ( (tech == cTechYPHCShipDaimyoAizu) || (tech == cTechYPHCShipDaimyoSatsuma) || (tech == cTechYPHCShipDaimyoTokushima) || (tech == cTechYPHCShipShogunate)
                    || (tech == cTechYPSPCHCShipDaimyoKiyomasa) || (tech == cTechYPSPCHCShipDaimyoMasamune) || (tech == cTechYPSPCHCShipDaimyoTadaoki) ) {
                  xsArraySetInt(gCardPriorities, i, 0);  // BHG: don't want spcjapanese sending in unapproved daimyos
                }
            }
            if (kbGetCiv() == cCivSPCIndians)
            {  
               if ( (tech == cTechYPHCShipSepoy1) || (tech == cTechYPHCShipSepoy2) || (tech == cTechYPHCShipSepoy3) || (tech == cTechYPHCShipSepoy4) ) {
                  xsArraySetInt(gCardPriorities, i, 0);  // BHG: don't want spcindians sending in unapproved sepoys
                }
            }
            // Priorities 2-4 will be set when the card is purchased, based on "find best" category that gets them.
            
            if (aiHCCardsIsCardBought(i) == true)
               xsArraySetString(gCardStates, i, "P"); // Purchased
            else
            {
               if (aiHCCardsCanIBuyThisCard(-1, i) == true)
                  xsArraySetString(gCardStates, i, "A"); // Available
               else
                  xsArraySetString(gCardStates, i, "N"); // Not available
            }
            if (kbGetCiv() == cCivSPCIndians)
            {  
               if ( (tech == cTechYPHCShipSepoy1) || (tech == cTechYPHCShipSepoy2) || (tech == cTechYPHCShipSepoy3) || (tech == cTechYPHCShipSepoy4) ) {
                  xsArraySetString(gCardStates, i, "N");  // BHG: don't want spcindians sending in unapproved sepoys
                }
            }

            if (aiHCCardsGetCardCount(i) < 0)
               tempString = " Infinite";
            else
               tempString = "   "+aiHCCardsGetCardCount(i)+" use";
            tempString = tempString + " Pri "+xsArrayGetInt(gCardPriorities, i)+" ";
            tempString = tempString + " "+xsArrayGetString(gCardStates, i);
            tempString = tempString + "  L"+aiHCCardsGetCardLevel(i);
            tempString = tempString + "  A"+aiHCCardsGetCardAgePrereq(i);
            tempString = tempString + " ("+tech+") "+kbGetTechName(tech);
            if (unit >= 0)
            {
               tempString = tempString + " "+aiHCCardsGetCardUnitCount(i)+" "+kbGetProtoUnitName(unit);
            }
            
            xsArraySetString(gCardNames, i, tempString);
            aiEcho(i+" "+tempString);
         }
         pass = 1;   // Buy cards next time
         break;
      }
      case 1:  // Buy cards
      {
         for (attempt = 0; < 200)
         {
            aiEcho("Purchase attempt "+attempt);
            if (remainingSP <= 0) // Have no points to spend...
               break;
            
            bool result = false;

            int boughtCardIndex = -1;
            int highestPriority = 0;   // Priority higher than this will be bought.
            // First, scan for the high-priority cards.
            for (index=0; <totalCardCount)  
            {  // Scan the list, looking for the highest-priority card still available
               if ( (aiHCCardsGetCardLevel(index) > myLevel) || (aiHCCardsCanIBuyThisCard(-1, index) == false) || (xsArrayGetString(gCardStates, index) == "P"))
                  continue;   // Skip it.  Note...I use the "P" (purchased) flag to indicate ones that are purchased, AND ones that have failed in a buy attempt.                  
               // It is legal and available
               if (xsArrayGetInt(gCardPriorities, index) > highestPriority)
               {
                  boughtCardIndex = index;
                  highestPriority = xsArrayGetInt(gCardPriorities, index);
               }
            }
            if (boughtCardIndex >= 0)
            {
               result = aiHCCardsBuyCard(boughtCardIndex);
               aiEcho("Buying priority "+highestPriority+" card "+xsArrayGetString(gCardNames, boughtCardIndex));
            }
          
            int cardIndex = -1;
            if (boughtCardIndex < 0)
            {  // No special cards remain, look for best one in each category.          
               cardIndex = aiHCCardsFindBestCard(cHCCardTypeEcon, myLevel);
               if ( cardIndex >= 0 )
               {  // Any econ card
                  result = aiHCCardsBuyCard(cardIndex);
                  aiEcho("Buying econ card "+xsArrayGetString(gCardNames, cardIndex));
                  boughtCardIndex = index;
                  xsArraySetInt(gCardPriorities, cardIndex, 3);   // Pri 3, econ card
                  break;
               }           
               cardIndex = aiHCCardsFindBestCard(cHCCardTypeMilitary, myLevel);
               if ( cardIndex >= 0 )
               {  // Any military card
                  result = aiHCCardsBuyCard(cardIndex);
                  aiEcho("Buying military card "+xsArrayGetString(gCardNames, cardIndex));
                  boughtCardIndex = cardIndex;
                  xsArraySetInt(gCardPriorities, cardIndex, 2);   // Pri 2, military card
                  break;                   
               }
               cardIndex = aiHCCardsFindBestCard(cHCCardTypeWagon, myLevel);
               if ( cardIndex >= 0 )
               {  // Any wagon card
                  result = aiHCCardsBuyCard(cardIndex);
                  aiEcho("Buying wagon card "+xsArrayGetString(gCardNames, cardIndex));
                  boughtCardIndex = cardIndex;
                  xsArraySetInt(gCardPriorities, cardIndex, 7);   // Pri 7, wagon card...shouldn't get any hits here.
                  break;                   
               }
               cardIndex = aiHCCardsFindBestCard(cHCCardTypeTeam, myLevel);
               if ( cardIndex >= 0 )
               {  // Any team card
                  result = aiHCCardsBuyCard(cardIndex);
                  aiEcho("Buying team card "+xsArrayGetString(gCardNames, cardIndex));
                  boughtCardIndex = cardIndex;
                  xsArraySetInt(gCardPriorities, cardIndex, 1);   // Pri 1, team card
                  break;                   
               }    
            }

            // If we're here, we've either selected a card, or exhausted the list.
            if (boughtCardIndex < 0)
            {  // Nothing to buy?!
               aiEcho("  ERROR!  We have points to spend, but no cards to buy.");
               pass = 2;   // go on to deck picking
               return;
            }
            // We've selected a card.  Did the purchase work?
            if (result == false)
            {  // It failed, blacklist this card by marking it owned in the array.
               aiEcho("  ERROR!  Failed to buy card "+xsArrayGetString(gCardNames, boughtCardIndex));
            }
            xsArraySetString(gCardStates, boughtCardIndex, "P");  // Even if purchase failed, mark it purchased so we don't get stuck on it.
            remainingSP = remainingSP - 1;
            SPSpent = SPSpent + 1;
            //if (SPSpent >= 10)
            //   myLevel = 10;
            //if (SPSpent >= 25)
               myLevel = 121;
         }  // For attempt 0..10
         
         if (remainingSP <= 0)
            pass = 2;
      }  // case 1
      case 2:  // Make deck
      {  
         aiEcho("Making deck");
         if (gSPC == true)
	 {
	   if (gDefaultDeck < 0)
	      gDefaultDeck = aiHCDeckCreate("The AI Deck");
	 }
	 else
	 {
	   //-- In non spc games, the game will make an empty deck for AI's at index 0.
           gDefaultDeck = 0;
	 }
         
         aiEcho("Building Deck");
         int cardsRemaining = 25;
         int toPick = 1;
         //if (kbGetHCLevel(cMyID) < 110)
            //toPick = 1;

         // First, "best" cards (if available).
         for (card=0; < maxCards)
         { 
             if (aiGetWorldDifficulty() > cDifficultyModerate) 
             { 
            if ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipUrumi1") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipUrumi2") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipUrumiTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipUrumiRegiment") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCAdvancedArsenal") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryHitpointsGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSettlers3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoureurs3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPShipVillagers3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSettlerWagons3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSettlerWagons4") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPNewWaysIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPNewWaysSioux") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCGermantownFarmers") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipShogunate") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipDaimyoAizu") ||
                (kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipDaimyoSatsuma")||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCDuelingSchoolTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFencingSchool")||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCBannerSchool") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAccupuncture")||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRidingSchool") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCFencingSchoolIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCRidingSchoolIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFencingSchoolGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRidingSchoolGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRidingSchoolGerman2") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCArtilleryCombatChinese") ||
		        (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCArtilleryDamageChinese") ||
		        (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCArtilleryHitpointsChinese")||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3German") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAdvancedConsulate") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAdvancedConsulateIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCIncreasedTribute") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCOldHanArmyReforms") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCWesternReforms") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUnlockFactory") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRobberBarons") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUnlockFactoryGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRobberBaronsGerman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCImprovedLongbows") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3") ||                 
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3German") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCGuildArtisans") ||
                //((civIsAsian() == false) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPLandGrab")) ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCBanks2") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCBanks1") ||                 
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPThoroughbreds") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryHitpointsFrench") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryDamageFrenchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightCombat") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightHitpoints") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPWarHutTraining") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryDamageIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPInfantryCombatIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPInfantryHitpointsIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPInfantryDamageIroquoisIroquois") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCInfantryCombatDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCInfantryHitpointsDutchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCInfantryDamageDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiegeDiscipline") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPConservativeTactics") ||         
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCTerritorialArmyCombat") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCHanAntiCavalryBonus") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCForbiddenArmyArmor") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCManchuCombat") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCYumiDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAshigaruDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAshigaruAntiCavalryDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCYumiRange") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCNaginataAntiInfantryDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCNaginataHitpoints") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCYabusameDamage") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCYabusameAntiArtilleryDamage") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCGurkhaAid") ||                
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCEastIndiaCompany") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCCamelFrightening") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCInfantrySpeedHitpointsTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCElephantLimit") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCElephantCombatIndians") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCElephantTrampling") ||
			    (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCCamelDamageIndians") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCMeleeDamageIndians") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCommandSkill") ||	
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryDamageSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryHitpointsSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryCombatSioux") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPMustangs") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiouxYanktonSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiouxSanteeSupport") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiouxTwoKettleSupport") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPInfantryDamageIroquois") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPInfantryHitpointsIroquois") ||		 		
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryHitpointsIroquois") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiegeCombat") ||		
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightDamage") ||		 
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightHitpoints") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPScorchedEarth") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPRuthlessness") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPGreatTempleHuitzilopochtli") || 
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTempleXipeTotec") || 
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTempleTlaloc") || 
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPGreatTempleQuetzalcoatl") || 
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMusketeerGrenadierHitpointsBritishTeam") ||                 
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMusketeerGrenadierDamageBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMusketeerGrenadierCombatBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryDamageBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryHitpointsBritish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryDamageFrenchTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCWildernessWarfare") ||		 
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryHitpointsFrench") ||		                  
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCJanissaryCost") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCJanissaryCombatOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCLightArtilleryHitpointsOttoman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCArtilleryHitpointsOttomanTeam") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCArtilleryDamageOttoman") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryHitpointsPortugueseTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCArtilleryHitpointsPortugueseTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryDamagePortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryCombatPortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCDragoonCombatPortuguese") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPGenitours") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeDutch") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCDutchEastIndiaCompany") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCInfantryDamageDutch") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCInfantryCombatDutch") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatDutch") ||	 
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCBetterBanks") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCStreletsCombatRussian") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRansack") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatRussian") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUniqueCombatRussian") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPIndustrialRevolution") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryDamageSpanishTeam") ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryCombatSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryCombatSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCaballeros") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryDamageSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryHitpointsSpanish") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryHitpointsSpanish") ||    
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryDamageGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryHitpointsGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUhlanCombatGerman") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSpahis4") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSpahis3") ||
				(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipFalconets3") ||
				((kbGetCiv() == cCivOttomans) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCEngineeringSchool")) ||
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryDamageGermanTeam")||   
                (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAdvancedConsulate") ||      
				((kbGetCiv() != cCivXPIroquois) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates1")) ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAdvancedConsulate") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAdvancedConsulateIndians") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCSmoothRelations") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCSmoothRelationsIndians") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAccupuncture") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCBannerSchool") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCNativeIncorporationIndians") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCVillagemasons") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAgrarianism") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRefrigerationGerman") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRefrigeration") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalMint") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalMintGerman") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCRoyalMintIndians") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCNativeDamage") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCGoraksha") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipRicePaddyWagon3") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCIncreasedTribute") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCFencingSchoolIndians") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCRidingSchoolIndians") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRidingSchool") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipShrineWagon2") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFencingSchool") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPMustangs") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFencingSchoolGerman") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRidingSchoolGerman") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipWoodCratesInf4Indians") ||
                 (gNavyMap == true) && ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAdmiralityIndians") ||
                 (gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCAdmirality")) ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCOldHanArmyReforms") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCWesternReforms") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeDutch") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeFrench") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUnlockFactory") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRobberBarons") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUnlockFactoryGerman") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRobberBaronsGerman") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCImprovedLongbows") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCoinCratesAztec3") ||
                 ((gInitialStrategy == 0) || (gInitialStrategy >= 2)) && ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPDistributivism") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoureurs4") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3") ||                 
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3German") ||
                 //((kbGetCiv() == cCivXPIroquois) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates2")) ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPEconomicTheory") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPColbertism") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFoodSilos") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCSustainableAgriculture") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCSustainableAgricultureIndians") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCFoodSilosIndians") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCRumDistilleryIndians") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCGermantownFarmers") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCapitalism") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalMintGerman") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRefrigerationGerman") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCGuildArtisans") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCigarRollerGerman") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCSustainableAgricultureGerman") ||
                 ((civIsAsian() == false) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPLandGrab")) ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCBanks2") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCBanks1") ||                 
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPThoroughbreds") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHouseEstates") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatFrench") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryDamageFrenchTeam") ||
                 //((kbGetCiv() != cCivDutch) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCigarRoller"))) ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPChinampa2") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPChinampa1") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightCombat") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPWarHutTraining") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryDamageIroquois") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPInfantryCombatIroquois") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiegeDiscipline") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPGreatHouse") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPConservativeTactics") ||
                 //(gInitialStrategy == 3) && ( ((civIsAsian() == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAdvancedRicePaddyIndians") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAdvancedRicePaddy")) ||
                 ((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCEngineeringSchoolTeam")) ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCConfusciousGift") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCSpawnRefugees1") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCSpawnRefugees2") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCTextileMills") ||                 
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCTerritorialArmyCombat") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCHanAntiCavalryBonus") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCForbiddenArmyArmor") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCManchuCombat") ||
                 ((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCChonindoTeam")) ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShrineLearning") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipRicePaddyWagon2") ||
		 //((gNavyMap == false) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipRicePaddyWagon1")) ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCYumiDamage") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAshigaruDamage") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAshigaruAntiCavalryDamage") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCYumiRange") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCNaginataAntiInfantryDamage") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCYabusameDamage") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCGurkhaAid") ||                
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCEastIndiaCompany") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCCamelFrightening") ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCExoticHardwoodsIndians") ||
                 (getAllyCount() > 0) && ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCRainbowTrickleTeam") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCInfantrySpeedHitpointsTeam")) ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCElephantLimit") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCElephantCombatIndians") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCElephantTrampling") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCCamelDamageIndians") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCMeleeDamageIndians") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCRumDistilleryIndians") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCFoodSilosIndians") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPEarthBounty") ||
                 //((kbGetCiv() != cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCExoticHardwoods")) ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCommandSkill") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPWarChiefSioux1") ||		 
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCNativeWarriors") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPBlackArrow") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPShipTradingPostTravois") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPNewWaysSioux") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPShipWarHutTravois1") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPAdoption") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryDamageSioux") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryHitpointsSioux") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryCombatSioux") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPMustangs") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiouxYanktonSupport") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiouxSanteeSupport") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiouxTwoKettleSupport") ||
                 //((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCNativeChampionsDutchTeam")) ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFoodSilosTeam") ||
                 //((civIsNative() == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPMedicineTeam"))) ||
                 //((getAllyCount() == 0) && (civIsNative() == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMedicine")) ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPWarChiefIroquois2") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPWarChiefIroquois1") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPNewWaysIroquois") ||		 
		 ((kbGetCiv() != cCivFrench) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCEngineeringSchool")) ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPExtensiveFortifications2") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPInfantryDamageIroquois") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPInfantryHitpointsIroquois") ||		 		
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryHitpointsIroquois") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiegeCombat") ||		 
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPShipMixedCratesRepeat") ||                 
		 //((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPExoticHardwoodsTeam")) ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPStoneTowers") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPExtensiveFortificationsAztec") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPWarChiefAztec1") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightDamage") ||		 
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightHitpoints") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPScorchedEarth") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPRuthlessness") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTempleXolotl") || 
                 ((getAllyCount() > 0) && (gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCheapDocksTeam")) ||
                 ((getAllyCount() > 0) && (gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFishMarketTeam")) ||
                 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFastHousesTeam") ||
                 ((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMusketeerGrenadierHitpointsBritishTeam")) ||                 
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatBritish") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMusketeerGrenadierDamageBritish") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMusketeerGrenadierCombatBritish") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryDamageBritish") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryHitpointsBritish") ||
                 ((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryDamageFrenchTeam")) ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCWildernessWarfare") ||		 
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryHitpointsFrench") ||		                  
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCJanissaryCost") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCJanissaryCombatOttoman") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatOttoman") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPIrregulars") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCLightArtilleryHitpointsOttoman") ||
         (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCArtilleryHitpointsOttomanTeam")) ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCArtilleryDamageOttoman") ||
                 ((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryHitpointsPortugueseTeam") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCArtilleryHitpointsPortugueseTeam")) ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryDamagePortuguese") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryCombatPortuguese") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCDragoonCombatPortuguese") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPGenitours") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPRangefinding") ||
                 ((gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCNavigationSchool")) ||
                 //((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMortarsDamageDutchTeam")) ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeDutch") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCDutchEastIndiaCompany") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCInfantryDamageDutch") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCInfantryCombatDutch") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatDutch") ||
		 ((gNavyMap == false) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPMilitaryReforms")) ||		 
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCBetterBanks") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCStreletsCombatRussian") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRansack") ||
                 ((gNavyMap == true) && (getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCColdWaterPortTeam")) ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCSpawnStrelet") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatRussian") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUniqueCombatRussian") ||
		 //(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUnicorne") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPIndustrialRevolution") ||
                 ((gNavyMap == false) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSevastopol")) ||
                 ((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCDuelingSchoolTeam")) ||
                 ((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCArchaicTrainingTeam") ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryDamageSpanishTeam")) ||
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryCombatSpanish") ||
                 ((gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCArmada")) ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryCombatSpanish") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCaballeros") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryDamageSpanish") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryHitpointsSpanish") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryHitpointsSpanish") ||                 
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCTextileMillsGerman") || 
                 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryDamageGerman") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryCombatGerman") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatGerman") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryHitpointsGerman") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUhlanCombatGerman") ||
         ((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSpahisTeam") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSpahis4") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSpahis3") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSpahis2") ||
		 (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSpahis1") ||
                 ((gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCSchooners")) ||
                 ((gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCSchoonersIndians")) ||
                 ((gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCSchoonersJapanese")) ||
                 ((gNavyMap == true) && (getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCheapFishingBoatTeam")) ||
                 ((getAllyCount() > 0) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryDamageGermanTeam")) ||                 
                 ((gNavyMap == true) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCAdmiralityGerman"))) )              
                {
                    aiHCDeckAddCardToDeck(gDefaultDeck, card);
                    cardsRemaining = cardsRemaining - 1;
                    xsArraySetString(gCardStates, card, "D");
                    aiEcho("  Adding card "+xsArrayGetString(gCardNames, card));
                }
            }
        }           
         // Next, 3 econ-biased age 1 cards. 
         //toPick = 0;        
         for (i=0; < 0) 
         {  // 3 age 1 cards
            int bestCard = -1;
            int bestCardPri = -1;
            for (card=0; < maxCards)
            {
               if (xsArrayGetString(gCardStates, card) != "P")
                  continue;   // Only consider purchased cards not already in deck.
               if (xsArrayGetInt(gCardPriorities, card) == 10)
                  continue;   // Ignore so-called "prerequisite cards"
               if (aiHCCardsGetCardAgePrereq(card) != cAge1)
                  continue;
               if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;
               }
               else if (((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoureurs3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipCoureurs1")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSettlers3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipSettlers1")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSettlers4") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipSettlers2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPShipVillagers3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCXPShipVillagers1")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipSettlerWagons3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipSettlerWagons1")))
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;  // make sure 3 Settlers cards win over 2 Settlers cards
               }
            }
            if (bestCard >= 0)
            {
               aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
               cardsRemaining = cardsRemaining - 1;
               xsArraySetString(gCardStates, bestCard, "D");
               aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
            }
         }  // 19-22 remaining.
         
			
         // Next, econ-biased age 2 cards. 2 for rusher, 3 for others.
         toPick = 2; // + ((btRushBoom+1.0) * 1.51); // Boomer 1, rusher 6  (XPack boomer 2, rusher 7);
         //if (gInitialStrategy == 1)
            //toPick = 2;
         for (i=0; < 0) 
         {  
            bestCard = -1;
            bestCardPri = -1;
            for (card=0; < maxCards)
            {
               if (xsArrayGetString(gCardStates, card) != "P")
                  continue;   // Only consider purchased cards not already in deck.
               if (xsArrayGetInt(gCardPriorities, card) == 10)
                  continue;   // Ignore so-called "prerequisite cards"
               if (aiHCCardsGetCardAgePrereq(card) != cAge2)
                  continue;
               if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;
               }
               else if (((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipFoodCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipCoinCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipFoodCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipCoinCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipFoodCrates3Indians") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "YPHCShipFoodCrates2Indians")))
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;  // make sure 700 resource cards win over 600 resource cards
               }
               else if (((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates2") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates3")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates2") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates3")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates2German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates3German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates2German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates3German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipWoodCrates2Indians") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "YPHCShipFoodCrates2Indians")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipWoodCrates2Indians") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "YPHCShipFoodCrates3Indians")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipCoinCrates2Indians") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "YPHCShipWoodCrates2Indians")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "ypHCShipWoodCrates2") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "ypHCShipFoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "ypHCShipCoinCrates2") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "ypHCShipWoodCrates2")))
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;  // make sure wood wins over food and coin wins over wood in Age 2 (for India, even 600 wood/coin wins over 700 food)
               }
            } 
            if (bestCard >= 0)
            {
               aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
               cardsRemaining = cardsRemaining - 1;
               xsArraySetString(gCardStates, bestCard, "D");
               aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
            }
         }  // 16-20 remaining


         // Next, age 2 military cards.  2 for a boomer, 5 for a rusher.
         toPick = 2; // + ((btRushBoom+1.0) * 3.99); // Boomer 2, rusher 5
         for (i=0; < 0) 
         {              
            bestCard = -1;
            bestCardPri = -1;
            for (card=0; < maxCards)
            {
               if (xsArrayGetString(gCardStates, card) != "P")
                  continue;   // Only consider purchased cards not already in deck.
               if (aiHCCardsGetCardAgePrereq(card) != cAge2)
                  continue;
               if (xsArrayGetInt(gCardPriorities, card) > 5)
                  continue;   // Ignore priorities above 'military'
               if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;
               }
            }
            if (bestCard >= 0)
            {
               aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
               cardsRemaining = cardsRemaining - 1;
               xsArraySetString(gCardStates, bestCard, "D");
               aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
            }
         } // 9-14 remaining  XPack 11-16 left
         
			
         for (i=0; < 0) 
         {  //4 age 3 cards, (XPack 5)
            bestCard = -1;
            bestCardPri = -1;
            for (card=0; < maxCards)
            {
               if (xsArrayGetString(gCardStates, card) != "P")
                  continue;   // Only consider purchased cards not already in deck.
               if (aiHCCardsGetCardAgePrereq(card) != cAge3)
                  continue;
               if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;
               }
            }
            if (bestCard >= 0)
            {
               aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
               cardsRemaining = cardsRemaining - 1;
               xsArraySetString(gCardStates, bestCard, "D");
               aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
            }
         }  // 5-10 remaining.   (Xpack 6-11)

         toPick = cardsRemaining - 5; // boomers go heavy here, adding 5 more.  (XPack 6 more)
         for (i=0; < 0) 
         {  
            bestCard = -1;
            bestCardPri = -1;
            for (card=0; < maxCards)
            {
               if (xsArrayGetString(gCardStates, card) != "P")
                  continue;   // Only consider purchased cards not already in deck.
               if (aiHCCardsGetCardAgePrereq(card) != cAge3)
                  continue;
               if (xsArrayGetInt(gCardPriorities, card) > 5)
                  continue;   // Ignore priorities above 'military'
               if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;
               }
            }
            if (bestCard >= 0)
            {
               aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
               cardsRemaining = cardsRemaining - 1;
               xsArraySetString(gCardStates, bestCard, "D");
               aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
            }
         } // 5 remaining.  
         
         for (i=0; < 0) 
         {  // 2 age 4cards
            bestCard = -1;
            bestCardPri = -1;
            for (card=0; < maxCards)
            {
               if (xsArrayGetString(gCardStates, card) != "P")
                  continue;   // Only consider purchased cards not already in deck.
               if (aiHCCardsGetCardAgePrereq(card) != cAge4)
                  continue;
               if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;
               }
            }
            if (bestCard >= 0)
            {
               aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
               cardsRemaining = cardsRemaining - 1;
               xsArraySetString(gCardStates, bestCard, "D");
               aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
            }
         } // 3 remaining.
         
         // 2 age-4 military cards
         for (i=0; < 0) 
         {  
            bestCard = -1;
            bestCardPri = -1;
            for (card=0; < maxCards)
            {
               if (xsArrayGetString(gCardStates, card) != "P")
                  continue;   // Only consider purchased cards not already in deck.
               if (aiHCCardsGetCardAgePrereq(card) != cAge4)
                  continue;
               if (xsArrayGetInt(gCardPriorities, card) > 5)
                  continue;   // Ignore priorities above 'military'
               if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;
               }
            }
            if (bestCard >= 0)
            {
               aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
               cardsRemaining = cardsRemaining - 1;
               xsArraySetString(gCardStates, bestCard, "D");
               aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
            }
         }  // 1 remaining.
         
         for (i=0; < cardsRemaining) 
         {  // final cards, any age
            bestCard = -1;
            bestCardPri = -1;
            for (card=0; < maxCards)
            {
               if (xsArrayGetString(gCardStates, card) != "P")
                  continue;   // Only consider purchased cards not already in deck.
               if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
               {
                  bestCardPri = xsArrayGetInt(gCardPriorities, card);
                  bestCard = card;
               }
            }
            if (bestCard >= 0)
            {
               aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
               //cardsRemaining = cardsRemaining - 1;
               xsArraySetString(gCardStates, bestCard, "D");
               aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
            }
         } 
         
         aiHCDeckActivate(gDefaultDeck);
         
         xsDisableSelf();
         break;
      }
   }
}

//==============================================================================
// init...Called once we have units in the new world.
//==============================================================================
void init(void)
{
   //Set the Explore Danger Threshold.
   aiSetExploreDangerThreshold(110.0);

   // Set the gIAmCaptain bool and gCaptainPlayerNumber vars.
   selectCaptain();  

   //Setup the resign handler
   aiSetHandler("resignHandler", cXSResignHandler);

   //Setup the nugget handler
   aiSetHandler("nuggetHandler", cXSNuggetHandler);
   
   // Set up the age-up chat handler
   aiSetHandler("ageUpHandler", cXSPlayerAgeHandler);

   //-- set the ScoreOppHandler
   aiSetHandler("scoreOpportunity", cXSScoreOppHandler);
   
   //Set up the communication handler
   aiCommsSetEventHandler("commHandler");
   
   // This handler runs when you have a shipment available in the home city
   aiSetHandler("shipGrantedHandler", cXSShipResourceGranted);
   
   // Handlers for mission start/end
   aiSetHandler("missionStartHandler",cXSMissionStartHandler);
   aiSetHandler("missionEndHandler",cXSMissionEndHandler);
   
   // Game ending handler, to save game-to-game data before game ends
   aiSetHandler("gameOverHandler",cXSGameOverHandler);
   
   // Handler when a player starts the monopoly victory timer
   aiSetHandler("monopolyStartHandler",cXSMonopolyStartHandler);
   
   // And when a monopoly timer prematurely ends
   aiSetHandler("monopolyEndHandler",cXSMonopolyEndHandler);
   
   // Handler when a player starts the KOTH victory timer
   aiSetHandler("KOTHVictoryStartHandler",cXSKOTHVictoryStartHandler);
   
   // And when a KOTH timer prematurely ends
   aiSetHandler("KOTHVictoryEndHandler",cXSKOTHVictoryEndHandler);

   //-- init Econ and Military stuff.
   initEcon();
   initMil();
  
   if (aiGetGameType() == cGameTypeScenario)
      cvOkToResign = false;   // Default is to not allow resignation in scenarios.  Can override in postInit().
      
   if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)   // We have a flag, there must be water...
   {  
      gGoodFishingMap = true;
      gNavyMap = true;
   }
         
   if ( (cRandomMapName == "amazonia") || (cRandomMapName == "caribbean") || (cRandomMapName == "Ceylon") )
   {   
      //gNavyMap = true;
      cvTransportMap = true;
   }
     
   /* natives aim for slightly more villagers (fire pit dancers!)
   if (civIsNative() == true)
   {
      int i = 0;
      for (i=0; <=cAge5)
      {
         xsArraySetInt(gTargetSettlerCounts, i, xsArrayGetInt(gTargetSettlerCounts, i) * 1.1);
      }
   }*/

      
   // Create a temporary main base so the plans have something to deal with.
   // If there is a scenarioStart object, use it.  If not, use the TC, if any.
   // Failing that, use an explorer, a war chief, a monk, a settlerWagon, or a Settler.  
   // Failing that, select any freakin' unit and use it.
   vector tempBaseVec = cInvalidVector;
   int unitID = -1;
   unitID = getUnit(cUnitTypeAIStart, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeTownCenter, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeExplorer, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypexpAztecWarchief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypexpIroquoisWarChief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypexpLakotaWarchief, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkChinese, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkIndian, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkIndian2, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkJapanese, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeypMonkJapanese2, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(gCoveredWagonUnit, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(cUnitTypeSettler, cMyID, cUnitStateAlive);
   if (unitID < 0)
      unitID = getUnit(gEconUnit, cMyID, cUnitStateAlive);
   
   if (unitID < 0)
      aiEcho("**** I give up...I can't find an aiStart unit, TC, wagon, explorer or settler.  How do you expect me to play?!");
   else
      tempBaseVec = kbUnitGetPosition(unitID);
   
   // This will create an interim main base at this location. 
   // Only done if there is no TC, otherwise we rely on the auto-created base
	if ( (gStartMode == cStartModeScenarioNoTC) || (getUnit(cUnitTypeTownCenter, cMyID, cUnitStateAlive) < 0) )
      gMainBase = createMainBase(tempBaseVec);     

   // If we have a covered wagon, let's pick a spot for the TC search to begin, and a TC start time to activate the build plan.
   int coveredWagon = getUnit(gCoveredWagonUnit, cMyID, cUnitStateAlive);
   if (coveredWagon >= 0)
   {
      vector coveredWagonPos = kbUnitGetPosition(coveredWagon);
      vector normalVec = xsVectorNormalize(kbGetMapCenter()-coveredWagonPos);
      int offset = 40;
      gTCSearchVector = coveredWagonPos + (normalVec * offset);
      
      while (kbAreaGroupGetIDByPosition(gTCSearchVector) != kbAreaGroupGetIDByPosition(coveredWagonPos) )
      {  
	 // Try for a goto point 40 meters toward center.  Fall back 5m at a time if that's on another continent/ocean.  
	 // If under 5, we'll take it.
         offset = offset - 5;
         gTCSearchVector = coveredWagonPos + (normalVec * offset);
         if (offset < 5)
            break;  
      }
      
      // Note...if this is a scenario, we should use the AIStart object's position, NOT the covered wagon position.  Override...
      int aiStart = getUnit(cUnitTypeAIStart, cMyID, cUnitStateAny);
      if (aiStart >= 0)
      {
         gTCSearchVector = kbUnitGetPosition(aiStart);
         aiEcho("Using aiStart object at "+gTCSearchVector+" to start TC placement search");
      }
   }
   
   // Keep Dutch envoy busy
   xsEnableRule("envoyMonitor");

   // Keep native scouts busy
   xsEnableRule("nativeScoutMonitor");

   // Keep mongol scouts busy
   xsEnableRule("mongolScoutMonitor");

   // Enable european upgrade plan
   xsEnableRule("europeanUpgradeMonitor");

   // Enable native upgrade plan
   xsEnableRule("nativeUpgradeMonitor");

   // Enable asian upgrade plan
   xsEnableRule("asianUpgradeMonitor");

   // Enable priest plan
   //xsEnableRule("priestMonitor");

   // Enable missionary plan
   //xsEnableRule("missionaryMonitor");

   // Enable imam plan
   //xsEnableRule("imamMonitor");

   // Enable grenadier plan
   //xsEnableRule("grenadierMonitor");

   // Enable organgun plan
   //xsEnableRule("organgunMonitor");

   // Enable oprichnik plan
   //xsEnableRule("oprichnikMonitor");

   // Enable musketeer plan
   //xsEnableRule("musketeerMonitor");

   // Enable flamethrower plan
   //xsEnableRule("flamethrowerMonitor");

   // Enable daimyo plan
   xsEnableRule("daimyoMonitor");

   // Enable shogun plan
   xsEnableRule("shogunMonitor");

   // Enable arrowknight plan
   //xsEnableRule("arrowknightMonitor");

   // Enable explorer rescue plan
   xsEnableRule("rescueExplorer");

   // Enable explorer ransoming
   xsEnableRule("ransomExplorer");

   // Disables early groups, starts nugget hunting, moves explorer later.
   xsEnableRule("exploreMonitor"); 
   
   if ( (gStartMode == cStartModeScenarioWagon) || 
	(gStartMode == cStartModeLandWagon) || 
	(gStartMode == cStartModeBoat) )
   {
      aiEcho("Creating a TC build plan.");
      // Make a town center, pri 100, econ, main base, 1 builder.
      int buildPlan=aiPlanCreate("TC Build plan ", cPlanBuild);
      // What to build
      aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeTownCenter);
      // Priority.
      aiPlanSetDesiredPriority(buildPlan, 100);
      // Mil vs. Econ.
      aiPlanSetMilitary(buildPlan, false);
      aiPlanSetEconomy(buildPlan, true);
      // Escrow.
      aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
      // Builders.
      if (kbUnitCount(cMyID, gCoveredWagonUnit, cUnitStateAlive) > 0)
        aiPlanAddUnitType(buildPlan, gCoveredWagonUnit, 1, 1, 1);
      else if ( (civIsEuropean() == false) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 0) )
        aiPlanAddUnitType(buildPlan, gEconUnit, 2, 4, 6); 
      else 
        aiPlanAddUnitType(buildPlan, gExplorerUnit, 1, 1, 1);

      // Instead of base ID or areas, use a center position and falloff.
      if(gTCSearchVector == cInvalidVector)
         aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, coveredWagonPos);
      else
         aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, gTCSearchVector);
      aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 40.00);
   
      // Add position influences for trees, gold
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitTypeID, 3, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitDistance, 3, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitValue, 3, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitFalloff, 3, true);
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeWood);
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 30.0);     // 30m range.
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, 10.0);        // 10 points per tree
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeMine);
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 1, 50.0);              // 50 meter range for gold
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 1, 300.0);                // 300 points each
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear);  // Linear slope falloff
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeMine);
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 2, 20.0);              // 20 meter inhibition to keep some space
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 2, -300.0);                // -300 points each
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone);      // Cliff falloff
      
      // Two position weights
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePosition, 2, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePositionDistance, 2, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePositionValue, 2, true);
      aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePositionFalloff, 2, true);
      
      // Give it a positive but wide-range prefernce for the search area, and a more intense but smaller negative to avoid the landing area.
      // Weight it to prefer the general starting neighborhood
      aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, gTCSearchVector);    // Position influence for search position
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, 200.0);     // 200m range.
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 300.0);        // 300 points max
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
      
      // Add negative weight to avoid initial drop-off beach area
      aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 1, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));    // Position influence for landing position
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 1, 50.0);     // Smaller, 50m range.
      aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 1, -400.0);      // -400 points max
      aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 1, cBPIFalloffLinear);  // Linear slope falloff
      // This combo will make it dislike the immediate landing (-100), score +25 at 50m, score +150 at 100m, then gradually fade to +0 at 200m.
     
      // Wait to activate TC build plan, to allow adequate exploration
	  GTowerBuildPlanID = buildPlan;
      gTCBuildPlanID = buildPlan;   // Save in a global var so the rule can access it.
      aiPlanSetEventHandler(buildPlan, cPlanEventStateChange, "tcPlacedEventHandler");    
      
      xsEnableRule("tcBuildPlanDelay");
      xsEnableRule("GTowerBuildPlanID");
   }

   if (cvOkToBuildDeck == true)
   {  xsEnableRule("buyCards");  }
   
   xsEnableRule("useCoveredWagons");
   xsEnableRule("townCenterComplete");  // Rule to build other buildings after TC completion     
   xsEnableRule("useFactoryWagons");
   xsEnableRule("useRicePaddyWagons");        
   xsEnableRule("tcMonitor");    // Has explorer, war chief, Asian monks or settlers build a TC if there is none
   //xsEnableRule("ageUpgradeMonitor");  // Make sure we freeze spending to allow age-ups at certain villie pop levels
   
   postInit();		// All normal initialization is done, let loader file clean up what it needs to.
   
   // Store the initial settings for later retrieval (to handle 'cancel' after a train bias command.
   gInitRushBoom = btRushBoom;
   gInitOffenseDefense = btOffenseDefense;
   gInitBiasCav = btBiasCav;
   gInitBiasInf = btBiasInf;
   gInitBiasArt = btBiasArt;
   gInitBiasNative = btBiasNative;
   gInitBiasTrade = btBiasTrade;
   aiEcho("INITIAL BEHAVIOR SETTINGS");
   aiEcho("Rush "+btRushBoom);
   aiEcho("Offense "+btOffenseDefense);
   aiEcho("Cav "+btBiasCav);
   aiEcho("Inf "+btBiasInf);
   aiEcho("Art "+btBiasArt);
   aiEcho("Natives "+btBiasNative);
   aiEcho("Trade "+btBiasTrade);
   
   // Re-do politician choices now that postInit() is complete...
   int poliScores = xsArrayCreateFloat(6, 0.0, "Politician scores");
   int numChoices = -1;
   int politician = -1;
   float bonus = 0.0;
   
   for (age = cAge2; <= cAge5)
   {
      for (p=0; <6)
         xsArraySetFloat(poliScores, p, 0.0);   // Reset scores
      numChoices = aiGetPoliticianListCount(age);
      for (p=0; <numChoices)
      {  // Score each of these choices based on the strength of our behavior settings.
         politician = aiGetPoliticianListByIndex(age, p);
         // Rusher bonuses
         if (btRushBoom > 0.0)
            bonus = btRushBoom;
         else
            bonus = 1.0;
         if (  (politician == cTechPoliticianQuartermaster) || 
               (politician == cTechPoliticianScout) ||
               (politician == cTechPoliticianScoutRussian) ||
               (politician == cTechPoliticianSergeantDutch) || 
               (politician == cTechPoliticianSergeantGerman) ||
               (politician == cTechPoliticianSergeantSpanish) || 
               (politician == cTechPoliticianMohawk) || 
               (politician == cTechPoliticianMarksman) ||
               (politician == cTechPoliticianMarksmanOttoman) ||
               (politician == cTechPoliticianMarksmanPortuguese) ||
               (politician == cTechPoliticianAdventurerBritish) ||
               (politician == cTechPoliticianAdventurerRussian) ||
               (politician == cTechPoliticianAdventurerSpanish) )
         {
            xsArraySetFloat(poliScores, p, xsArrayGetFloat(poliScores, p) + bonus); // Add in a bonus based on our rusher trait.
         }
         // Boomer bonuses
         if (btRushBoom < 0.0)
            bonus = -1.0 * btRushBoom;
         else
            bonus = 0.0;
         if (  (politician == cTechPoliticianBishop) ||
               (politician == cTechPoliticianBishopGerman) ||
               (politician == cTechPoliticianTycoon) ||
               (politician == cTechPoliticianExiledPrince) ||
               (politician == cTechPoliticianPresidente) )
         {
            xsArraySetFloat(poliScores, p, xsArrayGetFloat(poliScores, p) + bonus); // Add in a bonus based on our boomer trait.
         }
         // Defense bonuses
         if (btOffenseDefense < 0.0)
            bonus = -1.0 * btOffenseDefense; // Defense rating
         else
            bonus = 0.0;
         if (politician == cTechPoliticianGovernor)
         {
            xsArraySetFloat(poliScores, p, xsArrayGetFloat(poliScores, p) + bonus); // Add in a bonus based on our defense trait.
         }
         // Offense bonuses
         if (btOffenseDefense > 0.0)
            bonus = btOffenseDefense;
         else
            bonus = 0.0;
         if (  (politician == cTechPoliticianScout) ||
               (politician == cTechPoliticianScoutRussian) ||
               (politician == cTechPoliticianSergeantDutch) || 
               (politician == cTechPoliticianSergeantGerman) ||
               (politician == cTechPoliticianSergeantSpanish) || 
               (politician == cTechPoliticianMohawk) || 
               (politician == cTechPoliticianMarksman) ||
               (politician == cTechPoliticianMarksmanOttoman) ||
               (politician == cTechPoliticianMarksmanPortuguese) ||
               (politician == cTechPoliticianAdventurerBritish) ||
               (politician == cTechPoliticianAdventurerRussian) ||
               (politician == cTechPoliticianAdventurerSpanish) ||
               (politician == cTechPoliticianGeneral) ||
               (politician == cTechPoliticianGeneralBritish) ||
               (politician == cTechPoliticianGeneralOttoman) )
         {
            xsArraySetFloat(poliScores, p, xsArrayGetFloat(poliScores, p) + bonus); // Add in a bonus based on our offense trait.
         }
         if (gNavyMap == false)
         {
            bonus = -10.0; // Essentially disqualify any navy polis
            if (  (politician == cTechPoliticianAdmiral) ||
                  (politician == cTechPoliticianAdmiralOttoman) ||
                  (politician == cTechPoliticianPirate) )
            {
               xsArraySetFloat(poliScores, p, xsArrayGetFloat(poliScores, p) + bonus); // Disqualify naval polis on land maps
            }
         }         
      }  // for (p=0; <numChoices)
      
      // The scores are set, find the high score
      int bestChoice = 0;        // Select 0th item if all else fails
      float bestScore = -100.0;  // Impossibly low
      for (p=0; <numChoices)
      {
         if (xsArrayGetFloat(poliScores, p) > bestScore)
         {
            bestScore = xsArrayGetFloat(poliScores, p);
            bestChoice = p;
         }
      }
      politician = aiGetPoliticianListByIndex(age, bestChoice);
      aiSetPoliticianChoice(age, politician);
      aiEcho("Politician for age "+age+" is #"+politician+", "+kbGetTechName(politician));
   } //for (age = cAge2; <= cAge5)
}
   
//==============================================================================
// initRule
// Add a brief delay to make sure the covered wagon (if any) has time to unload
//==============================================================================
rule initRule
inactive
minInterval 3
{
   if (cvInactiveAI == true) 
      return;  // Wait forever unless this changes
   init();
   xsDisableSelf();
}






//==============================================================================
// ottomanMonitor
// Make sure they always have a church, get techs as available
//==============================================================================
rule ottomanMonitor
inactive
minInterval 30
{  
   if (kbGetCiv() != cCivOttomans)  
   {
      xsDisableSelf();
      return;
   }

   int speedPlanID = -1;   // Plan for improving vill training speed.
   int capPlanID = -1;     // Plan for raising settler pop limit.
   int churchPlanID = -1;

   // Disable rule once all techs have been researched
   if ((kbTechGetStatus(cTechChurchMilletSystem) == cTechStatusActive) && 
       (kbTechGetStatus(cTechChurchKopruluViziers) == cTechStatusActive) && 
       (kbTechGetStatus(cTechChurchAbbassidMarket) == cTechStatusActive) &&  
       (kbTechGetStatus(cTechChurchGalataTowerDistrict) == cTechStatusActive) &&  
       (kbTechGetStatus(cTechChurchTopkapi) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchTanzimat) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }
   
   // If no mosque and no build plan, build one, exit.
   if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1)
   {  // No mosque, check for build plan, add one if needed
      churchPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeChurch);  
      if (churchPlanID < 0)
      {      
         aiEcho("Creating church build plan");        
         createSimpleBuildPlan(cUnitTypeChurch, 1, 93, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      }
      return;
   }
  
   // We have a church, continue...
   // Check for each of their techs.  If it's obtainable and there's 
   // no plan, get it.
   

   if (kbTechGetStatus(cTechChurchMilletSystem) == cTechStatusObtainable) 
   {
      speedPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMilletSystem);
      if (speedPlanID < 0)
         createSimpleResearchPlan(cTechChurchMilletSystem, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
   }

   if (kbTechGetStatus(cTechChurchKopruluViziers) == cTechStatusObtainable)
   {
      speedPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchKopruluViziers);
      if (speedPlanID < 0)
         createSimpleResearchPlan(cTechChurchKopruluViziers, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
   }     
   
   if ((kbTechGetStatus(cTechChurchAbbassidMarket) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 2))
   {
      speedPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchAbbassidMarket);
      if (speedPlanID < 0)
         createSimpleResearchPlan(cTechChurchAbbassidMarket, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
   }
   
   if ((kbTechGetStatus(cTechChurchGalataTowerDistrict) == cTechStatusObtainable) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 20))
   {
      capPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGalataTowerDistrict);
      if (capPlanID < 0)
         createSimpleResearchPlan(cTechChurchGalataTowerDistrict, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
   }     
 
   if ((kbTechGetStatus(cTechChurchTopkapi) == cTechStatusObtainable) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 40))
   {
      capPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTopkapi);
      if (capPlanID < 0)
         createSimpleResearchPlan(cTechChurchTopkapi, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
   }

   if ((kbTechGetStatus(cTechChurchTanzimat) == cTechStatusObtainable) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 60))
   {
      capPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTanzimat);
      if (capPlanID < 0)
         createSimpleResearchPlan(cTechChurchTanzimat, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
   }
}

//==============================================================================
// tcBuildPlanDelay
/*
   Allows delayed activation of the TC build plan, so that the explorer has 
   uncovered a good bit of the map before a placement is selected.

   The int gTCBuildPlanID is used to simplify passing of the build plan ID from
   init().
*/
//==============================================================================

rule tcBuildPlanDelay
inactive
minInterval 1
{
  if (xsGetTime() < gTCStartTime)
      return;     // Do nothing until game time is beyond 10 seconds
   
   aiPlanSetActive(gTCBuildPlanID);
   aiEcho("Activating TC build plan "+gTCBuildPlanID+".");
   xsDisableSelf();
}

vector tcBuildPlaceSearch(float searchRange=120.0)
{
     static int mineQuery = -1;
     if (mineQuery < 0)
     {
	mineQuery = kbUnitQueryCreate("Mine query for TC placement");
	kbUnitQuerySetPlayerID(mineQuery, 0);
	kbUnitQuerySetUnitType(mineQuery, cUnitTypeAbstractMine);
	kbUnitQuerySetPosition(mineQuery, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetMaximumDistance(mineQuery, searchRange);
	kbUnitQuerySetAscendingSort(mineQuery, true);   // Ascending distance from initial location
     }
        kbUnitQueryResetResults(mineQuery);
	int mineCount = kbUnitQueryExecute(mineQuery);
	int i = 0;
	int mineID = -1;
	vector loc = cInvalidVector;
	int mineAreaGroup = -1;
	int mainAreaGroup = kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	bool found = false;
	aiEcho("**** Starting TC placement search, found "+mineCount+" mines.");
	for (i=0; < mineCount)
	{  // Check each mine for a nearby TC, i.e. w/in 30 meters.
	   mineID = kbUnitQueryGetResult(mineQuery, i);
	   loc = kbUnitGetPosition(mineID);
	   mineAreaGroup = kbAreaGroupGetIDByPosition(loc);
	   if ( (getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationAny, cUnitStateABQ, loc, 60.0) < 0) && 
		(mineAreaGroup == mainAreaGroup) && 
		(getUnitByLocation(cUnitTypeMilitaryBuilding, cPlayerRelationEnemyNotGaia, cUnitStateABQ, loc, 60.0) < 0) && 
		(getUnitByLocation(cUnitTypeFortFrontier, cPlayerRelationEnemyNotGaia, cUnitStateABQ, loc, 60.0) < 0))
	   {
	      aiEcho("Found good mine at "+loc);
	      found = true;
	      break;
	   }
	   else
	   {
	      aiEcho("    Ignoring mine at "+loc);
	   }
        }      
	// If we found a mine without a nearby TC, use that mine's location.  If not, use the main base.
	if (found == false)
	  loc = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));

     return(loc);
}

//==============================================================================
/* tcMonitor
   
   Look for a TC, or a build plan for a TC.  If neither, start a new plan
   and have explorer, war chief or monk(s) build one.
*/
//==============================================================================
rule tcMonitor
inactive
minInterval 15
{   

   int numUnits = 0;
   float villTarget = xsArrayGetInt(gTargetSettlerCounts, kbGetAge());  // How many we want to have this age
   float villCount = kbUnitCount(cMyID, gEconUnit, cUnitStateABQ);   // How many we have

   numUnits = villTarget - villCount;
   
    int buildLimit = kbGetBuildLimit(cMyID, cUnitTypeTownCenter);
   
    if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) < buildLimit)
    {
        //Start a new TC build plan.        
        float searchRange = 100.0 + 50.0*cNumberPlayers; 
	static Vector tcBuildPlace = cInvalidVector;
        tcBuildPlace = tcBuildPlaceSearch(searchRange);  
        createLocationBuildPlan(cUnitTypeTownCenter, buildLimit, 99, true, cEconomyEscrowID, tcBuildPlace, 1);
	aiEcho("Starting a new TC build plan.");	 
    }
	
    if ((gSettlerMaintainPlan < 0) || (aiPlanGetState(gSettlerMaintainPlan) == cPlanStateNone))
    {
       aiPlanDestroy(gSettlerMaintainPlan);
       gSettlerMaintainPlan = -1;
    }
    if (gSettlerMaintainPlan < 0)
    {
       gSettlerMaintainPlan = createSimpleMaintainPlan(gEconUnit, xsArrayGetInt(gTargetSettlerCounts, kbGetAge()), true, kbBaseGetMainID(cMyID), 1);  
    }

/*
    if ((gSettlerMaintainPlan < 0) || (aiPlanGetState(gSettlerMaintainPlan) == cPlanStateNone))
    {
       aiPlanDestroy(gSettlerMaintainPlan);
       gSettlerMaintainPlan = -1;
    }
	
    if (gSettlerMaintainPlan < 0)
	{
            numUnits = kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
        {
            if (xsArrayGetInt(gTargetSettlerCounts) > numUnits)
            addItemToForecasts(gEconUnit); 
        }
	}
    */
		
		
    static int lastReInitGatherersTime = 0;
    if (xsGetTime() < gAgeUpTime + 60*1000)
    {
       lastReInitGatherersTime = gAgeUpTime;
    }

    if (xsGetTime() > lastReInitGatherersTime + 1*60*1000)
    {
       econMaster();
       kbEscrowAllocateCurrentResources();
       xsEnableRule("reInitGatherers");
       lastReInitGatherersTime = xsGetTime();       
    }
}

//==============================================================================
/* transportArrive()
   
   This function is called when it is time for the AI to come to life.

   In Scenario/Campaign games, it means the aiStart object has been placed.

   In RM/GC games, it means that the player has all the starting units.  This may
   mean that the initial boat has been unloaded, or the player has started
   with a TC and units, or the player has initial units and a covered wagon
   and must choose a TC location.  

   This function activates "initRule" if everything is OK for a start...
*/
//==============================================================================
void transportArrive(int parm=-1) // Event handler
{
   static bool firstTime = true;
   
   if (gSPC == true)
   {
      // Verify aiStart object, return if it isn't there
      if (kbUnitCount(cMyID, cUnitTypeAIStart, cUnitStateAlive) < 1)
      {
         xsEnableRule("waitForStartup");
         return();
      }
   }
   
   if (firstTime == true)
   {  
		// Do init processing
		aiEcho("The transport has arrived.");
		firstTime = false;
		// No need for it, we're running
		xsDisableRule("transportArriveFailsafe");	
      xsEnableRule("initRule");
   }
}

rule transportArriveFailsafe
inactive
minInterval 30
{	// This rule is normally killed when transportArrive runs the first time.
	transportArrive(-1);		// Call it if we're still running at 30 seconds, make sure the AI starts.
}




rule autoSave
inactive
minInterval 5
{
   int interval = 2; // Interval in minutes
   static int nextTime = 0;
   
   // First, do an auto save game if needed
   //Dont save if we are told not to.
   if (aiGetAutosaveOn() == true)
   {
      int firstCPPlayerID = -1;
      for(i=0; < cNumberPlayers)
      {
         if(kbIsPlayerHuman(i) == true)
            continue;
   
         firstCPPlayerID = i;
      }
      if ( (cMyID == firstCPPlayerID) && (xsGetTime() >= nextTime) && (cvDoAutoSaves == true))
      {  // We're the first CP, it's our job to do the save, and it's time to do it.
         //Create the savegame name.
         static int psCount = 0;
         //Save it.
         if (cvDoAutoSaves == true)
         {
            aiQueueAutoSavegame(psCount);
            //Inc our count.
            psCount=psCount+interval;   // Count roughly matches game time in minutes
            while (psCount < (xsGetTime()/600000) )
               psCount = psCount+interval;    // Handle reloading of save games from machines that had saves off...
            nextTime = psCount * 60 * 1000;
         }
      }
   }
}

//==============================================================================
/* rule ageUpgradeMonitor

   This rule decides when it makes sense to work toward an age upgrade.  When that
   time comes, it shifts the normal escrow accounts to zero, sets the upgrade account 
   to 100%, and reallocates everything.  

   This causes the upgrade account to take everything it needs until the age upgrade
   is complete.  The escrows are restored in the next age's 'monitor' rule, i.e.
   the age2monitor, age3Monitor, etc.  
*/
//==============================================================================
rule ageUpgradeMonitor
inactive
group tcComplete
minInterval 15
{
   int specialAgeTech = -1;   // Used for personality-specific overrides
   int politician = -1;
   int planID = -1;
   int i=0;
   static int lastAgeFrozen = -1;
         
   if ((kbGetAge() >= cAge5) || ((aiGetGameMode() == cGameModeDeathmatch) && (kbGetAge() >= cAge4)) )
   {
      xsDisableSelf();
      return;
   }
   
   if ( kbGetAge() >= cvMaxAge )
      return;  // Don't disable, this var could change later...
        
   int foodNeeded = 0;
   int goldNeeded = 0;
   int age = kbGetAge();
   switch (age)
   {
	case cAge1:
	{
	    foodNeeded = 800;
	    goldNeeded = 0;
	    break;
	}
	
	case cAge2:
	{
         if ( (cMyCiv != cCivOttomans) && (cMyCiv != cCivPortuguese) && (xsGetTime() > 12*60*1000)) 
		 {
	    foodNeeded = 1200;
	    goldNeeded = 1000;
		}
	else
	{
	    foodNeeded = 1200;
	    goldNeeded = 1000;
	}
	    break;
	}
	
	
	    case cAge3:
	{
         if (xsGetTime() > 18*60*1000) 
		{
	    foodNeeded = 2000;
	    goldNeeded = 1200;
		}
	else
		{
	    foodNeeded = 2000;
	    goldNeeded = 1200;
		}
	    break;
	}
	
	case cAge4:
	{
	    foodNeeded = 4000;
	    goldNeeded = 4000;
	    break;
	}
	
   }
   
   if ((civIsAsian() == true) && (kbTechGetStatus(cTechypBigConsulatePortuguese) == cTechStatusActive))
   {
       foodNeeded = foodNeeded * 0.85;
   }

   bool readyToAgeUp = false;
   /*if ((kbGetAge() == cAge1) && (civIsAsian() == true) && (kbGetCiv() != cCivChinese) && (kbGetCiv() != cCivSPCChinese)&&(aiGetGameMode() != cGameModeDeathmatch)) 
   {
      if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) > 0)
      {
	  if ((kbResourceGet(cResourceFood) >= foodNeeded)&&(kbResourceGet(cResourceGold) >= goldNeeded)&&(kbTechGetStatus(cTechypBigConsulatePortuguese) == cTechStatusActive))
	     readyToAgeUp = true;
      }
      else if (xsGetTime() > 120000) //let Asians have enough time to build consulate.
      {
	  if ((kbResourceGet(cResourceFood) >= foodNeeded)&&(kbResourceGet(cResourceGold) >= goldNeeded))
	     readyToAgeUp = true;
      }
   }*/
    if ((kbGetAge() == cAge2) && (xsGetTime() > 12*60*1000)) 
	  readyToAgeUp = true;
   else
    if ((kbGetAge() == cAge3) && (xsGetTime() > 18*60*1000)) 
	  readyToAgeUp = true;
   else
    if ((kbGetAge() == cAge4) && (xsGetTime() > 24*60*1000)) 
	  readyToAgeUp = true;
   else
   {
	if ((kbResourceGet(cResourceFood) >= foodNeeded)&&(kbResourceGet(cResourceGold) >= goldNeeded))
	  readyToAgeUp = true;
   }
    
   // Quit if we already have a plan in the works
   if (gAgeUpResearchPlan >= 0)
   {
      //now it should be in the course of aging up.
      if (aiPlanGetState(gAgeUpResearchPlan) >= 0)
      {
	 return;  
      }
      else
      {  // Plan variable is set, but plan is dead.
	  aiPlanDestroy(gAgeUpResearchPlan);
	  gAgeUpResearchPlan = -1;
      }
   }

  
      if ((civIsAsian() == true) &&( gAgeUpResearchPlan < 0))
      {
	  specialAgeTech = chooseAsianWonder(); 
	  aiEcho("Wonder to build: "+kbGetProtoUnitName(specialAgeTech));
	  aiEcho("Should we make the plan?: "+gAgeUpResearchPlan);
	  int wonderBuilders = 0;
	  if (aiGetGameMode() == cGameModeDeathmatch)
	     wonderBuilders = 6;
	  else if (kbGetAge() == cAge1)
	     wonderBuilders = 1;
	  else
	     wonderBuilders = 4;

	  vector myTCLocation = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
	  vector wonderBuildPlace = myTCLocation;

          if (((kbGetCiv() == cCivIndians)||(kbGetCiv() == cCivSPCIndians))&&
	      ((specialAgeTech == cUnitTypeypWIAgraFort2)||
	      (specialAgeTech == cUnitTypeypWIAgraFort3)||
	      (specialAgeTech == cUnitTypeypWIAgraFort4)||
	      (specialAgeTech == cUnitTypeypWIAgraFort5)))
	  {
	      vector normalVec = xsVectorNormalize(kbGetMapCenter()-myTCLocation);	
	      wonderBuildPlace = selectForwardBaseLocation();
	  }
          else if (((kbGetCiv() == cCivJapanese)||(kbGetCiv() == cCivSPCJapanese)||(kbGetCiv() == cCivSPCJapaneseEnemy))&&
		   ((specialAgeTech == cUnitTypeypWJToshoguShrine2)||
		   (specialAgeTech == cUnitTypeypWJToshoguShrine3)||
		   (specialAgeTech == cUnitTypeypWJToshoguShrine4)||
		   (specialAgeTech == cUnitTypeypWJToshoguShrine5)))
	  {
	      int animalID = getUnitByLocation(cUnitTypeHuntable, 0, cUnitStateAlive, myTCLocation, 50.0);
	      if (animalID >= 0)
		wonderBuildPlace = kbUnitGetPosition(animalID);
	  }
		gAgeUpResearchPlan = createLocationBuildPlan(specialAgeTech, 1, 100, true, cEconomyEscrowID, wonderBuildPlace, wonderBuilders);
		aiPlanSetVariableFloat(gAgeUpResearchPlan, cBuildPlanCenterPositionDistance, 0, 300.0); //confined space on some maps like Bayou would possibly cause aging-up failure because of no room for wonder placement.
		aiEcho("<<<<<<<<<<RushBoom + OffenseDefense = "+btRushBoom+" + "+btOffenseDefense+" = "+(btRushBoom+btOffenseDefense));
		aiEcho("Creating plan #"+gAgeUpResearchPlan+" to get age upgrade with wonder "+kbGetProtoUnitName(specialAgeTech));
		return;
	}
	else if (gAgeUpResearchPlan < 0)
	{		
	    if (civIsNative() == true)
		specialAgeTech = chooseNativeCouncilMember();
	    else
	        specialAgeTech = chooseEuropeanPolitician();
        if ((kbTechGetStatus(specialAgeTech) == cTechStatusObtainable) && (gAgeUpResearchPlan < 0))
        { 
            gAgeUpResearchPlan = createSimpleResearchPlan(specialAgeTech, -1, cEmergencyEscrowID, 100);
            aiEcho("Creating plan #"+gAgeUpResearchPlan+" to get age upgrade with tech "+kbGetTechName(specialAgeTech));
            return;
        }
    }

/*
      // First, see if we can afford an age-up politician
      //-- try our personality choice first.
      specialAgeTech = politician;
      if ( specialAgeTech != -1 )
      {
         if ( kbCanAffordTech(specialAgeTech, cEmergencyEscrowID) == true )   
         {  // Can afford or in "escrow-wait" mode...go ahead and make the plan
            if ( (kbTechGetStatus(specialAgeTech) == cTechStatusObtainable) && (gAgeUpResearchPlan < 0) )
            {  // Tech is valid, and we're not yet researching it...
               gAgeUpResearchPlan = createSimpleResearchPlan(specialAgeTech, -1, cEmergencyEscrowID, 100);
               aiEcho("Creating plan #"+gAgeUpResearchPlan+" to get age upgrade with tech "+kbGetTechName(specialAgeTech));
               return;
            }
         }
      }
   
      // No previous choice, let's see if something is available
      if (gAgeUpResearchPlan < 0) // If we're not already waiting for one...
      {
         //-- Walk what is available to us and choose the first one we can afford.
         int count = aiGetPoliticianListCount(kbGetAge());
         for (i=0; < count)
         {
            specialAgeTech = aiGetPoliticianListByIndex(kbGetAge()+1, i);
            if ( kbCanAffordTech(specialAgeTech, cEmergencyEscrowID) == true )   
            {  // Can afford or in "escrow-wait" mode...go ahead and make the plan
               if ( (kbTechGetStatus(specialAgeTech) == cTechStatusObtainable) && (gAgeUpResearchPlan < 0) )
               {
                  gAgeUpResearchPlan = createSimpleResearchPlan(specialAgeTech, -1, cEmergencyEscrowID, 100);                
                  aiEcho("Creating plan #"+gAgeUpResearchPlan+" to get age upgrade with tech "+kbGetTechName(specialAgeTech));
                  return;
               }
            }
         }
      }
   }
   else 
   {  //We are Asian, time to build a wonder
      // Not at deadline...see if we can afford the preferred politician
      politician = chooseAsianWonder();    // Get the specified wonder
      int wonderBuilders = 0;
      
      if (aiGetGameMode() == cGameModeDeathmatch)
	wonderBuilders = 8;
      else if (kbGetAge() == cAge1)
	wonderBuilders = 1;
      else
	wonderBuilders = 4;
      // Quit if we already have a plan in the works
      if (gAgeUpResearchPlan >= 0)
      {
         if (aiPlanGetState(gAgeUpResearchPlan) >= 0)
         {
            return;  
         }
         else 
         {  // Plan variable is set, but plan is dead.
            aiPlanDestroy(gAgeUpResearchPlan);
            gAgeUpResearchPlan = -1;
            // OK to continue, as we don't have an active plan
         }
      }
  
      // First, see if we can afford an age-up politician
  
      //-- try our personality choice first.
      specialAgeTech = politician;
      if (specialAgeTech != -1)
      {
         aiEcho("Wonder to build: "+kbGetProtoUnitName(specialAgeTech));
         aiEcho("Should we make the plan?: "+gAgeUpResearchPlan);
         if ( gAgeUpResearchPlan < 0 )
         {  // Tech is valid, and we're not yet researching it...           
            if (((kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians)) &&
		((specialAgeTech == cUnitTypeypWIAgraFort2) ||
		 (specialAgeTech == cUnitTypeypWIAgraFort3) ||
		 (specialAgeTech == cUnitTypeypWIAgraFort4) ||
		 (specialAgeTech == cUnitTypeypWIAgraFort5)))
	    {  
               vector normalVec = xsVectorNormalize(kbGetMapCenter()-myTCLocation);	
	       wonderBuildPlace = selectForwardBaseLocation(); //myTCLocation + normalVec * 25;
            }
            if (((kbGetCiv() == cCivJapanese) || 
                 (kbGetCiv() == cCivSPCJapanese) || 
                 (kbGetCiv() == cCivSPCJapaneseEnemy)) &&
		((specialAgeTech == cUnitTypeypWJToshoguShrine2) ||
		 (specialAgeTech == cUnitTypeypWJToshoguShrine3) ||
		 (specialAgeTech == cUnitTypeypWJToshoguShrine4) ||
		 (specialAgeTech == cUnitTypeypWJToshoguShrine5)))
            {
	       int animalID = getUnitByLocation(cUnitTypeHuntable, 0, cUnitStateAlive, myTCLocation, 50.0);
	       if (animalID >= 0)
		 wonderBuildPlace = kbUnitGetPosition(animalID);              
	    }
            gAgeUpResearchPlan = createLocationBuildPlan(specialAgeTech, 1, 100, true, cEconomyEscrowID, wonderBuildPlace, wonderBuilders);
            aiPlanSetVariableFloat(gAgeUpResearchPlan, cBuildPlanCenterPositionDistance, 0, 300.0);
            aiEcho("<<<<<<<<<<RushBoom + OffenseDefense = "+btRushBoom+" + "+btOffenseDefense+" = "+(btRushBoom+btOffenseDefense));
            aiEcho("Creating plan #"+gAgeUpResearchPlan+" to get age upgrade with wonder "+kbGetProtoUnitName(specialAgeTech));
            return;
         }
      }
   }*/
}

//==============================================================================
/* shipGrantedHandler()

   

   Update 02/10/2004:  New algorithm.
   1)  Clear the list
   2)  Get all the settlers you can.
   3)  If space remains, get the resource you're lowest on.

   Update on 04/22/2004:  New algorithm:
   1)  First year, get wood
   2)  Later years, get the resource that gives the largest bucket.
   3)  In a tie, coin > food > wood
   Note, in the early years, the resourceManager will sell food and buy wood as needed
   to drive early housing growth.

   Update on 4/27/2004:  Get wood for first TWO years.

   Scrapped on 5/12/2004.  Now, settlers have to be imported.  New logic:
   1)  Get settlers always, except:
   2)  If I can afford governor and I don't have him yet, get him
   3)  If I can afford viceroy and I don't have him yet and he's available, get him.
   4)  If settlers aren't available or less than 10 are available, get most needed resource.
   
   August:  Always get an age upgrade if you can.  Otherwise, compute the value for each bucket,
   and choose the best buy.  
   
   November:  Adding multiplier for econ/mil units based on rush/boom emphasis
*/
//==============================================================================
void shipGrantedHandler(int parm=-1) // Event handler
{
   aiEcho(" ");
   aiEcho("SHIP GRANTED:");
   
   if (kbResourceGet(cResourceShips) < 1.0)
      return;     // Early out if we don't have a ship...no point even checking.
   
   if (agingUp() == true)
   {
      // We're aging up, save this shipment for after it completes
      aiEcho("We're aging up, delaying this shipment until then.");
      return;
   }

   if ((gSPC == false) && (kbUnitCount(cMyID, cUnitTypexpColonialMilitia, cUnitStateAlive) > 0))
   {
      // We've revolted, function is no longer appropriate
      aiEcho("Abort -- revolutionary need special handling.");
      return;
   }
   aiEcho("Choosing contents for next transport");
   bool result = false;
   bool homeBaseUnderAttack = false;
   if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      homeBaseUnderAttack = true;      // So don't send resources or settlers....

   // Adjust for rush or boominess
   float econBias = 0.0; // How much to boost econ units or penalize mil units
   // Flip rushboom sign so boomer is +1 and rusher is -1.
   if (kbGetAge() < cAge2)
     econBias = 0.8;
   else
     econBias = .8; // (btRushBoom * -1.0);
   // Set econBias as a percentage boost or penalty for resources and settlers
   econBias = (econBias / 4.0) + 1.0;  // +/- up to 25%
   
   int bestCard = -1;
   float bestUnitScore = -1.0;
   int unitType = -1;               // The current unit's ID
   int unitCount = -1;              // How many unit types are available?
   int qtyAvail = -1;               // How many of each are available
   int age = -1;                    // What age do you need to use this card.
   int ownTPList = kbVPSiteQuery(cVPNative, cMyID, cVPStateCompleted);  
   int alliedTPList = kbVPSiteQuery(cVPNative, cPlayerRelationAlly, cVPStateCompleted);
   int numTeamTPs = xsArrayGetSize(ownTPList) + xsArrayGetSize(alliedTPList);
   float totalValue = -1.0;         // What is this bucket worth to me?
   bool isMilitaryUnit = false;
   
   
   int totalCards = aiHCDeckGetNumberCards(gDefaultDeck);
   aiEcho("**** Picking HC card to play");
   for (i=0; < totalCards)
   {
      //-- Skip card if we can't play it.
      if(aiHCDeckCanPlayCard(i) == false)
	continue;

      unitType = aiHCDeckGetCardUnitType(gDefaultDeck, i);  // What is this unit?
      qtyAvail = aiHCDeckGetCardUnitCount(gDefaultDeck, i);
      age = aiHCDeckGetCardAgePrereq(gDefaultDeck, i);
      totalValue = 0.0;
      
      // Calculate a value for this unit.  If not found, use its aiCost.
      switch(unitType)
      {
         case cUnitTypeSettler:   // European settlers
         {
            totalValue = 405 * qtyAvail;      // Normal default
            totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
               totalValue = 0.0;
            break;
         }
         case cUnitTypeCoureur:   // French coureurs
         {
            totalValue = 470 * qtyAvail;      // Normal default
            totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
               totalValue = 0.0;
            break;
         }
         case cUnitTypeSettlerWagon:   // German settler wagons
         {
            totalValue = 490 * qtyAvail;      // Normal default
            totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
               totalValue = 0.0;
            break;
         }
         case cUnitTypeSettlerNative:   // Native villagers
         {
            totalValue = 405 * qtyAvail;      // Normal default
            totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
               totalValue = 0.0;
            break;
         }
         case cUnitTypeypSettlerAsian:   // Chinese settlers
         {
            totalValue = 405 * qtyAvail;      // Normal default
            totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
               totalValue = 0.0;
            break;
         }
         case cUnitTypeypSettlerJapanese:   // Japanese settlers
         {
            totalValue = 405 * qtyAvail;      // Normal default
            totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
               totalValue = 0.0;
            break;
         }
         case cUnitTypeAbstractWarShip:
         {
            if (gNavyMap == true) 
              totalValue = 1000.0 * qtyAvail; 
            else 
              totalValue = 0.0;          
            break;
         }
         case gFishingUnit:
         {
            totalValue = 405 * qtyAvail;  
            break;                
         }
         case gCoveredWagonUnit:
         {                                 
            int tcTarget = 1;
            if (kbGetAge() >= cAge3)
            {
               tcTarget = 3;
               if (cMyCiv == cCivPortuguese)
                 tcTarget = kbGetBuildLimit(cMyID, cUnitTypeTownCenter); 
            }
            //if ( (gInitialStrategy >= 2) && (kbGetAge() < cAge4) )
               //totalValue = 0.0;
            if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) < tcTarget)
               totalValue = 4000.0;         
            break;
         }
         case gTowerWagonUnit:
         {
            totalValue = 0.0;    
            if ( (kbUnitCount(cMyID, gTowerWagonUnit, cUnitStateABQ) + kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive)) < gNumTowers)
               totalValue = 1300.0 * qtyAvail;
            if (homeBaseUnderAttack == true)
               totalValue = 0.0;
            break;
         }         
         case cUnitTypeFortWagon:
         {
            if ( (aiTreatyActive() == true) || ((cvOkToBuild == false) && (cvOkToBuildForts == false) && (homeBaseUnderAttack == false)) )
               totalValue = 0.0;
            if ( (gInitialStrategy != 1) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) < 45) )
               totalValue = 0.0;
            else
               totalValue = 3400.0;   // Big, but smaller than TC wagon if there is no TC.
            break;
         }
         case cUnitTypeFactoryWagon:
         {
            totalValue = 0.0;
            if ( (cvOkToBuild == true) && (homeBaseUnderAttack == false) )
               totalValue = 3500.0 * qtyAvail;   // Big, but smaller than TC wagon if there is no TC.
            break;
         }
         case cUnitTypeYPDojoWagon:
         {
            totalValue = 0.0;
            if ( (cvOkToBuild == true) && (homeBaseUnderAttack == false) )
               totalValue = 1290.0;   // Big, but smaller than TC wagon.
            break;
         }
         case cUnitTypeYPRicePaddyWagon:
         {
            totalValue = 0.0;
            if ( (cvOkToBuild == true) && ((gTimeToFarm == true) || (gTimeForPlantations == true)) )
               totalValue = 2500.0;   // Big, but smaller than TC wagon.
            break;
         }
         case cUnitTypeBankWagon:
         {
            totalValue = 0.0;    
            if ( (cvOkToBuild == true) && (homeBaseUnderAttack == false) )
               totalValue = 2000.0 * qtyAvail;
            break;
         }
         case cUnitTypeYPGroveWagon:
         {
            totalValue = 0.0;    
            if ( (cvOkToBuild == true) && (homeBaseUnderAttack == false) )
               totalValue = 1500.0 * qtyAvail;
            break;
         }
         case cUnitTypeypShrineWagon:
         {
            totalValue = 0.0;    
            if ( (cvOkToBuild == true) && (homeBaseUnderAttack == false) )
               totalValue = 2500.0 * qtyAvail;
            break;
         }
         case cUnitTypeCrateofCoin:
         {                                                          
            if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
	    {
		if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipCoinCrates3") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPShipMixedCrates2") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCoinCratesAztec2") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCoinCratesAztec3") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "ypHCShipCoinCrates2") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipCoinCrates3German"))
		{
		   if ((gInitialStrategy == 0) || (gInitialStrategy >= 2))
		   { 
		       qtyAvail = 30;
		       totalValue = 7500.0;
		   }
		   else
		   { 
                       qtyAvail = 15;
		       totalValue = 2000.0;
		   }
		}
	        if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipCoinCrates2") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipCoinCrates2German") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCoinCratesAztec2") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCoinCratesAztec3") ||           
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipCoinCrates2Indians"))
		{
                   qtyAvail = 25;
		   totalValue = 3100.0; 
		}		
	    }
            else if (age == cAge3)
	    {
                if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipCoinCrates4") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipCoinCrates4German") ||
		    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipCoinCrates4Indians") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipCoinCrates4Indians") ||
                    (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCoinCratesAztec4") ||
	            (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "ypHCShipCoinCrates4")) 
                {
		   if (gInitialStrategy >= 2)
                   {
                      qtyAvail = 23;
                      totalValue = 8500.0;
                   }
                   else
                   {
                      qtyAvail = 12;
		      totalValue = 3000.0;
		   }
		}
		if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipCoinCrates3Indians")
                   qtyAvail = 22;	 		
	    }
            else if (age > cAge3)
	    {
                qtyAvail = 18;
		//totalValue = 0.0;
	    }
            totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);  
            if (kbGetAge() == cAge1)
               totalValue = totalValue / 2.0;            
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            break;
            break;
         }
         case cUnitTypeCrateofCoinLarge:
         {              
            if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
               qtyAvail = 6;
            else if (age == cAge3)
               qtyAvail = 20;
            else if (age > cAge3)
               qtyAvail = 18;
            totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);  
            if (kbGetAge() == cAge1)
               totalValue = totalValue / 2.0;
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better               
            break;
         }
         case cUnitTypeCrateofFood:
         {
            if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
            {
	       if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipFoodCrates3") ||
                   (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipFoodCrates3Indians") ||
                   (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipFoodCrates3German"))
                 qtyAvail = 12;
	       if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipFoodCrates2") ||
                   (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipFoodCrates2Indians") ||
                   (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipFoodCrates2German"))
                 qtyAvail = 11;
            }
            else if (age == cAge3)
               qtyAvail = 11;
            else if (age > cAge3)
               qtyAvail = 15;
            totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
            if (kbGetAge() == cAge1)   // Increase value for rusher, decrease it for boomer
               totalValue = totalValue / econBias;
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            break;
         }
         case cUnitTypeCrateofFoodLarge:
         {
            if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.            
               qtyAvail = 10;            
            else if (age == cAge3)
               qtyAvail = 15;
            else if (age > cAge3)
               qtyAvail = 18;
            totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
            if (kbGetAge() == cAge1)   // Increase value for rusher, decrease it for boomer
               totalValue = totalValue / econBias;
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            break;
         }
         case cUnitTypeCrateofWood:
         {
            if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
	    {
	       if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipWoodCrates3") ||
                   (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipWoodCrates3German") ||
                   (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipWoodCrates2Indians") ||
                  ((kbGetCiv() == cCivJapanese) && (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "ypHCShipWoodCrates2")))
                 qtyAvail = 12;
	       else if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipWoodCrates2") ||
                        (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipWoodCrates2German"))
                 qtyAvail = 11;
	    }             
            else if (age == cAge3)
	    {
                if ((kbGetCiv() == cCivJapanese) && (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "ypHCShipWoodCrates4"))
                   qtyAvail = 21;
                if ((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipWoodCrates3Indians")) 
                   qtyAvail = 21;
                if ((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipWoodCrates4Indians")) 
                   qtyAvail = 22;
            }
            else if (age > cAge3)
            {
                if ((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipWoodCrates5Indians")) 
                   qtyAvail = 15;
                else if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipWoodCrates5")
                   qtyAvail = 22;
            }     
            totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
            if (kbGetAge() == cAge1)
               totalValue = totalValue / 2.0;            
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            break;
         }
         case cUnitTypeCrateofWoodLarge:
         {
            if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
               qtyAvail = 9;
            else if (age == cAge3)
               qtyAvail = 10;
            else if (age > cAge3)
               qtyAvail = 15;           
            totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
            if (kbGetAge() == cAge1)
               totalValue = totalValue / 2.0;           
            if (homeBaseUnderAttack == true)
               totalValue = 1.0; // Tiny...ANYTHING else is better
            break;
         }
         case cUnitTypeCow:
         {
            totalValue = 50.0 * qtyAvail;
            if (homeBaseUnderAttack == true)
               totalValue = 1.0;
            break;
         }
         case cUnitTypeSheep:
         {
            totalValue = 20.0 * qtyAvail;
            if (homeBaseUnderAttack == true)
               totalValue = 1.0;
            break;
         }        
         default:
         { 
            totalValue = kbGetProtoUnitAICost(unitType) * qtyAvail;

            switch(kbGetCiv())
            { 
                case cCivXPIroquois:
                {
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSawmills"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0; 
                      else 
                        totalValue = qtyAvail * 92.0 * kbGetAICostWeight(cResourceWood);
                   }

                   // Handle food economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFurrierTeam")
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 17;
                      else if (age == cAge3)
                         qtyAvail = 8;
                      else if (age > cAge3)
                         qtyAvail = 5;  
 
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0; 
                      else
                        totalValue = qtyAvail * 92.0 * kbGetAICostWeight(cResourceFood);
                   }

                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFoodSilosTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 92.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0; 
                   }

                   // Handle gold economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRumDistillery")
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true)
                        totalValue = qtyAvail * 95.0 * kbGetAICostWeight(cResourceGold); 
                      else
                        totalValue = 900.0; 
                   }
                   // Handle 'New Ways' (Iroquois)
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPNewWaysIroquois")
                   {
                      if (kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive) >= 10)
                        totalValue = 2505.0;
                      else
                        totalValue = 905.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPGreatHouse")
                   {
                      if (agingUpToOrAbove(cAge3) == true)
                         totalValue = 2600.0;
                      else
                         totalValue = 900.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPWarChiefIroquois1") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPWarChiefIroquois2"))
                   {  
                      totalValue = 2080.0;  
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) )
                        totalValue = 3900.0;
                      else
                        totalValue = 0.0; 
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCMedicine") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPMedicineTeam"))
                   {
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0;
                      else
                        totalValue = 2350.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCEngineeringSchool")
                   {
                      if (kbUnitCount(cMyID, gArtilleryDepotUnit, cUnitStateAlive) > 1) 
                        totalValue = 2310.0; 
                      else 
                        totalValue = 900.0;                 
                   }
                   // Handle Native military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeWarriors") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeChampionsDutchTeam"))
                   {                      
                      if (numTeamTPs >= 2)
                        totalValue = 2340.0;
                      else
                        continue;                   
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPInfantryDamageIroquois") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPInfantryLOSTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPInfantryHitpointsIroquois"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) > 10)
                        totalValue = 2302.0; 
                      else 
                        totalValue = 900.0;
                   }                       
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCavalryDamageIroquois") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCavalryHitpointsIroquois"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                        totalValue = 2302.0; 
                      else 
                        totalValue = 900.0;
                   }                     
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPInfantryCombatIroquois")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 10)
                        totalValue = 2312.0; 
                      else 
                        totalValue = 910.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPSiegeCombat") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPSiegeDamage") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPSiegeHitpoints"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) > 5)
                        totalValue = 2303.0; 
                      else 
                        totalValue = 905.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPSiegeDiscipline")
                   {                                    
                      totalValue = 2352.0;
                   }                                
                   break;
                }
                case cCivXPSioux:
                {
                   // Handle wood economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods")                      
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
                   }
                   // Handle food economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFoodSilos")
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) ) 
                        totalValue = 2900.0;
                      else
                        totalValue = 0.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPEarthBounty")
                   {  
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0;
                      else
                        totalValue = 2050.0;
                   }                   
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPWarChiefSioux1")
                   {
                      totalValue = 1050.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRidingSchool")
                   {
                      if (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) > 1)
                         totalValue = 1405.0;
                      else
                         totalValue = 905.0;
                   }
                   // Handle 'New Ways' (Sioux)
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPNewWaysSioux")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeTeepee, cUnitStateAlive) > 8)
                         totalValue = 1505.0; 
                      else
                         totalValue = 950.0; 
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPMustangs")                       
                   {
                      if (homeBaseUnderAttack == true) 
                        totalValue = 1.0; 
                      else 
                        totalValue = 1510;                
                   }
                   // Handle navy cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality")
                   {
                      if (gNavyMode == cNavyModeActive)
                        totalValue = 1505.0; 
                      else 
                        totalValue = 900.0;
                   }
                   // Handle Native military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeWarriors") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeChampionsDutchTeam"))
                   {                      
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0;
                      else
                        continue;                   
                   }
                   // Handle military cards 
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPWindRunner")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 20)
                        totalValue = 1302.0; 
                      else 
                        totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCavalryCombatSioux")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) >= 10)
                        totalValue = 1352.0; 
                      else 
                        totalValue = 905.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCavalryDamageSioux") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCavalryHitpointsSioux"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                        totalValue = 1302.0; 
                      else 
                        totalValue = 900.0;
                   }
                   break;
                }
                case cCivXPAztec:
                {
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPExoticHardwoodsTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSawmills"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0; 
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
                   }

                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFoodSilos") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPChinampa1") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPChinampa2") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCGrainMarket"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0;
                   }

                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPWarChiefAztec1") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPWarChiefAztec2"))
                   {
                      totalValue = 1020.0;                      
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) ) 
                        totalValue = 2900.0;
                      else
                        totalValue = 0.0; 
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCMedicine") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPMedicineTeam"))
                   {                          
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0;  
                      else
                        totalValue = 1250.0;  
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPStoneTowers")
                   {                          
                      if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) >= 3)
                        totalValue = 1300.0;
                      else
                        totalValue = 1000.0;
                   }
                   // Handle Native military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeWarriors") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeChampionsDutchTeam"))
                   {                     
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0;
                      else
                        continue;            
                   }
                   // Handle navy cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality")
                   {
                      if (gNavyMode == cNavyModeActive)
                        totalValue = 1505.0; 
                      else 
                        totalValue = 900.0;
                   }

                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFencingSchool") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPWarHutTraining"))
                   {
                      if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) >= 3)
                        totalValue = 1500.0; 
                      else 
                        totalValue = 900.0; 
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPGreatTempleTezcatlipoca")
                   {   
                      totalValue = 10005.0;
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCoyoteCombat")
                   {
                      if (kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) > 10)
                        totalValue = 1302.0; 
                      else 
                        totalValue = 900.0;
                   } 
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPScorchedEarth")
                   {
                      if (kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypexpJaguarKnight, cUnitStateAlive) > 15)
                        totalValue = 1302.0; 
                      else 
                        totalValue = 900.0;
                   }    
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPRuthlessness")
                   {
                      if (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) > 15)
                        totalValue = 1302.0; 
                      else 
                        totalValue = 900.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPKnightHitpoints") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPKnightDamage"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypexpJaguarKnight, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypexpSkullKnight, cUnitStateAlive) > 15)
                        totalValue = 1302.0; 
                      else 
                        totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPKnightCombat")
                   {
                      if (kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypexpJaguarKnight, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypexpSkullKnight, cUnitStateAlive) > 15)
                        totalValue = 1352.0; 
                      else 
                        totalValue = 900.0;
                   }
                   break;
                }
                case cCivChinese:
                {
                   // Handle wood economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods")
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
                   }

                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRefrigeration") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFoodSilos"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0;
                   }
                   
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalMint") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCTextileMills") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCigarRoller"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAdvancedConsulate")
                      totalValue = 2505.0;
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCSmoothRelations")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1)
                        totalValue = 900.0; 
                      else 
                        totalValue = 6505.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCSpawnRefugees1") || 
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCSpawnRefugees2") || 
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCSpawnMigrants1"))
                   {
		      if ((kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) + kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) >= 2 + 3 * kbGetAge()))
                        totalValue = 450 * (kbGetAge() + 1);
                      else
                        totalValue = 0.0;     
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCVillagemasons")
                       totalValue = 1100.0;
                   if ( (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab") ||
                        (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAdvancedRicePaddy") )
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) ) 
                        totalValue = 2100.0;
                      else
                        totalValue = 0.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCCheapWarAcademyTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCRainbowTrickle") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCConfusciousGift"))
                   {
                      if (homeBaseUnderAttack == true)
                       totalValue = 1.0; 
                      else 
                       totalValue = 2000.0;
                   }
                   // Handle navy cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality")
                   {
                      if (gNavyMode == cNavyModeActive)
                        totalValue = 1505.0;
                      else 
                        totalValue = 900.0;
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCBannerSchool") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAccupuncture"))
                   {
                      if (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) >= 3)
                        totalValue = 1450.0;
                      else 
                        totalValue = 950.0;                     
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCEngineeringSchoolTeam")
                   {
                      if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) > 2)
                        totalValue = 2450.0; 
                      else 
                        totalValue = 950.0;                   
                   }
                   // Handle Native military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCNativeLearning") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCNativeDamage"))
                   {                     
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0;
                      else
                        continue;                   
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCStandardArmyHitpoints")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypSteppeRider, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) > 15)
                        totalValue = 1302.0; 
                      else 
                        totalValue = 900.0;
                   }
		   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCOldHanArmyReforms")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 20)
                        totalValue = 1802.0; 
                      else 
                        totalValue = 940.0;
                   }
		   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCHanAntiCavalryBonus")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypArquebusier, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) > 15)
                        totalValue = 1312.0; 
                      else 
                        totalValue = 900.0;
                   }
		   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCTerritorialArmyCombat")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypArquebusier, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypChangdao, cUnitStateAlive) > 15)
                        totalValue = 1302.0; 
                      else 
                        totalValue = 900.0;
                   }
		   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCMongolianScourge")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypKeshik, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypeypSteppeRider, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypeypIronFlail, cUnitStateAlive) >= 25)
                        totalValue = 1312.0; 
                      else 
                        totalValue = 902.0;
                   }
		   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCForbiddenArmyArmor")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypIronFlail, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypMeteorHammer, cUnitStateAlive) > 15)
                        totalValue = 1802.0; 
                      else 
                        totalValue = 940.0;
                   }
		   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCArtilleryCombatChinese") ||
		       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCArtilleryDamageChinese") ||
		       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCArtilleryHitpointsChinese"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 10)
                        totalValue = 1300.0; 
                      else 
                        totalValue = 900.0;
                   }
		   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCManchuCombat")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypChangdao, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypeypKeshik, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypeypMeteorHammer, cUnitStateAlive) > 25)
                        totalValue = 1302.0; 
                      else 
                        totalValue = 900.0;
                   }
		   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCWesternReforms")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive) > 10)
                        totalValue = 1900.0; 
                      else 
                        totalValue = 905.0;
                   }
                   break;
                }
                case cCivJapanese:
                {
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "ypHCSawmills"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood); 
                   }
                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRefrigeration") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFoodSilos"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0;
                   }                  
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalMint") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCTextileMills") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCigarRoller") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRumDistillery"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCIncreasedTribute")
                   {
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0;  
                      else
                        totalValue = 10000.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShrineLearning")
                   {
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0;  
                      else
                        totalValue = 1400.0; 
                   }            
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCChonindoTeam")
                   {                     
                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = 1005.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAdvancedConsulate")
                      totalValue = 2505.0;
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCSmoothRelations")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1)
                        totalValue = 900.0; 
                      else 
                        totalValue = 3505.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAdvancedRicePaddy")
                   {
                      if ((gTimeToFarm == true) || (gTimeForPlantations == true))
                        totalValue = 2300.0;  
                      else
                        totalValue = 905.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCPioneersTeam")
                   {
                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = 1050.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCVillagemasons")
                       totalValue = 1100.0;
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCStoneCastles")
                   {
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0; 
                      if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) > 2)
                        totalValue = 1200.0; 
                   }
                   // Handle Daimyo cards
                   if ( (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipDaimyoSatsuma") ||
                        (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipDaimyoAizu") ||
                        (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipShogunate") )
                   {
                      totalValue = 2000.0;
                   }
                   if ( (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCBakufu") ||
                        (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCNobleCombat") )
                   {
                      totalValue = 2100.0;
                   }
                   // Handle navy cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality")
                   {
                      if (gNavyMode == cNavyModeActive)
                        totalValue = 1505.0;
                      else 
                        totalValue = 800.0; 
                   }
                   // Handle Native military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCNativeLearning") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCNativeIncorporation"))
                   {                     
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0;
                      else
                        continue;                 
                   }
                   // Handle team cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCCheapUnitUpgradesTeam")
                   {                    
                      if (kbGetAge() < cAge4)
                        totalValue = 0.0; 
                      else
                        totalValue = 2500.0;
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCYumiDamage") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCYumiRange"))
                   {
                       if (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) > 10)
                        totalValue = 1308.0;
                      else
                        totalValue = 900.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAshigaruDamage") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAshigaruAntiCavalryDamage"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) > 10)
                        totalValue = 1302.0;
                      else
                        totalValue = 900.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCSamuraiDamage") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCSamuraiSpeed"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypKensei, cUnitStateAlive) > 10)
                        totalValue = 1302.0;
                      else
                        totalValue = 900.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCNaginataHitpoints") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCNaginataAntiInfantryDamage"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypNaginataRider, cUnitStateAlive) > 10)
                        totalValue = 1312.0;
                      else
                        totalValue = 900.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCYabusameDamage") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCYabusameAntiArtilleryDamage"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypYabusame, cUnitStateAlive) > 10)
                        totalValue = 1312.0;
                      else
                        totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCArtilleryHitpointsJapanese")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 5)
                        totalValue = 1302.0;
                      else
                        totalValue = 900.0;
                   }
                   break;
                }
                case cCivIndians:
                {
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCExoticHardwoodsIndians") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCSawmillsIndians"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
                   }
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAgrarianism") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCForeignLogging"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = qtyAvail * 91.0 * kbGetAICostWeight(cResourceWood);
                   }
                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCSustainableAgricultureIndians") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCFoodSilosIndians"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0; 
                   }
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCRoyalMintIndians") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCRumDistilleryIndians"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAdvancedRicePaddyIndians")
                   {
                      if ((gTimeToFarm == true) || (gTimeForPlantations == true))
                        totalValue = 2300.0;  
                      else
                        totalValue = 905.0;  
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCGoraksha")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateABQ) < 1)
                        totalValue = 0.0;  
                      else
                        totalValue = 10000.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCTheRaj")
                   {
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0; 
                      else
                        totalValue = 2050.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAdvancedConsulateIndians")
                      totalValue = 2505.0;
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCSmoothRelationsIndians")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1)
                        totalValue = 1900.0; 
                      else 
                        totalValue = 3505.0;
                   }                   
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCVillagemasonsIndians")
                       totalValue = 1100.0;
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPMedicineTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCImprovedBuildingsTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCRainbowTrickleTeam"))
                   {
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0;
                      else
                        totalValue = 1005.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCGrazing") 
                   {                                            
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0;
                      else
                        totalValue = 1500.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCFencingSchoolIndians")
                   {
                      if (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) >= 2)
                        totalValue = 1440.0;
                      else 
                        totalValue = 910.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCRidingSchoolIndians")
                   {
                      if (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) >= 2)
                        totalValue = 1405.0; 
                      else 
                        totalValue = 905.0; 
                   }                   
                   // Handle navy cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAdmiralityIndians")
                   {
                      if (gNavyMode == cNavyModeActive)
                        totalValue = 1405.0; 
                      else 
                        totalValue = 900.0; 
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCElephantTrampling") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCElephantCombatIndians") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCElephantLimit"))
                   {
                      if (homeBaseUnderAttack == true) 
                        totalValue = 1.0;
                      else 
                        totalValue = 1345.0;                
                   }
                   // Handle Native military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCNativeLearningIndians") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCNativeIncorporationIndians"))
                   {                     
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0;
                      else
                        continue;                  
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCMeleeDamageIndians") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCInfantrySpeedHitpointsTeam"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive) > 8)
                        totalValue = 1348.0;
                      else
                        totalValue = 950.0;
                   }                        
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCCamelDamageIndians") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCCamelFrightening"))
                   {
                       if (kbUnitCount(cMyID, cUnitTypeAbstractSowar, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeAbstractZamburak, cUnitStateAlive) > 10)
                         totalValue = 1302.0; 
                       else 
                         totalValue = 900.0;
                   }

                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCGurkhaAid") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCEastIndiaCompany"))                      
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractSepoy , cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeAbstractGurkha, cUnitStateAlive) > 10)
                        totalValue = 1302.0; 
                      else 
                        totalValue = 900.0;       
                   }
                   break;
                }
                case cCivBritish:
                { 
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPDistributivism") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSawmills"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 9; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
                   }
                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRefrigeration") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0;
                   }
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalMint") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRumDistilleryTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCigarRoller") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCTextileMills"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0;
                   }                    
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFatterSheepTeam")
                   {
                      if ( (gJapaneseIsAlly == true) || (gIndianIsAlly == true) )
                        totalValue = 2500.0;
                      else 
                        totalValue = 900.0;              
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFastHousesTeam")
                   {
                      if (homeBaseUnderAttack == true) 
                        totalValue = 1.0; 
                      else 
                        totalValue = 2000.0;                   
                   }                
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHouseEstates")
                   {
                      if (homeBaseUnderAttack == true) 
                        totalValue = 1.0;                                
                      else
                        totalValue = 2300.0; 
                   }
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) ) 
                        totalValue = 2900.0;  
                      else
                        totalValue = 0.0;                  
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExtensiveFortifications")
                   {                     
                      if (aiGetGameMode() == cGameModeDeathmatch)
                        totalValue = 1550.0; 
                      else
                        totalValue = 1350.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPFlorenceNightingale")
                   {                     
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0; 
                      else
                        totalValue = 1000.0; 
                   }
                   // Handle 'Advanced Hot Air Balloon'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPAdvancedBalloon")
                   {
                      if ((homeBaseUnderAttack == true) || (cvOkToExplore == false))
                        totalValue = 1.0;  
                      else
                        totalValue = 1500.0;  
                   }
                   // Handle navy cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality")
                   {
                      if (gNavyMode == cNavyModeActive)
                        totalValue = 1505.0;
                      else 
                        totalValue = 800.0;
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFencingSchool")
                   {
                      if (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) > 2) 
                        totalValue = 1450.0;
                      else 
                        totalValue = 900.0;               
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRidingSchool")
                   {
                      if (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) > 1) 
                        totalValue = 1450.0;
                      else 
                        totalValue = 900.0;               
                   }                
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCImprovedLongbows")
                   {  
                      if (kbGetAge() < cAge3)
                        totalValue = 1.0;
                      else
                        totalValue = 2535.0;
                   }
                   // Handle Native military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeWarriors")
                   {
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0;
                      else
                        continue;
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCMusketeerGrenadierDamageBritish") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCMusketeerGrenadierCombatBritish") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCMusketeerGrenadierHitpointsBritishTeam"))
                   {
                       if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) > 10)
                         totalValue = 1302.0; 
                       else 
                         totalValue = 900.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCavalryHitpointsBritish") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCavalryDamageBritish") ||                      
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCavalryCombatBritish"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                         totalValue = 1312.0; 
                       else 
                         totalValue = 900.0;                   
                   }
                   break;
                }
                case cCivFrench:
                {
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPEconomicTheory")
                   {
                      if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 50)
                        totalValue = 2000.0; 
                      else 
                        totalValue = 780.0; 
                   }
                   // Handle wood economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPDistributivism")
                   {
                      if (age <= cAge2) 
                         qtyAvail = 9;
                      else if (age == cAge3)
                         qtyAvail = 17;
                      else if (age > cAge3)
                         qtyAvail = 20; 

                      totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood); 
                   }
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSawmillsTeam"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
                   }
                   // Handle food economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPColbertism")
                   {                                            
                      if (age <= cAge2) 
                         qtyAvail = 9;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 20;  
 
                      totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                   }
                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRefrigeration") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFoodSilos"))
                   {                                            
                      if (age == cAge2)
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0;
                   }
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalMint") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCTextileMills") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCigarRoller") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRumDistillery"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0;
                   }                   
                   // French coureurs, Boomers prefer this
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCShipCoureurs4")
                      totalValue = 5000.0;

                   // Don't use earlier than 40 minutes into the game
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPFurTrade")
                   {  
                      if (xsGetTime() < 60*1000*40)
                        totalValue = 1.0; 
                      else 
                        totalValue = 10000.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) ) 
                        totalValue = 2900.0;
                      else
                        totalValue = 0.0;              
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExtensiveFortifications")
                   {
                      if (aiGetGameMode() == cGameModeDeathmatch)
                        totalValue = 1550.0; 
                      else
                        totalValue = 1350.0; 
                   }
                   // Handle 'Advanced Hot Air Balloon'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPAdvancedBalloon")
                   {
                      if ((homeBaseUnderAttack == true) || (cvOkToExplore == false))
                        totalValue = 1.0;  
                      else
                        totalValue = 1500.0; 
                   }
                   // Handle navy cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality")
                   {
                      if (gNavyMode == cNavyModeActive)
                        totalValue = 1505.0; 
                      else 
                        totalValue = 800.0; 
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFencingSchool") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCEarlySkirmishersTeam"))
                   {
                      if (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) > 2) 
                        totalValue = 1450.0; 
                      else 
                        totalValue = 950.0;              
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRidingSchool")
                   {
                      if (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) > 1) 
                        totalValue = 1450.0;
                      else 
                        totalValue = 950.0;               
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCEngineeringSchool")
                   {
                      if (kbUnitCount(cMyID, gArtilleryDepotUnit, cUnitStateAlive) > 1) 
                        totalValue = 1300.0;
                      else 
                        totalValue = 900;                 
                   }
                   // Handle 'Royal Decree'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeFrench")
                   {
                      if ((homeBaseUnderAttack == true) || (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1) || (kbGetAge() < cAge3))
                        totalValue = 1.0;  
                      else
                        totalValue = 1510.0;  
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPThoroughbreds")
                   {
                      if ( (homeBaseUnderAttack == true) || (kbGetAge() <= cAge3) ) 
                        totalValue = 1.0;
                      else 
                        totalValue = 1510;                  
                   }
                   // Handle Native military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeCombatTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeWarriors") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeCombat"))
                   {
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0;  
                      else
                        continue;  
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCavalryCombatFrench")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                         totalValue = 1352.0;
                      else
                         totalValue = 902.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandCavalryHitpointsFrench") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandCavalryDamageFrenchTeam"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCWildernessWarfare") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRangedInfantryDamageFrenchTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRangedInfantryHitpointsFrench") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCEarlySkirmishersTeam"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) > 10)
                         totalValue = 1322.0;
                      else
                         totalValue = 900.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeCombatTeam") ||                      
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCWildernessWarfare"))
                   {
                      if (kbGetAge() < cAge2) 
                        totalValue = 1.0; 
                      else 
                        totalValue = 1302.0;                   
                   }
                   break;
                }
                case cCivDutch:
                {   
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSawmills"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 18;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 10; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0; 
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);  
                   }
                   // Handle food economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPColbertism")
                   {                                            
                      if (age <= cAge2) 
                         qtyAvail = 9;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 20;  
 
                      totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                   }
                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRefrigeration") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFoodSilos"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0;
                   }
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalMint") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCTextileMills") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCigarRoller") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRumDistillery"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0;
                   }                   
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) )
                        totalValue = 2900.0;  
                      else
                        totalValue = 0.0;                   
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCDutchEastIndiaCompany")
                   {
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0;  
                      else
                        totalValue = 2000.0;  
                   }             
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCBanks1") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCBanks2"))
                   {
                      totalValue = 0.0; 
                      if (kbGetBuildLimit(cMyID, cUnitTypeBank) <= kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive))
                         totalValue = 1900.0;               
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCBetterBanks")
                   {               
                      if (age < cAge3)                  
                        totalValue = 1.0;
                      else
                        totalValue = 1600.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdvancedArsenal")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateABQ) < 1)
                        totalValue = 500.0; 
                      else
                        totalValue = 1300.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExplorerDutch")
                   {
                      if (agingUpToOrAbove(cAge3) == true)
                         totalValue = 2300.0;
                      else
                         totalValue = 900.0;
                   }
                   // Handle 'Advanced Hot Air Balloon'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPAdvancedBalloon")
                   {
                      if ((homeBaseUnderAttack == true) || (cvOkToExplore == false))
                        totalValue = 1.0;  
                      else
                        totalValue = 1500.0;  
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFencingSchool")
                   {
                      if (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) > 2) 
                        totalValue = 1450.0; 
                      else 
                        totalValue = 950.0;                   
                   }               
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRidingSchool")
                   {
                      if (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) > 1) 
                        totalValue = 1450.0;
                      else 
                        totalValue = 940.0;                  
                   }
                   // Handle 'Royal Decree'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeDutch")
                   {
                      if ((homeBaseUnderAttack == true) || (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1) || (kbGetAge() < cAge2))
                        totalValue = 1.0;
                      else
                        totalValue = 1610.0;
                   }
                   // Handle navy cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality")
                   {
                      if (gNavyMode == cNavyModeActive)
                        totalValue = 1505.0;
                      else 
                        totalValue = 800.0;
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPDanceHall")
                   {
                      if (homeBaseUnderAttack == true) 
                        totalValue = 1.0; 
                      else 
                        totalValue = 1520.0;                  
                   }
                   // Handle Native military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeWarriors") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeChampionsDutchTeam"))
                   {
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0;
                      else
                        continue;
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCInfantryDamageDutch") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCInfantryHitpointsDutchTeam"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) > 10)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCInfantryCombatDutch")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 10)
                         totalValue = 1322.0;
                      else
                         totalValue = 910.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPMilitaryReforms")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 10)
                         totalValue = 1312.0;
                      else
                         totalValue = 912.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCavalryCombatDutch")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                         totalValue = 1302.0;
                      else
                         totalValue = 902.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCMortarsDamageDutchTeam")
                   {
                      if (kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive) >= 5)
                         totalValue = 1302.0;
                      else
                         totalValue = 902.0;
                   }
                   break;   
                }
                case cCivSpanish:
                {
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPEconomicTheory")
                   {
                      if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 50)
                        totalValue = 2000.0; 
                      else 
                        totalValue = 800.0;
                   }
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSawmills"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
                   }
                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRefrigeration") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0;
                   }
                   // Handle gold economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCapitalism")
                   { 
                      if (age <= cAge2) 
                         qtyAvail = 9;
                      else if (age == cAge3)
                         qtyAvail = 17;
                      else if (age > cAge3)
                         qtyAvail = 20;  
 
                      totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                   }
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalMint") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCTextileMills") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCigarRoller") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRumDistillery"))                       
                   { 
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0;
                   }                   
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) ) 
                        totalValue = 2900.0;
                      else
                        totalValue = 0.0;               
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExtensiveFortifications")
                   {                      
                      if (aiGetGameMode() == cGameModeDeathmatch)
                        totalValue = 1550.0; 
                      else
                        totalValue = 1350.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPUnction")
                   {
                      totalValue = 0.0;
                      if (aiGetGameMode() == cGameModeDeathmatch)
                        totalValue = 1500.0; 
                      else
                        totalValue = 1300.0; 
                   }                 
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExplorerSpanish") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExplorerCombatTeam"))
                   {
                      if (aiGetGameMode() == cGameModeDeathmatch)
                        totalValue = 10000.0; 
                      else
                        totalValue = 2300.0; 
                   }
                   // Handle 'Advanced Hot Air Balloon'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPAdvancedBalloon")
                   {
                      if ((homeBaseUnderAttack == true) || (cvOkToExplore == false))
                        totalValue = 1.0;
                      else
                        totalValue = 1500.0;
                   }
                   // Handle navy cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCArmada"))
                   {
                      if (gNavyMode == cNavyModeActive)
                        totalValue = 1505.0;
                      else 
                        totalValue = 800.0;
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFencingSchool")
                   {
                      if (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) > 1) 
                        totalValue = 1450.0; 
                      else 
                        totalValue = 950.0;               
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRidingSchool")
                   {
                      if (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) > 1) 
                        totalValue = 1450.0;
                      else 
                        totalValue = 940.0;                 
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCArchaicTrainingTeam")
                   {
                      if (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) > 1) 
                        totalValue = 1420.0;
                      else 
                        totalValue = 902.0;                  
                   }
                   // Handle Native military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeWarriors")
                   {
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0;
                      else
                        continue;
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandInfantryDamageSpanishTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandInfantryHitpointsSpanish"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) > 10)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandInfantryCombatSpanish")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) > 10)
                         totalValue = 1342.0;
                      else
                         totalValue = 910.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandCavalryHitpointsSpanish") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandCavalryDamageSpanish"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                         totalValue = 1342.0;
                      else
                         totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandCavalryCombatSpanish")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                         totalValue = 1340.0;
                      else
                         totalValue = 902.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCaballeros")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeLancer, cUnitStateAlive) >= 10)
                         totalValue = 1342.0;
                      else
                         totalValue = 912.0;               
                   }
                   break;
                }
                case cCivGermans:
                {
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPEconomicTheory")
                   {
                      if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive) > 50)                      
                        totalValue = 2000.0; 
                      else 
                        totalValue = 700.0;
                   }
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) ) 
                        totalValue = 2900.0;  
                      else
                        totalValue = 0.0;                   
                   }
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSawmills"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0; 
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood); 
                   }
                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRefrigerationGerman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgricultureGerman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFoodSilosTeam"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0; 
                   }
                   // Handle gold economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCapitalism")
                   {                                            
                      if (age <= cAge2) 
                         qtyAvail = 9;
                      else if (age == cAge3)
                         qtyAvail = 17;
                      else if (age > cAge3)
                         qtyAvail = 20;  
 
                      totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                   }
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalMintGerman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCTextileMillsGerman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCigarRollerGerman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRumDistilleryGerman"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0;
                   }                   
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCGuildArtisans")
                   {
                      if (age <= cAge3) 
                      {  totalValue = 1.0; }
                      else 
                      {  totalValue = 2000.0; }                  
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCGermantownFarmers") 
                   { 
                      totalValue = 0.0;
                      if (kbUnitCount(cMyID, cUnitTypeMill, cUnitStateAlive) > 0)
                         totalValue = 2500.0;
                   }                
                   // Handle 'Advanced Hot Air Balloon'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPAdvancedBalloon")
                   {
                      if ((homeBaseUnderAttack == true) || (cvOkToExplore == false))
                        totalValue = 1.0; 
                      else
                        totalValue = 1500.0; 
                   }
                   // Handle 'Royal Decree'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeGerman")
                   {
                      if ((homeBaseUnderAttack == true) || (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1) || (kbGetAge() < cAge3))
                        totalValue = 1.0;
                      else
                        totalValue = 6010.0; 
                   }                  
                   // Handle navy cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmiralityGerman")
                   {
                      if (gNavyMode == cNavyModeActive)
                        totalValue = 1505.0; 
                      else 
                        totalValue = 800.0; 
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFencingSchoolGerman")
                   {
                      if (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) >= 2) 
                        totalValue = 1450.0;
                      else 
                        totalValue = 950.0;                  
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRidingSchoolGerman")
                   {
                      if (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) > 1) 
                        totalValue = 1450.0;
                      else 
                        totalValue = 940.0;                 
                   }
                   // Handle Native military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeWarriorsGerman")
                   {
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0; 
                      else
                        continue;
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRangedInfantryHitpointsGerman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandInfantryDamageGerman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandInfantryHitpointsGerman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCHandInfantryCombatGerman"))
                   { 
                      if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) > 10)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCavalryHitpointsGerman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCavalryDamageGermanTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCavalryCombatGerman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCUhlanCombatGerman"))
                   { 
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   break;
                }
                case cCivRussians:
                {
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPEconomicTheory")
                   {
                      if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 50)
                        totalValue = 2000.0; 
                      else 
                        totalValue = 800.0; 
                   }
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) ) 
                        totalValue = 2900.0;  
                      else
                        totalValue = 0.0;              
                   }
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPDistributivism") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSawmills"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0; 
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
                   }
                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRefrigeration") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFoodSilos"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0;
                   }
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalMint") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCTextileMills") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCigarRoller") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRumDistillery"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0;
                   }                   
                   // Handle 'Advanced Hot Air Balloon'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPAdvancedBalloon")
                   {
                      if ((homeBaseUnderAttack == true) || (cvOkToExplore == false))
                        totalValue = 1.0;  
                      else
                        totalValue = 1500.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPNationalRedoubt")
                   {
                      if (age <= cAge3)
                        totalValue = 0.0;  
                      else
                        totalValue = 10000.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPSevastopol")
                   {
                      if (age == cAge2)
                        totalValue = 1500.0;  
                      else
                        totalValue = 1560.0;  
                   }
                   // Handle navy cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCColdWaterPortTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality"))
                   {
                      if (gNavyMode == cNavyModeActive)
                       totalValue = 1505.0; 
                      else 
                       totalValue = 800.0; 
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCDuelingSchoolTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFencingSchool"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateAlive) > 1) 
                        totalValue = 1450.0; 
                      else 
                        totalValue = 950.0;                  
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRidingSchool")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateAlive) > 1) 
                        totalValue = 1450.0;
                      else 
                        totalValue = 900.0;                
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCStreletsCombatRussian") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSpawnStrelet"))
                   {
                       if (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) > 20)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRansack")
                   {
                       if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) > 20)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCUnicorne")
                   {
                      if (kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive) >= 5)
                         totalValue = 1302.0;
                      else
                         totalValue = 902.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCUniqueCombatRussian")
                   {
                       if (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) +
                           kbUnitCount(cMyID, cUnitTypeCossack, cUnitStateAlive) +
                           kbUnitCount(cMyID, cUnitTypeOprichnik, cUnitStateAlive) > 20)
                         totalValue = 1352.0;
                      else
                         totalValue = 915.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCavalryCombatRussian")
                   { 
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   break;
                }
                case cCivPortuguese:
                {
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPEconomicTheory")
                   {
                      if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 50)
                        totalValue = 2000.0; 
                      else 
                        totalValue = 700.0; 
                   }
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) ) 
                        totalValue = 2900.0;  
                      else
                        totalValue = 0.0;                  
                   }
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSawmills"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0;
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
                   }
                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRefrigeration") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFishMarketTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeToFarm == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                      else
                        totalValue = 900.0;
                   }
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalMint") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCTextileMills") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCigarRoller") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRumDistillery"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0;
                   }                   
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCImprovedWallsTeam")
                   {
                      if (gBuildWalls == true)
                        totalValue = 5500.0; 
                      else
                        totalValue = 1000.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdvancedArsenal")
                   {
                      if (getUnit(cUnitTypeArsenal, cMyID, cUnitStateAlive) <= 0)
                        totalValue = 500.0; 
                      else
                        totalValue = 1300; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCDonatarios")
                   {
                      if (homeBaseUnderAttack == true) 
                        totalValue = 1.0;  
                      else
                        totalValue = 1000.0;  
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCMedicine")
                   {                         
                      if (homeBaseUnderAttack == true)
                        totalValue = 1.0;  
                      else
                        totalValue = 1750.0;  
                   }
                   // Handle navy cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNavigationSchool"))
                   {
                      if (gNavyMode == cNavyModeActive)
                       totalValue = 1505.0; 
                      else 
                       totalValue = 800.0; 
                   }
                   // Handle 'Advanced Hot Air Balloon'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPAdvancedBalloon")
                   {
                      if ((homeBaseUnderAttack == true) || (cvOkToExplore == false))
                        totalValue = 1.0;  
                      else
                        totalValue = 1500.0;  
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCFencingSchool")
                   {
                      if (kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) > 1) 
                        totalValue = 1450.0; 
                      else 
                        totalValue = 900.0;              
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRidingSchool")
                   {
                      if (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) > 1) 
                        totalValue = 1450.0; 
                      else 
                        totalValue = 950.0;                   
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCEngineeringSchool")
                   {
                      if ((kbUnitCount(cMyID, gArtilleryDepotUnit, cUnitStateABQ) < 1) || (kbGetAge() < cAge3)) 
                        totalValue = 1.0; 
                      else 
                        totalValue = 1310;                   
                   }
                   // Handle Native military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeWarriors")
                   {
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0;
                      else
                        continue;
                   }
                   // Handle military cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRangedInfantryHitpointsPortugueseTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRangedInfantryDamagePortuguese"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) > 10)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRangedInfantryCombatPortuguese")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) > 15)
                         totalValue = 1312.0;
                      else
                         totalValue = 910.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCDragoonCombatPortuguese")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) > 15)
                         totalValue = 1312.0;
                      else
                         totalValue = 910.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPGenitours")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) > 15)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPRangefinding")
                   {
                      if (kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive) >= 5)
                         totalValue = 1302.0;
                      else
                         totalValue = 902.0;
                   }
                   break;                
                }
                case cCivOttomans:
                {
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPEconomicTheory")
                   {
                      if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 50)
                        totalValue = 2000.0; 
                      else 
                        totalValue = 780.0;
                   }
                   // Handle economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPLandGrab")
                   {
                      if ( (gTimeToFarm == true) || (gTimeForPlantations == true) ) 
                        totalValue = 2900.0;  
                      else
                        totalValue = 0.0;                 
                   }
                   // Handle wood economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExoticHardwoods") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSawmills"))
                   {
                      if (age <= cAge2) 
                         qtyAvail = 15;
                      else if (age == cAge3)
                         qtyAvail = 10;
                      else if (age > cAge3)
                         qtyAvail = 8; 

                      if (homeBaseUnderAttack == true)  
                        totalValue = 1.0; 
                      else 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);
                   }
                   // Handle food economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRefrigeration") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSustainableAgriculture"))
                   {                                            
                      if (age == cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (getUnit(gFarmUnit, cMyID, cUnitStateAlive) <= 0) 
                        totalValue = 1.0;
                      else
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
                   }
                   // Handle gold economic cards
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalMint") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCigarRoller"))
                   {                                            
                      if (age <= cAge2) 
                         qtyAvail = 8;
                      else if (age == cAge3)
                         qtyAvail = 12;
                      else if (age > cAge3)
                         qtyAvail = 17;  
 
                      if (gTimeForPlantations == true) 
                        totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                      else
                        totalValue = 900.0;
                   }
                   // Handle gold economic cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPCapitalism")
                   {                                            
                      if (age <= cAge2) 
                         qtyAvail = 10;
                      else if (age == cAge3)
                         qtyAvail = 17;
                      else if (age > cAge3)
                         qtyAvail = 22;  
 
                      totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);
                   }                   
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCheapTradingPostTeam")
                   {
                      totalValue = 1500.0;
                   }
                   // Handle navy cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdmirality")
                   {
                      if (gNavyMode == cNavyModeActive)
                       totalValue = 1505.0; 
                      else 
                       totalValue = 800.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCExtensiveFortifications")
                   {                      
                      if (aiGetGameMode() == cGameModeDeathmatch)
                        totalValue = 1550.0; 
                      else
                        totalValue = 1350.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdvancedArsenal")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateABQ) < 1)
                        totalValue = 500.0; 
                      else
                        totalValue = 1300;
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRidingSchool")
                   {
                      if (kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) < 1) 
                        totalValue = 1.0;
                      else 
                        totalValue = 1450.0;                 
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCEngineeringSchool")
                   {
                      if ((kbUnitCount(cMyID, gArtilleryDepotUnit, cUnitStateABQ) < 1) || (kbGetAge() < cAge3)) 
                        totalValue = 1.0; 
                      else 
                        totalValue = 1320;                
                   }
                   // Handle 'Advanced Hot Air Balloon'
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPAdvancedBalloon")
                   {
                      if ((homeBaseUnderAttack == true) || (cvOkToExplore == false))
                        totalValue = 1.0;  
                      else
                        totalValue = 1500.0; 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCSilkRoadTeam")
                   {
                      if ((homeBaseUnderAttack == true) || (cvOkToExplore == false))
                        totalValue = 1.0;  
                      else
                        totalValue = 1349.0; 
                   }
                   // Handle Native military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCNativeWarriors")
                   {
                      if (numTeamTPs >= 2)
                        totalValue = 1350.0; 
                      else
                        continue;
                   }
                   // Handle military cards
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCJanissaryCombatOttoman")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) > 10)
                         totalValue = 1342.0;
                      else
                         totalValue = 912.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCJanissaryCost")
                   {
                      totalValue = 1550.0;
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCCavalryCombatOttoman")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                         totalValue = 1312.0;
                      else
                         totalValue = 910.0;                 
                   }
                   if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPIrregulars")
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 10)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;                 
                   }
                   if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCLightArtilleryHitpointsOttoman") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCArtilleryHitpointsOttomanTeam") ||
                       (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCArtilleryDamageOttoman"))
                   {
                      if (kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) +
                          kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) > 12)
                         totalValue = 1302.0;
                      else
                         totalValue = 900.0;
                   }
                   break;        
                }     
            }

            if ( (totalValue < 1.0) && (age >= cAge1) )
            {  // Set a min value based on age
               switch(age)
               {
                  case cAge1:
                  {
                     totalValue = 400.0;
                     break;
                  }
                  case cAge2:
                  {
                     totalValue = 800.0;
                     break;
                  }
                  case cAge3:
                  {
                     totalValue = 1600.0;
                     break;
                  }
                  case cAge4:
                  {
                     totalValue = 3200.0;
                     break;
                  }
                  case cAge5:
                  {
                     totalValue = 6400.0;
                     break;
                  }   
               }
            }           
            break;
         }
      }

      // Adjust scores for military units
      isMilitaryUnit = kbProtoUnitIsType(cMyID, unitType, cUnitTypeLogicalTypeLandMilitary);
      if ( (kbGetAge() < cAge3) && (isMilitaryUnit == true) )
         totalValue = totalValue / econBias;  // Adjust value up for pure rusher, down for pure boomer
      if ( (kbGetAge() < cAge2) && (isMilitaryUnit == true) )
         totalValue = 0.0; // No military units before age 2. /*
      if ( (gInitialStrategy == 0) && (isMilitaryUnit == true) && (kbGetAge() < cAge2) )
         totalValue = 0.0; // No military units before age 3.
      if ( (gInitialStrategy == 2) && (isMilitaryUnit == true) && (kbGetAge() < cAge2) )
         totalValue = 0.0; // No military units before age 3.
      if ( (gInitialStrategy == 3) && (isMilitaryUnit == true) && (kbGetAge() < cAge2) )
         totalValue = 0.0; // No military units before age 4. */
      if (unitType == kbUnitPickGetResult(gLandUnitPicker, 0))
         totalValue = totalValue * 1.5;   // It's what we're trying to train
     
      // Adjust score for mercenaries if not enough coin is available.
      if ( (age == cAge2) && (kbProtoUnitIsType(cMyID, unitType, cUnitTypeMercenary) == true) && (kbResourceGet(cResourceGold) < 500) )
         totalValue = 1.0;   // No Age 2 mercenaries if less than 500 coin is available.
      if ( (age == cAge3) && (kbProtoUnitIsType(cMyID, unitType, cUnitTypeMercenary) == true) && (kbResourceGet(cResourceGold) < 1500) )
         totalValue = 1.0;   // No Age 3 mercenaries if less than 1500 coin is available.
      if ( (age == cAge4) && (kbProtoUnitIsType(cMyID, unitType, cUnitTypeMercenary) == true) && (kbResourceGet(cResourceGold) < 2500) )
         totalValue = 1.0;   // No Age 4 mercenaries if less than 2500 coin is available.

      // Adjust score for arsonists (wrongly not classified as mercenaries) if not enough coin is available.
      if ( (age == cAge2) && (kbProtoUnitIsType(cMyID, unitType, cUnitTypeypMercArsonist) == true) && (kbResourceGet(cResourceGold) < 500) )
         totalValue = 1.0;   // No Age 2 mercenaries if less than 500 coin is available.
      if ( (age == cAge3) && (kbProtoUnitIsType(cMyID, unitType, cUnitTypeypMercArsonist) == true) && (kbResourceGet(cResourceGold) < 1500) )
         totalValue = 1.0;   // No Age 3 mercenaries if less than 1500 coin is available.
      if ( (age == cAge4) && (kbProtoUnitIsType(cMyID, unitType, cUnitTypeypMercArsonist) == true) && (kbResourceGet(cResourceGold) < 2500) )
         totalValue = 1.0;   // No Age 4 mercenaries if less than 2500 coin is available.

      aiEcho("    "+i+" "+kbGetProtoUnitName(unitType)+": "+qtyAvail+" total value: "+totalValue);
      if (totalValue > bestUnitScore)
      {
         bestUnitScore = totalValue;
         bestCard = i;
      }
   }

      if (bestCard >= 0)
      {
         if (aiHCDeckGetCardUnitCount(gDefaultDeck, bestCard) > 0)
         {  aiEcho("  Choosing card "+bestCard+", "+aiHCDeckGetCardUnitCount(gDefaultDeck, bestCard)+" "+kbGetUnitTypeName(aiHCDeckGetCardUnitType(gDefaultDeck, bestCard)));  }
         else
         {  aiEcho("  Choosing card "+bestCard+", "+kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, bestCard)));  }
	 
         //createSimpleTrainPlan(bestUnitType, 1, cRootEscrowID, -1, 1, true);
	 aiHCDeckPlayCard(bestCard);
      }
}


//==============================================================================
// extraShipMonitor
// Checks for shipments (not just for extra ones!) and calls appropriate handler
//==============================================================================
rule extraShipMonitor
inactive
group tcComplete
minInterval 20
{
   if (kbResourceGet(cResourceShips) > 0)
   {
      if (gRevolutionFlag == false)
      {
         shipGrantedHandler();   // normal shipment handler
      }
      else
      {
         revolutionaryShipmentHandler();  // post-revolution shipment handler
      }
   }
}

void getHCTech(string name="", int techID=-1, int pri=50)
{  // Make a simple plan to research a HC tech.
   int planID = aiPlanCreate(name, cPlanResearch);
   aiPlanSetVariableInt(planID, cResearchPlanTechID, 0, techID);
   aiPlanSetEscrowID(planID, cRootEscrowID);
   aiPlanSetDesiredPriority(planID, pri);
   aiPlanSetActive(planID);
}

//==============================================================================
// ShouldIResign
//==============================================================================
rule ShouldIResign
minInterval 35
active
{
   static bool hadHumanAlly = false;
   
   if (gSPC == true)
   {
      xsDisableSelf();
      return;
   }
   
   if (cvOkToResign == false)
   {
      return;     // Early out if we're not allowed to think about this.
   }
   
   // Don't resign if you have a human ally that's still in the game
   int i = 0;
   bool humanAlly = false;    // Set true if we have a surviving human ally.
   int humanAllyID = -1;
   bool complained = false;   // Set flag true if I've already whined to my ally.
   bool wasHumanInGame = false;  // Set true if any human players were in the game
   bool isHumanInGame = false;   // Set true if a human survives.  If one existed but none survive, resign.
   
   // Look for humans
   for (i=1; <=cNumberPlayers)
   {
      if ( kbIsPlayerHuman(i) == true)
      {
         wasHumanInGame = true;
         if ( kbHasPlayerLost(i) == false )
            isHumanInGame = true;
      }
      if ( (kbIsPlayerAlly(i) == true) && (kbHasPlayerLost(i) == false) && (kbIsPlayerHuman(i) == true) )
      {
         humanAlly = true; // Don't return just yet, let's see if we should chat.
         hadHumanAlly = true; // Set flag to indicate that we once had a human ally.
         humanAllyID = i;  // Player ID of lowest-numbered surviving human ally.
      }
   }
   
//   if ( (wasHumanInGame == true) && (isHumanInGame == false) )
   if ( (hadHumanAlly == true) && (humanAlly == false) ) // Resign if my human allies have quit.
   {
      //aiResign(); // If there are no humans left, and this wasn't a bot battle from the start, quit.
      aiEcho("Resigning because I had a human ally, and he's gone...");
      aiResign(); // I had a human ally or allies, but do not any more.  Our team loses.
      return;  // Probably not necessary, but whatever...
   }
   // Check for MP with human allies gone.  This trumps the OkToResign setting, below.
   if ( (aiIsMultiplayer() == true) && (hadHumanAlly == true) && (humanAlly == false) )   
   {  // In a multiplayer game...we had a human ally earlier, but none remain.  Resign immediately
      aiEcho("Resign because my human ally is no longer in the game.");
      aiResign();    // Don't ask, just quit.
      xsEnableRule("resignRetry");
      xsDisableSelf();
      return;
   }


   //Don't resign too soon.
   if (xsGetTime() < 600000)     // 600K = 10 min
     return;

   //Don't resign if we have over 5 active pop slots.
   if (kbGetPop() >= 5)
      return;

   //If we don't have any settlers and we cannot afford anymore, try to resign.
   int numSettlements=kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive);   
   int numBuilders=kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);   
   if ( (numBuilders < 5) && (numSettlements <= 0) && (aiGetFallenExplorerID() >= 0) )
   {
      if (kbCanAffordUnit(cUnitTypeTownCenter, cEconomyEscrowID) == false)
      {
         aiEcho("**** I give up...I can't find an aiStart unit, TC, wagon, explorer or settler.  How do you expect me to play?!");
         aiAttemptResign(cAICommPromptToEnemyMayIResign);
         xsEnableRule("resignRetry");
         xsDisableSelf();
         return;
      }
   }
}

rule resignRetry
inactive
minInterval 240
{
   xsEnableRule("ShouldIResign");
   xsDisableSelf();
}

//==============================================================================
// resignHandler
//==============================================================================
void resignHandler(int result =-1)
{
   aiEcho("***************** Resign handler running with result "+result);
   if (result == 0)
   {

      xsEnableRule("resignRetry");
      return;
   }
   aiEcho("Resign handler returned "+result);

   aiResign();
   return;
}

int createTechProgression(int techID = -1, int escrowID = -1, int pri = 50)
{
   int planID = -1;
   if ((techID < 0) || (escrowID < 0))
      return(-1);
   
   planID = aiPlanCreate("Tech Progression "+techID, cPlanProgression);
   if (planID < 0)
      return(-1);
   
   aiPlanSetVariableInt(planID, cProgressionPlanGoalTechID, 0, techID);
   aiPlanSetDesiredPriority(planID, pri);
   aiPlanSetEscrowID(planID, escrowID);
   aiPlanSetBaseID(planID, kbBaseGetMainID(cMyID));
   aiPlanSetActive(planID);
   
   return(planID);
}

rule bigTechManager
group tcComplete
inactive
minInterval 120
{
   if (civIsNative() == false)
   {
      xsDisableSelf();
      return;
   }
   if (xsGetTime() < 28*60*1000)
      return;  // Wait until 28 minutes
   
   if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) < 1)
      return;

   aiEcho(" ");
   aiEcho("#### Starting 'big tech' research plans. ####");
   aiEcho(" ");
   
   if (cMyCiv == cCivXPAztec)
   {
      createSimpleResearchPlan(cTechBigFarmCinteotl, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigFirepitFounder, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigPlantationTezcatlipoca, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigWarHutBarometz, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigNoblesHutWarSong, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigHouseCoatlicue, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigDockCipactli, -1, cMilitaryEscrowID, 80);
   }
   else if (cMyCiv == cCivXPIroquois)
   {
      createSimpleResearchPlan(cTechBigFarmStrawberry, -1, cEconomyEscrowID, 80);
      createSimpleResearchPlan(cTechBigPlantationMapleFestival, -1, cEconomyEscrowID, 80);
      createSimpleResearchPlan(cTechBigLonghouseWoodlandDwellers, -1, cEconomyEscrowID, 80);
      createSimpleResearchPlan(cTechBigWarHutLacrosse, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigSiegeshopSiegeDrill, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigCorralHorseSecrets, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigDockRawhideCovers, -1, cMilitaryEscrowID, 80);
   }
   else if (cMyCiv == cCivXPSioux)
   {
      createSimpleResearchPlan(cTechBigCorralBonepipeArmor, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigWarHutWarDrums, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigPlantationGunTrade, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigFarmHorsemanship, -1, cMilitaryEscrowID, 80);
      createSimpleResearchPlan(cTechBigDockFlamingArrows, -1, cMilitaryEscrowID, 80);
      //createSimpleResearchPlan(cTechBigFirepitBattleAnger, -1, cMilitaryEscrowID, 80);
   }
   
   xsDisableSelf();
}

rule firePitUpgradeMonitor
inactive
group tcComplete
minInterval 120
{

   int upgradePlanID = -1;

   if (civIsNative() == false)
   {
         xsDisableSelf();
         return;
   }

   // Disable rule once the upgrades are available

	if (((kbGetCiv() == cCivXPIroquois)&&(kbTechGetStatus(cTechBigFirepitSecretSociety) == cTechStatusActive))||
	   ((kbGetCiv() == cCivXPSioux)&&(kbTechGetStatus(cTechBigFirepitBattleAnger) == cTechStatusActive))||
       ((kbGetCiv() == cCivXPAztec)&&(kbTechGetStatus(cTechBigFirepitFounder) == cTechStatusActive)))
	{
		xsDisableSelf();
		return;
	}

	// Get upgrades one at a time
	if (kbGetCiv() == cCivXPIroquois)
	{
		if (((gInitialStrategy <= 1)&&(kbGetAge() >= cAge2))||
			((gInitialStrategy == 2)&&(kbGetAge() >= cAge2))||
			((gInitialStrategy == 0)&&(kbGetAge() >= cAge2))||
			((gInitialStrategy == 3)&&(kbGetAge() >= cAge2)))
		{
			if ((kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive) > gGoodArmyPop)&&(kbTechGetStatus(cTechBigFirepitSecretSociety) == cTechStatusObtainable))
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigFirepitSecretSociety);
				if (upgradePlanID >= 0)
					aiPlanDestroy(upgradePlanID);
				createSimpleResearchPlan(cTechBigFirepitSecretSociety, getUnit(cUnitTypeFirePit), cEconomyEscrowID, 50);
				return;
			}
		}
	}

	if (kbGetCiv() == cCivXPSioux)
	{
	    static bool enemyCivHasArttillery = false;
		static bool enemyCivConfirmed = false;
		int player = 0;
		if (enemyCivConfirmed == false)
		{
			for (player=1; < cNumberPlayers)
			{
				if ((kbIsPlayerEnemy(player) == true)&&(kbHasPlayerLost(player) == false))
				{
					if ((kbGetCivForPlayer(player) != cCivXPAztec)&&(kbGetCivForPlayer(player) != cCivXPSioux))
					{
						enemyCivHasArttillery = true;
						break;
					}
				}
			}
			if (enemyCivHasArttillery == false) //if enemy's civs have no arttillery Units(only Aztec and Sioux), no need to research this tech.
			{
			 xsDisableSelf();
			 return;
			}
			enemyCivConfirmed = true;
		}
		if (((gInitialStrategy <= 2)&&(kbGetAge() >= cAge2))||
			((gInitialStrategy == 3)&&(kbGetAge() >= cAge2)))
		{
			if ((kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive) > gGoodArmyPop)&&(kbTechGetStatus(cTechBigFirepitBattleAnger) == cTechStatusObtainable))
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigFirepitBattleAnger);
				if (upgradePlanID >= 0)
					aiPlanDestroy(upgradePlanID);
				createSimpleResearchPlan(cTechBigFirepitBattleAnger, getUnit(cUnitTypeFirePit), cEconomyEscrowID, 50);
				return;
			}
		}
	}

	if (kbGetCiv() == cCivXPAztec)
	{
		if (kbTechGetStatus(cTechBigFirepitFounder) == cTechStatusObtainable)
		{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBigFirepitFounder);
			if (upgradePlanID >= 0)
				aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechBigFirepitFounder, getUnit(cUnitTypeFirePit), cEconomyEscrowID, 50);
			return;
		}
	}
 
}

//==============================================================================
// rule lateInAge
//==============================================================================
extern int gLateInAgePlayerID = -1;
extern int gLateInAgeAge = -1;
rule lateInAge
minInterval 120
inactive
{
   // This rule is used to taunt a player who is behind in the age race, but only if
   // he is still in the previous age some time (see minInterval) after the other
   // players have all advanced.  Before activating this rule, the calling function
   // (ageUpHandler) must set the global variables for playerID and age, 
   // gLateInAgePlayerID and gLateInAgeAge.  When the rule finally fires minInterval 
   // seconds later, it checks to see if that player is still behind, and taunts accordingly.
   if (gLateInAgePlayerID < 0)
      return;
   
   if (kbGetAgeForPlayer(gLateInAgePlayerID) == gLateInAgeAge)
   {
      if ( gLateInAgeAge == cAge1 )
      {
         if ( (kbIsPlayerAlly(gLateInAgePlayerID) == true) && (gLateInAgePlayerID != cMyID) )
            sendStatement(gLateInAgePlayerID, cAICommPromptToAllyHeIsAge1Late); 
         if ( (kbIsPlayerEnemy(gLateInAgePlayerID) == true ) )
            sendStatement(gLateInAgePlayerID, cAICommPromptToEnemyHeIsAge1Late);
      }
      else
      {
         if ( (kbIsPlayerAlly(gLateInAgePlayerID) == true) && (gLateInAgePlayerID != cMyID) )
            sendStatement(gLateInAgePlayerID, cAICommPromptToAllyHeIsStillAgeBehind); 
         if ( (kbIsPlayerEnemy(gLateInAgePlayerID) == true ) )
            sendStatement(gLateInAgePlayerID, cAICommPromptToEnemyHeIsStillAgeBehind);
      }
   }
   gLateInAgePlayerID = -1;
   gLateInAgeAge = -1;
   xsDisableSelf();
}


//==============================================================================
// AgeUpHandler
//==============================================================================
void ageUpHandler(int playerID = -1) 
{
   
   int age = kbGetAgeForPlayer(playerID);
   bool firstToAge = true;      // Set true if this player is the first to reach that age, false otherwise
   bool lastToAge = true;         // Set true if this player is the last to reach this age, false otherwise
   int index = 0;
   int slowestPlayer = -1;
   int lowestAge = 100000;
   int lowestCount = 0;          // How many players are still in the lowest age?
   
   //aiEcho("AGE HANDLER:  Player "+playerID+" is now in age "+age);
   
   for (index = 1; < cNumberPlayers)
   {
      if (index != playerID)
      {
         // See if this player is already at the age playerID just reached.
         if (kbGetAgeForPlayer(index) >= age)
            firstToAge = false;  // playerID isn't the first
         if (kbGetAgeForPlayer(index) < age)
            lastToAge = false;   // Someone is still behind playerID.
      }
      if (kbGetAgeForPlayer(index) < lowestAge)
      {
         lowestAge = kbGetAgeForPlayer(index);
         slowestPlayer = index;
         lowestCount = 1;
      }
      else
      {
         if (kbGetAgeForPlayer(index) == lowestAge)
            lowestCount = lowestCount + 1;
      }
   }


   if ( (firstToAge == true) && (age == cAge2) )
   {  // This player was first to age 2
      if ( (kbIsPlayerAlly(playerID) == true) && (playerID != cMyID) )
         sendStatement(playerID, cAICommPromptToAllyHeReachesAge2First); 
      if ( (kbIsPlayerEnemy(playerID) == true ) )
         sendStatement(playerID, cAICommPromptToEnemyHeReachesAge2First);
      return();
   }
   if ( (lastToAge == true) && (age == cAge2) )
   {  // This player was last to age 2
      if ( (kbIsPlayerAlly(playerID) == true) && (playerID != cMyID) )
         sendStatement(playerID, cAICommPromptToAllyHeReachesAge2Last); 
      if ( (kbIsPlayerEnemy(playerID) == true ) )
         sendStatement(playerID, cAICommPromptToEnemyHeReachesAge2Last);
      return();
   }

   // Check to see if there is a lone player that is behind everyone else
   if ( (lowestCount == 1) && (slowestPlayer != cMyID) )
   {
      // This player is slowest, nobody else is still in that age, and it's not me,
      // so set the globals and activate the rule...unless it's already active.
      // This will cause a chat to fire later (currently 120 sec mininterval) if
      // this player is still lagging technologically.
      if (gLateInAgePlayerID < 0)
      {
         if (xsIsRuleEnabled("lateInAge") == false)
         {
            gLateInAgePlayerID = slowestPlayer;
            gLateInAgeAge = lowestAge;
            xsEnableRule("lateInAge");
            return();
         }
      }
   }
   
   // Check to see if ally advanced before me
   if ( (kbIsPlayerAlly(playerID) == true) && (age > kbGetAgeForPlayer(cMyID)) )
   {
      sendStatement(playerID, cAICommPromptToAllyHeAdvancesAhead);   
      return();
   }

   // Check to see if ally advanced before me
   if ( (kbIsPlayerEnemy(playerID) == true) && (age > kbGetAgeForPlayer(cMyID)) )
   {
      sendStatement(playerID, cAICommPromptToEnemyHeAdvancesAhead);   
      return();
   }      

}


/*
   getNuggetChatID()

   Called from the nugget event handler.  Given the player ID, determine what
   type of nugget was just claimed, and return a specific appropriate chat ID, if any.

   If none apply, return the general 'got nugget' chat ID.
*/
int getNuggetChatID(int playerID = -1)
{
   int retVal = cAICommPromptToEnemyWhenHeGathersNugget;
   int type = aiGetLastCollectedNuggetType(playerID);
   int effect = aiGetLastCollectedNuggetEffect(playerID);
   
   switch(type)
   {
      case cNuggetTypeAdjustResource:
      {
         switch(effect)
         {
            case cResourceGold:
            {
               retVal = cAICommPromptToEnemyWhenHeGathersNuggetCoin;
               break;
            }
            case cResourceFood:
            {
               retVal = cAICommPromptToEnemyWhenHeGathersNuggetFood;
               break;
            }
            case cResourceWood:
            {
               retVal = cAICommPromptToEnemyWhenHeGathersNuggetWood;
               break;
            }
         }
         break;
      }
      case cNuggetTypeSpawnUnit:
      {
         if ( (effect == cUnitTypeNatMedicineMan) || 
              (effect == cUnitTypeNatClubman) || 
              (effect == cUnitTypeNatRifleman) || 
              (effect == cUnitTypeNatHuaminca) || 
              (effect == cUnitTypeNatTomahawk) || 
              (effect == cUnitTypeNativeScout) || 
              (effect == cUnitTypeNatEagleWarrior) )
         {
            retVal = cAICommPromptToEnemyWhenHeGathersNuggetNatives;
         }
         if ( (effect == cUnitTypeSettler) || (effect == cUnitTypeCoureur) || (effect == cUnitTypeSettlerNative) || (effect == cUnitTypeypSettlerAsian) || (effect == cUnitTypeypSettlerIndian) )
            retVal = cAICommPromptToEnemyWhenHeGathersNuggetSettlers;
         break;
      }
      case cNuggetTypeGiveLOS:
      {
         break;
      }
      case cNuggetTypeAdjustSpeed:
      {
         break;
      }
      case cNuggetTypeAdjustHP:
      {
         break;
      }
      case cNuggetTypeConvertUnit:
      {
         if ( (effect == cUnitTypeNatMedicineMan) || 
              (effect == cUnitTypeNatClubman) || 
              (effect == cUnitTypeNatRifleman) || 
              (effect == cUnitTypeNatHuaminca) || 
              (effect == cUnitTypeNatTomahawk) || 
              (effect == cUnitTypeNativeScout) || 
              (effect == cUnitTypeNatEagleWarrior) )
         {
            retVal = cAICommPromptToEnemyWhenHeGathersNuggetNatives;
         }
         if ( (effect == cUnitTypeSettler) || (effect == cUnitTypeCoureur) || (effect == cUnitTypeSettlerNative) || (effect == cUnitTypeypSettlerAsian) || (effect == cUnitTypeypSettlerIndian) )
            retVal = cAICommPromptToEnemyWhenHeGathersNuggetSettlers;
         break;
      }
   }
   
   
   return(retVal);
}




//==============================================================================
// nuggetHandler
//==============================================================================
void nuggetHandler(int playerID =-1)
{
   if (kbGetAge() > cAge2)
      return;  // Do not send these chats (or even bother keeping count) after age 2 ends.
	//aiEcho("***************** Nugget handler running with playerID"+playerID);   
   static int nuggetCounts = -1;    // Array handle.  nuggetCounts[i] will track how many nuggets each player has claimed
   static int totalNuggets = 0;
   const int  cNuggetRange = 300;   // Nuggets within this many meters of a TC are "owned".
   int defaultChatID = getNuggetChatID(playerID);
   
   if ( (playerID < 1) || (playerID > cNumberPlayers) )
      return;
   
   // Initialize the array if we haven't done this before.
   if (nuggetCounts < 0)
   {
      nuggetCounts = xsArrayCreateInt(cNumberPlayers, 0, "Nugget Counts");
   }
   
   // Score this nugget
   totalNuggets = totalNuggets + 1;
   xsArraySetInt(nuggetCounts, playerID, xsArrayGetInt(nuggetCounts, playerID) + 1);
   
   // Check to see if one of the special-case chats might be appropriate.
   // If so, use it, otherwise, fall through to the generic ones.
   // First, some bookkeeping
   int i = 0;
   int count = 0;
   int lowestPlayer = -1;
   int lowestCount = 100000;  // Insanely high start value, first pass will reset it.
   int totalCount = 0;
   int averageCount = 0;
   int highestPlayer = -1;
   int highestCount = 0;
   for (i=1; <cNumberPlayers)
   {
      count = xsArrayGetInt(nuggetCounts, i,);  // How many nuggets has player i gathered?
      if ( count < lowestCount )
      {
         lowestCount = count;
         lowestPlayer = i;
      }
      if ( count > highestCount )
      {
         highestCount = count;
         highestPlayer = i;
      }
      totalCount = totalCount + count; 
   }
   averageCount = totalCount / (cNumberPlayers - 1);
   
   if (totalCount == 1) // This is the first nugget in the game
   {
      if(playerID != cMyID)
      {
         if(kbIsPlayerAlly(playerID) == true)
         {
            sendStatement(playerID, cAICommPromptToAllyWhenHeGathersFirstNugget); 
            return;
         }
         else
         {
            sendStatement(playerID, cAICommPromptToEnemyWhenHeGathersFirstNugget);
            return;
         }
      }
   }
   
   int playersCount = 0;
   int myCount = 0;
   myCount = xsArrayGetInt(nuggetCounts, cMyID);
   playersCount = xsArrayGetInt(nuggetCounts, playerID);
   // Check if this player is way ahead of me, i.e. 2x my total and ahead by at least 2
   if ( ((playersCount - myCount) >= 2) && (playersCount >= (myCount*2)) )
   {
      if(kbIsPlayerAlly(playerID) == true)
      {
         sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetHeIsAhead); 
         return;
      }
      else
      {
         sendStatement(playerID, cAICommPromptToEnemyWhenHeGathersNuggetHeIsAhead);
         return;
      }
   }

   // Check if I'm way ahead of any other players
   int player = 0;      // Loop counter...who might I send a message to
   bool messageSent = false;
   if (playerID == cMyID)
   {
      for (player = 1; <cNumberPlayers)
      {
         playersCount = xsArrayGetInt(nuggetCounts, player);
         if ( ((myCount - playersCount) >= 2) && (myCount >= (playersCount*2)) )
         {
            if(kbIsPlayerAlly(player) == true)
            {
               sendStatement(player, cAICommPromptToAllyWhenIGatherNuggetIAmAhead); 
               messageSent = true;
            }
            else
            {
               sendStatement(player, cAICommPromptToEnemyWhenIGatherNuggetIAmAhead);
               messageSent = true;
            }
         }  
      }
   }
   if (messageSent == true)
      return;
   
   // Check to see if the nugget was gathered near a main base.  
   // For now, check playerID's explorer location, assume nugget was gathered there.
   // Later, we may add location info to the event handler.
   vector explorerPos = cInvalidVector;
   int explorerID = -1;
   int tcID = -1;
   
   explorerID = getUnit(cUnitTypeExplorer, playerID, cUnitStateAlive);
   if (explorerID < 0)
      explorerID = getUnit(cUnitTypexpAztecWarchief, playerID, cUnitStateAlive);
   if (explorerID < 0)
      explorerID = getUnit(cUnitTypexpIroquoisWarChief, playerID, cUnitStateAlive);
   if (explorerID < 0)
      explorerID = getUnit(cUnitTypexpLakotaWarchief, playerID, cUnitStateAlive);
   if (explorerID < 0)
      explorerID = getUnit(cUnitTypeypMonkChinese, playerID, cUnitStateAlive);
   if (explorerID < 0)
      explorerID = getUnit(cUnitTypeypMonkIndian, playerID, cUnitStateAlive);
   if (explorerID < 0)
      explorerID = getUnit(cUnitTypeypMonkIndian2, playerID, cUnitStateAlive);
   if (explorerID < 0)
      explorerID = getUnit(cUnitTypeypMonkJapanese, playerID, cUnitStateAlive);
   if (explorerID < 0)
      explorerID = getUnit(cUnitTypeypMonkJapanese2, playerID, cUnitStateAlive);
   if (explorerID >= 0) // We know of an explorer, war chief or Asian monk for this player
   {
      if (kbUnitVisible(explorerID) == true)
      {  // And we can see him.
         explorerPos = kbUnitGetPosition(explorerID);
         if (playerID == cMyID)
         {  // I gathered the nugget
            // Get nearest ally TC distance
            tcID = getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationAlly, cUnitStateAlive, explorerPos, cNuggetRange);
            if ( (tcID > 0) && (kbUnitGetPlayerID(tcID) != cMyID) )
            {  // A TC is near, owned by an ally, and it's not mine...
               sendStatement(kbUnitGetPlayerID(tcID), cAICommPromptToAllyWhenIGatherNuggetHisBase); // I got a nugget near his TC
               return;
            }
            // Get nearest enemy TC distance
            tcID = getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationEnemy, cUnitStateAlive, explorerPos, cNuggetRange);
            if ( tcID > 0 )
            {  // A TC is near, owned by an enemy...
               sendStatement(kbUnitGetPlayerID(tcID), cAICommPromptToEnemyWhenIGatherNuggetHisBase); // I got a nugget near his TC
               return;
            }
         }
         else 
         {
            if (kbIsPlayerAlly(playerID) == true)
            {  // An ally has found a nugget, see if it's close to my TC
               tcID = getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, explorerPos, cNuggetRange);   
               if (tcID > 0)
               {  // That jerk took my nugget!
                  sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetMyBase); // He got one in my zone
                  return;
               }
            }
            else 
            {  // An enemy has found a nugget, see if it's in my zone
               tcID = getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, explorerPos, cNuggetRange);   
               if (tcID > 0)
               {  // That jerk took my nugget!
                  sendStatement(playerID, cAICommPromptToEnemyWhenHeGathersNuggetMyBase); // He got one in my zone
                  return;      
               }
            }
         }     // if me else
      }  // If explorer is visible to me
   }  // If explorer known
   
   // No special events fired, so go with generic messages
   // defaultChatID has the appropriate chat if an enemy gathered the nugget...send it.
   // Otherwise, convert to the appropriate case.
	if (playerID != cMyID)
	{
	    if (kbIsPlayerEnemy(playerID) == true)
	    {
	        sendStatement(playerID, defaultChatID);
	    }
	    else
	    {  // Find out what was returned, send the equivalent ally version
         switch(defaultChatID)
         {
            case cAICommPromptToEnemyWhenHeGathersNugget:
            {
               sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNugget); 
               break;
            }
            case cAICommPromptToEnemyWhenHeGathersNuggetCoin:
            {
               sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetCoin); 
               break;
            }
            case cAICommPromptToEnemyWhenHeGathersNuggetFood:
            {
               sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetFood); 
               break;
            }
            case cAICommPromptToEnemyWhenHeGathersNuggetWood:
            {
               sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetWood); 
               break;
            }
            case cAICommPromptToEnemyWhenHeGathersNuggetNatives:
            {
               sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetNatives); 
               break;
            }
            case cAICommPromptToEnemyWhenHeGathersNuggetSettlers:
            {
               sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetSettlers); 
               break;
            }
         }
     }
	}
	else
	{
		//-- I gathered the nugget.  Figure out what kind it is based on the defaultChatID enemy version.
      // Substitute appropriate ally and enemy chats.
      switch(defaultChatID)
      {
         case cAICommPromptToEnemyWhenHeGathersNugget:
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNugget);
            sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNugget);
            break;
         }
         case cAICommPromptToEnemyWhenHeGathersNuggetCoin:
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetCoin);
            sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetCoin);
            break;
         }
         case cAICommPromptToEnemyWhenHeGathersNuggetFood:
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetFood);
            sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetFood);
            break;
         }
         case cAICommPromptToEnemyWhenHeGathersNuggetWood:
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetWood);
            sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetWood);
            break;
         }
         case cAICommPromptToEnemyWhenHeGathersNuggetNatives:
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetNatives);
            sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetNatives);
            break;
         }
         case cAICommPromptToEnemyWhenHeGathersNuggetSettlers:
         {
            sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetSettlers);
            sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetSettlers);
            break;
         }
      }
   }
   return;
}

rule monitorFeeding
inactive
minInterval 60
{
   // Once a minute, check the global vars to see if there is somebody we need
   // to be sending resources to.  If so, send whatever we have in root.  If not,
   // go to sleep.
   // Feeding is not allowed before Age 2 is reached, or after revolting
   bool stayAwake = false; // Set true if we have orders to feed anything, keeps rule active.
   float toSend = 0.0;
   bool goldSent = false;  // Used for choosing chat at end.
   bool woodSent = false;
   bool foodSent = false;
   bool failure = false;
   int failPlayerID = -1;

   // Ignore already eliminated players
   if (kbHasPlayerLost(gFeedGoldTo) == true)
      gFeedGoldTo = 0;
   if (kbHasPlayerLost(gFeedWoodTo) == true)
      gFeedWoodTo = 0;
   if (kbHasPlayerLost(gFeedFoodTo) == true)
      gFeedFoodTo = 0;

   if (gFeedGoldTo > 0)
   {
      stayAwake = true; // There is work to do, stay active.
      toSend = 0.0;
      if (aiResourceIsLocked(cResourceGold) == false)
      {
         kbEscrowFlush(cEconomyEscrowID, cResourceGold, false);
         kbEscrowFlush(cMilitaryEscrowID, cResourceGold, false);
         toSend = kbEscrowGetAmount(cRootEscrowID, cResourceGold) * .85;   // Round down for trib penalty
      }
      if ((toSend > 100.0) && (kbGetAge() >= cAge2) && (gRevolutionFlag == false))
      {  // can send something
         goldSent = true;
         gLastTribSentTime = xsGetTime();
         if (toSend > 1000.0)
            toSend = 1000;
         if (toSend > 200.0)
            aiTribute(gFeedGoldTo, cResourceGold, toSend/2);
         else
            aiTribute(gFeedGoldTo, cResourceGold, 100.0);
      }
      else
      {
         failure = true;
         failPlayerID = gFeedGoldTo;
      }
      stayAwake = true; // There is work to do, stay active.
   }
   
   if (gFeedWoodTo > 0)
   {
      stayAwake = true; // There is work to do, stay active.
      toSend = 0.0;
      if (aiResourceIsLocked(cResourceWood) == false)
      {
         kbEscrowFlush(cEconomyEscrowID, cResourceWood, false);
         kbEscrowFlush(cMilitaryEscrowID, cResourceWood, false);
         toSend = kbEscrowGetAmount(cRootEscrowID, cResourceWood) * .85;   // Round down for trib penalty
      }
      if ((toSend > 100.0) && (kbGetAge() >= cAge2) && (gRevolutionFlag == false))
      {  // can send something
         gLastTribSentTime = xsGetTime();
         woodSent = true;
         if (toSend > 1000.0)
            toSend = 1000;
         if (toSend > 200.0)
            aiTribute(gFeedWoodTo, cResourceWood, toSend/2);
         else
            aiTribute(gFeedWoodTo, cResourceWood, 100.0);
      }
      else
      {
         failure = true;
         failPlayerID = gFeedWoodTo;
      }
      stayAwake = true; // There is work to do, stay active.
   }
   
   if (gFeedFoodTo > 0)
   {
      stayAwake = true; // There is work to do, stay active.
      toSend = 0.0;
      if (aiResourceIsLocked(cResourceFood) == false)
      {
         kbEscrowFlush(cEconomyEscrowID, cResourceFood, false);
         kbEscrowFlush(cMilitaryEscrowID, cResourceFood, false);
         toSend = kbEscrowGetAmount(cRootEscrowID, cResourceFood) * .85;   // Round down for trib penalty
      }
      if ((toSend > 100.0) && (kbGetAge() >= cAge2) && (gRevolutionFlag == false))
      {  // can send something
         gLastTribSentTime = xsGetTime();
         foodSent = true;
         if (toSend > 1000.0)
            toSend = 1000;
         if (toSend > 200.0)
            aiTribute(gFeedFoodTo, cResourceFood, toSend/2);
         else
            aiTribute(gFeedFoodTo, cResourceFood, 100.0);
      }
      else
      {
         failure = true;
         failPlayerID = gFeedFoodTo;
      }
      stayAwake = true; // There is work to do, stay active.
   }
   
   int tributes = 0;
   if (goldSent == true)
      tributes = tributes + 1;
   if (woodSent == true)
      tributes = tributes + 1;
   if (foodSent == true)
      tributes = tributes + 1;
         
   if (stayAwake == false)
   {
      aiEcho("Disabling monitorFeeding rule.");
      xsDisableSelf();  // No work to do, go to sleep.
   }
}


extern int gMissionToCancel = -1;   // Function returns # of units available, sets global var so commhandler can kill the mission if needed.
int unitCountFromCancelledMission(int oppSource = cOpportunitySourceAllyRequest)
{
   int retVal = 0;   // Number of military units available
   gMissionToCancel = -1;
   
   if (oppSource == cOpportunitySourceTrigger)
      return(0); // DO NOT mess with scenario triggers
   
   int planCount = aiPlanGetNumber(cPlanMission, cPlanStateWorking, true);
   int plan = -1;
   int childPlan = -1;
   int oppID = -1;
   int pri = -1;

   
   aiEcho(planCount+" missions found");
   for (i=0; < planCount)
   {
      plan = aiPlanGetIDByIndex(cPlanMission, cPlanStateWorking, true, i);
      if (plan < 0)
         continue;
      childPlan = aiPlanGetVariableInt(plan, cMissionPlanPlanID, 0);
      oppID = aiPlanGetVariableInt(plan, cMissionPlanOpportunityID, 0);
      aiEcho("  Examining mission "+plan);
      aiEcho("    Child plan is "+childPlan);
      aiEcho("    Opp ID is "+oppID);
      pri = aiGetOpportunitySourceType(oppID);
      aiEcho("    Opp priority is "+pri+", incoming command is "+oppSource);
      if ( (pri > cOpportunitySourceAutoGenerated) && (pri <= oppSource) ) // This isn't an auto-generated opp, and the incoming command has sufficient rank.
      {
         aiEcho("  This is valid to cancel.");
         gMissionToCancel = plan;   // Store this so commHandler can kill it.
         aiEcho("    Child plan has "+aiPlanGetNumberUnits(childPlan, cUnitTypeLogicalTypeLandMilitary)+" units.");
         retVal = aiPlanGetNumberUnits(childPlan, cUnitTypeLogicalTypeLandMilitary);
      }
      else
      {
         aiEcho("Cannot cancel mission "+plan);
         retVal = 0;
      }
   }   
   return(retVal);
}


//==============================================================================
// commHandler
//==============================================================================
void commHandler(int chatID =-1)
{
   // Set up our parameters in a convenient format...
   int fromID = aiCommsGetSendingPlayer(chatID);         // Which player sent this?
   int verb = aiCommsGetChatVerb(chatID);                // Verb, like cPlayerChatVerbAttack or cPlayerChatVerbDefend
   int targetType = aiCommsGetChatTargetType(chatID);    // Target type, like cPlayerChatTargetTypePlayers or cPlayerChatTargetTypeLocation
   int targetCount = aiCommsGetTargetListCount(chatID);  // How many targets?
   static int targets = -1;                              // Array handle for target array.
   vector location = aiCommsGetTargetLocation(chatID);   // Target location
   int firstTarget = -1;
   static int  targetList = -1;
   int opportunitySource = cOpportunitySourceAllyRequest;             // Assume it's from a player unless we find out it's player 0, Gaia, indicating a trigger
   int newOppID = -1;
   
   if (fromID == 0)  // Gaia sent this 
      opportunitySource = cOpportunitySourceTrigger;
   
   if (fromID == cMyID)
      return;  // DO NOT react to echoes of my own commands/requests.
   
   if ( (kbIsPlayerEnemy(fromID) == true) && (fromID != 0) )
      return;  // DO NOT accept messages from enemies.
   
   if (targets < 0)
   {
      aiEcho("Creating comm handler target array.");
      targets = xsArrayCreateInt(30, -1, "Chat targets");
      aiEcho("Create array int returns "+targets);
   }  
   
   // Clear, then fill targets array
   int i=0;
   for (i=0; <30)
      xsArraySetInt(targets, i, -1);
   
   if (targetCount > 30)
      targetCount = 30; // Stay within array bounds
   for (i=0; <targetCount)
      xsArraySetInt(targets, i, aiCommsGetTargetListItem(chatID, i));
   
   if (targetCount > 0)
      firstTarget = xsArrayGetInt(targets, 0);
   
   // Spew
   aiEcho(" ");
   aiEcho(" ");
   aiEcho("***** Incoming communication *****");
   aiEcho("From: "+fromID+",  verb: "+verb+",  targetType: "+targetType+",  targetCount: "+targetCount);
   for (i=0; <targetCount)
      aiEcho("        "+xsArrayGetInt(targets, i));
   aiEcho("Vector: "+location);
   aiEcho(" ");
   aiEcho("***** End of communication *****");
   
   switch(verb)      // Parse this message starting with the verb
   {
      case cPlayerChatVerbAttack: 
      {  // "Attack" from an ally player could mean attack enemy base, defend my base, or claim empty VP Site.  
         // Attack from a trigger means attack unit list.
         // Permission checks need to be done inside the inner switch statement, as cvOkToAttack only affects true attack commands.
         int militaryAvail = unitCountFromCancelledMission(opportunitySource);
         int reserveAvail = aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
         int totalAvail = militaryAvail + reserveAvail;
         aiEcho("Plan units available: "+militaryAvail+", reserve ="+reserveAvail+", good army size is "+gGoodArmyPop); 
         if(opportunitySource == cOpportunitySourceAllyRequest)
         {  // Don't mess with triggers this late in development
            if (totalAvail < 3)
            {
               aiEcho("Sorry, no units available.");
               // chat "no units" and bail               
               sendStatement(fromID, cAICommPromptToAllyDeclineNoArmy);               
               return;
            }
            if ( aiTreatyActive() == true )
            {
               aiEcho("Can't attack under treaty.");
               sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
               return;
            }
            else
            {
               if (totalAvail < (gGoodArmyPop/5))
               {
                  aiEcho("Sorry, not enough units.");
                  // chat "not enough army units" and bail
                  sendStatement(fromID, cAICommPromptToAllyDeclineSmallArmy);
                  return;
               }
            }
            // If we get here, it's not a trigger, but we do have enough units to go ahead.
            // See if cancelling an active mission is really necessary.
            if ( (reserveAvail > gGoodArmyPop/4) || (gMissionToCancel < 0) )
            {
               aiEcho("Plenty in reserve, no need to cancel...or no mission to cancel.");
            }
            else
            {
               aiEcho("Not enough military units, need to destroy mission "+gMissionToCancel);
               aiPlanDestroy(gMissionToCancel); // Cancel the active mission.
            }
         }
         switch(targetType)
         {
            case cPlayerChatTargetTypeLocation:
            {
               //-- Figure out what is in the this area, and do the correct thing.
               //-- Find nearest base and vpSite, and attack/defend/claim as appropriate.
               int closestBaseID = kbFindClosestBase(cPlayerRelationAny, location);     // If base is ally, attack point/radius to help out
               int closestVPSite = getClosestVPSite(location, cVPAll, cVPStateAny, -1);
               
               if ( (closestVPSite >= 0) && (distance(location, kbVPSiteGetLocation(closestVPSite)) < 20.0))
               {  // Near a VP site...this is a claim opportunity
                  newOppID = createOpportunity(cOpportunityTypeClaim, cOpportunityTargetTypeVPSite, closestVPSite, -1, opportunitySource);
                  sendStatement(fromID, cAICommPromptToAllyConfirm);
                  aiActivateOpportunity(newOppID, true);
                  break;   // We've created an Opp, we're done.
               }
               if( (closestBaseID != -1) && (distance(location, kbBaseGetLocation(kbBaseGetOwner(closestBaseID),closestBaseID)) < 50.0) )
               {  // Command is inside a base.  If enemy, base attack.  If ally, point/radius attack.
                  if (kbIsPlayerAlly( kbBaseGetOwner(closestBaseID) ) == false)
                  {  // This is an enemy base, create a base attack opportunity
                     if ( (cvOkToAttack == false) && (opportunitySource == cOpportunitySourceAllyRequest) )  // Attacks prohibited unless it's a trigger
                     {
                        // bail out, we're not allowed to do this.
                        sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
                        aiEcho("ERROR:  We're not allowed to attack.");
                        return();
                        break;
                     }
                     //newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypeBase, closestBaseID, kbBaseGetOwner(closestBaseID), opportunitySource);
                     //sendStatement(fromID, cAICommPromptToAllyConfirm, kbBaseGetLocation(kbBaseGetOwner(closestBaseID),closestBaseID));
                  }
                  if ( (gBaseAttackPlan >= 0) && (distance(gBaseAttackLocation, kbBaseGetLocation(kbBaseGetOwner(closestBaseID), closestBaseID)) > 70.0) )
		  {
	             aiPlanDestroy(gBaseAttackPlan);
		     gBaseAttackPlan = -1;
		     sendChatToAllies("I've terminate last base attack plan to back you up.");
		  }
															
		  if (gBaseAttackPlan < 0)
		  {
		     gBaseAttackPlan = aiPlanCreate("gBaseAttackPlan", cPlanAttack);
		     gBaseAttackLocation = kbBaseGetLocation(kbBaseGetOwner(closestBaseID),closestBaseID);
		     aiPlanSetVariableInt(gBaseAttackPlan, cAttackPlanPlayerID, 0, kbBaseGetOwner(closestBaseID));
		     aiPlanSetNumberVariableValues(gBaseAttackPlan, cAttackPlanTargetTypeID, 2, true);
		     aiPlanSetVariableInt(gBaseAttackPlan, cAttackPlanTargetTypeID, 0, cUnitTypeLogicalTypeLandMilitary);
		     aiPlanSetVariableInt(gBaseAttackPlan, cAttackPlanTargetTypeID, 1, cUnitTypeAbstractVillager);
		     aiPlanSetVariableVector(gBaseAttackPlan, cAttackPlanGatherPoint, 0, gBaseAttackLocation);
		     aiPlanSetVariableFloat(gBaseAttackPlan, cAttackPlanGatherDistance, 0, 60.0);
		     aiPlanSetVariableInt(gBaseAttackPlan, cAttackPlanRefreshFrequency, 0, 1);
		     aiPlanSetDesiredPriority(gBaseAttackPlan, 90);
		     //aiPlanSetInitialPosition(gBaseAttackPlan, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
		     aiPlanAddUnitType(gBaseAttackPlan, cUnitTypeLogicalTypeLandMilitary, totalAvail, totalAvail, totalAvail);
		     aiPlanAddUnitType(gBaseAttackPlan, cUnitTypexpMedicineManAztec, 0, 0, 0);
                     sendStatement(fromID, cAICommPromptToAllyConfirm, gBaseAttackLocation);
		     sendChatToAllies("At Once!");
		     aiPlanSetActive(gBaseAttackPlan);
		  }
                  else
                  {  // Ally base, so do attack point/radius here.
                     newOppID = createOpportunity(cOpportunityTypeDefend, cOpportunityTargetTypeBase, closestBaseID, kbBaseGetOwner(closestBaseID), opportunitySource);
                     aiSetOpportunityLocation(newOppID, kbBaseGetLocation(kbBaseGetOwner(closestBaseID),closestBaseID));
                     aiSetOpportunityRadius(newOppID, 50.0);                     
                     sendStatement(fromID, cAICommPromptToAllyIWillHelpDefend, location);
                     //createOpportunity(int type, int targettype, int targetID, int targetPlayerID, int source ): 
                  }
                  aiActivateOpportunity(newOppID, true);
                  break;   // We've created an Opp, we're done.
               }  

               // If we're here, it's not a VP site, and not an enemy or ally base - basically open map.
               // Create a point/radius destroy opportunity.
               newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypePointRadius, -1, chooseAttackPlayerID(location, 50.0), opportunitySource);
               aiSetOpportunityLocation(newOppID, location);
               aiSetOpportunityRadius(newOppID, 50.0);
               aiActivateOpportunity(newOppID, true);                     
               sendStatement(fromID, cAICommPromptToAllyConfirm);               
               break;   
            }  // case targetType location
            case cPlayerChatTargetTypeUnits:
            {  // This is a trigger command to attack a unit list.
               newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypeUnitList, targets, chooseAttackPlayerID(location, 50.0), opportunitySource);
               aiSetOpportunityLocation(newOppID, location);
               aiSetOpportunityRadius(newOppID, 50.0);    
               aiActivateOpportunity(newOppID, true);                 
               sendStatement(fromID, cAICommPromptToAllyConfirm);               
               break;
            }
            default:
            {  // Not recognized
               sendStatement(fromID, cAICommPromptToAllyDeclineGeneral);  
               aiEcho("ERROR!  Target type "+targetType+" not recognized.");
               return();   // Don't risk sending another chat...
               break;
            }
         }  // end switch targetType
         break;   
      }  // end verb attack
      
      case cPlayerChatVerbTribute:
      {
         if ( opportunitySource == cOpportunitySourceAllyRequest )
         {
            aiEcho("    Command was to tribute to player "+fromID+".  Resource list:");
            bool alreadyChatted = false;
            for (i=0; < targetCount)
            {
               float amountAvailable = 0.0;
               if (xsArrayGetInt(targets, i) == cResourceGold)
               {
                  kbEscrowFlush(cEconomyEscrowID, cResourceGold, false);
                  kbEscrowFlush(cMilitaryEscrowID, cResourceGold, false);
                  amountAvailable = kbEscrowGetAmount(cRootEscrowID, cResourceGold) * .85;   // Leave room for tribute penalty
                  if (aiResourceIsLocked(cResourceGold) == true)
                     amountAvailable = 0.0;
                  if ((amountAvailable > 100.0) && (kbGetAge() >= cAge2) && (gRevolutionFlag == false))
                  {  // We will tribute something
                     if (alreadyChatted == false)
                     {
                        sendStatement(fromID, cAICommPromptToAllyITributedCoin);  
                        alreadyChatted = true;
                     }
                     gLastTribSentTime = xsGetTime();
                     if (amountAvailable > 1000.0)
                        amountAvailable = 1000;
                     if (amountAvailable > 200.0)
                        aiTribute(fromID, cResourceGold, amountAvailable/2);
                     else
                        aiTribute(fromID, cResourceGold, 100.0);
                  }
                  else
                  {
                     if (alreadyChatted == false)
                     {
                        sendStatement(fromID, cAICommPromptToAllyDeclineCantAfford);
                        alreadyChatted = true;
                     }
                  }
                  aiEcho("        Tribute gold");
               }
               if (xsArrayGetInt(targets, i) == cResourceFood)
               {
                  kbEscrowFlush(cEconomyEscrowID, cResourceFood, false);
                  kbEscrowFlush(cMilitaryEscrowID, cResourceFood, false);
                  amountAvailable = kbEscrowGetAmount(cRootEscrowID, cResourceFood) * .85;   // Leave room for tribute penalty
                  if (aiResourceIsLocked(cResourceFood) == true)
                     amountAvailable = 0.0;
                  if ((amountAvailable > 100.0) && (kbGetAge() >= cAge2) && (gRevolutionFlag == false))
                  {  // We will tribute something
                     if (alreadyChatted == false)
                     {
                        sendStatement(fromID, cAICommPromptToAllyITributedFood);  
                        alreadyChatted = true;
                     }
                     gLastTribSentTime = xsGetTime();
                     if (amountAvailable > 1000.0)
                        amountAvailable = 1000;
                     if (amountAvailable > 200.0)
                        aiTribute(fromID, cResourceFood, amountAvailable/2);
                     else
                        aiTribute(fromID, cResourceFood, 100.0);
                  }
                  else
                  {
                     if (alreadyChatted == false)
                     {
                        sendStatement(fromID, cAICommPromptToAllyDeclineCantAfford);
                        alreadyChatted = true;
                     }
                  }
                  aiEcho("        Tribute food");
               }
               if (xsArrayGetInt(targets, i) == cResourceWood)
               {
                  kbEscrowFlush(cEconomyEscrowID, cResourceWood, false);
                  kbEscrowFlush(cMilitaryEscrowID, cResourceWood, false);
                  amountAvailable = kbEscrowGetAmount(cRootEscrowID, cResourceWood) * .85;   // Leave room for tribute penalty
                  if (aiResourceIsLocked(cResourceWood) == true)
                     amountAvailable = 0.0;
                  if ((amountAvailable > 100.0) && (kbGetAge() >= cAge2) && (gRevolutionFlag == false))
                  {  // We will tribute something
                     if (alreadyChatted == false)
                     {
                        sendStatement(fromID, cAICommPromptToAllyITributedWood);  
                        alreadyChatted = true;
                     }
                     gLastTribSentTime = xsGetTime();
                     if (amountAvailable > 2000.0)
                        amountAvailable = 1000;
                     if (amountAvailable > 200.0)
                        aiTribute(fromID, cResourceWood, amountAvailable/2);
                     else
                        aiTribute(fromID, cResourceWood, 100.0);
                     kbEscrowAllocateCurrentResources();
                  }
                  else
                  {
                     if (alreadyChatted == false)
                     {
                        sendStatement(fromID, cAICommPromptToAllyDeclineCantAfford);
                        alreadyChatted = true;
                     }
                  }
                  aiEcho("        Tribute wood");
               }
            }
         } // end source allyRequest
         else
         {     // Tribute trigger...send it to player 1
            aiEcho("    Command was a trigger to tribute to player 1.  Resource list:");
            for (i=0; <= 2)   // Target[x] is the amount of resource type X to send
            {
               float avail = kbEscrowGetAmount(cRootEscrowID, i) * .85;
               int qty = xsArrayGetInt(targets, i);
               if (qty > 0)
               {
                  aiEcho("        Resource # "+i+", amount: "+qty+" requested.");
                  if (avail >= qty)  // we can afford it
                  {
                     aiTribute(1, i, qty);
                     aiEcho("            Sending full amount.");
                  }
                  else
                  {
                     aiTribute(1, i, avail);   // Can't afford it, send what we have.
                     aiEcho("            Sending all I have, "+avail+".");
                  }
               }
            }
         }
         break;
      }  // End verb tribute
      
      case cPlayerChatVerbFeed:     // Ongoing tribute.  Once a minute, send whatever you have in root.
      {
         aiEcho("    Command was to feed resources to a player.");
         alreadyChatted = false;
         for (i=0; < targetCount)
         {
            switch(xsArrayGetInt(targets, i))
            {
               case cResourceGold:
               {
                  gFeedGoldTo = fromID;
                  if (xsIsRuleEnabled("monitorFeeding") == false)
                  {
                     xsEnableRule("monitorFeeding");
                     monitorFeeding();
                  }
                  if (alreadyChatted == false)
                  {
                     sendStatement(fromID, cAICommPromptToAllyIWillFeedCoin);
                     alreadyChatted = true;
                  }
                  break;
               }
               case cResourceWood:
               {
                  gFeedWoodTo = fromID;
                  if (xsIsRuleEnabled("monitorFeeding") == false)
                  {
                     xsEnableRule("monitorFeeding");
                     monitorFeeding();
                  }
                  if (alreadyChatted == false)
                  {
                     sendStatement(fromID, cAICommPromptToAllyIWillFeedWood);
                     alreadyChatted = true;
                  }
                  break;
               }
               case cResourceFood:
               {
                  gFeedFoodTo = fromID;
                  if (xsIsRuleEnabled("monitorFeeding") == false)
                  {
                     xsEnableRule("monitorFeeding");
                     monitorFeeding();
                  }
                  if (alreadyChatted == false)
                  {
                     sendStatement(fromID, cAICommPromptToAllyIWillFeedFood);
                     alreadyChatted = true;
                  }
                  break;
               }
            }            
         }
         break;
      } // End verb feed

      case cPlayerChatVerbTrain:
      {
         aiEcho(" Command was to train units starting with "+firstTarget+", unit type "+kbGetProtoUnitName(firstTarget));
         // See if we have authority to change the settings
         bool okToChange = false;
         if (opportunitySource == cOpportunitySourceTrigger)
            okToChange = true;   // Triggers always rule
         if (opportunitySource == cOpportunitySourceAllyRequest)
         {
            if ( (gUnitPickSource == cOpportunitySourceAllyRequest) || (gUnitPickSource == cOpportunitySourceAutoGenerated) )
               okToChange = true;
         }
         if (okToChange == true)
         {
            aiEcho("Permission granted, changing units.");
            gUnitPickSource = opportunitySource;    // Record who made this change
            gUnitPickPlayerID = fromID;
            
	    cvPrimaryArmyUnit = firstTarget;
            cvSecondaryArmyUnit = -1;
            aiEcho("Primary unit is "+firstTarget+" "+kbGetProtoUnitName(firstTarget));
            setUnitPickerPreference(gLandUnitPicker);

            if (gUnitPickSource == cOpportunitySourceAllyRequest)
               sendStatement(fromID, cAICommPromptToAllyConfirm);
         }
         else 
         {
            sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
            aiEcho("    Cannot override existing settings.");
         }
         break;
      }
      case cPlayerChatVerbDefend:
      {  // Currently, defend is only available via the aiCommsDefend trigger, it is not in the UI.
         // An "implicit" defend can be done when a human player issues an attack command on a location
         // that does not have enemy units nearby.  
         // Currently, all defend verbs will be point/radius
         newOppID = createOpportunity(cOpportunityTypeDefend, cOpportunityTargetTypePointRadius, -1, chooseAttackPlayerID(location, 50.0), opportunitySource);
         aiSetOpportunityLocation(newOppID, location);
         aiSetOpportunityRadius(newOppID, 50.0);              
         aiActivateOpportunity(newOppID, true);
         break;
      }
      case cPlayerChatVerbClaim:
      {  // Available only from trigger, sends a vector.  Humans can send implicit claim commands
         // by sending "attack" with a point that is near an unclaimed VP site.
         closestVPSite = getClosestVPSite(location, cVPAll, cVPStateAny, -1);
         bool permitted = true;
         if ( (cvOkToClaimTrade == false) && (kbVPSiteGetType(closestVPSite) == cVPTrade) )
            permitted = false;
         if ( (cvOkToAllyNatives== false) && (kbVPSiteGetType(closestVPSite) == cVPNative) )
            permitted = false;
         
         if (permitted = false)
         {
            sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
            aiEcho("    Not allowed to claim this type of site.");            
         }
         else
         {
            newOppID = createOpportunity(cOpportunityTypeClaim, cOpportunityTargetTypeVPSite, closestVPSite, -1, opportunitySource);
            aiActivateOpportunity(newOppID, true); 
         }            
         break;
      }
      case cPlayerChatVerbStrategy:
      {
	 if (xsArrayGetInt(targets, 0) == cPlayerChatTargetStrategyRush)
	 {
            btRushBoom = 1.0;
            xsEnableRule("turtleUp");
            gInitialStrategy = 1;
            gPrevNumTowers = gNumTowers;
            gNumTowers = 2;
	 }
	 else if (xsArrayGetInt(targets, 0) == cPlayerChatTargetStrategyBoom)
	 {  
            btRushBoom = -1.0;
            gInitialStrategy = 2;
         }
	 else if (xsArrayGetInt(targets, 0) == cPlayerChatTargetStrategyTurtle)
	 {
            btOffenseDefense = -1.0;
            xsEnableRule("turtleUp");
            gPrevNumTowers = gNumTowers;
            gInitialStrategy = 3;
            gNumTowers = kbGetBuildLimit(cMyID, gTowerUnit);
	 }
	 sendStatement(fromID, cAICommPromptToAllyConfirm);
	 break;
      }
      case cPlayerChatVerbCancel:
      {
         // Clear training (unit line bias) settings
         if ( (gUnitPickSource == cOpportunitySourceAllyRequest) || (opportunitySource == cOpportunitySourceTrigger) )  
         {  // We have an ally-generated unit line choice, destroy it
            gUnitPickSource = cOpportunitySourceAutoGenerated;
            gUnitPickPlayerID = -1;
            cvPrimaryArmyUnit = -1;
            cvSecondaryArmyUnit = -1;
            setUnitPickerPreference(gLandUnitPicker);            
         }
         
         // Clear Feeding (ongoing tribute) settings
         gFeedGoldTo = -1;
         gFeedWoodTo = -1;
         gFeedFoodTo = -1;
      
         // Cancel any active attack, defend or claim missions from allies or triggers
         if ( (opportunitySource == cOpportunitySourceTrigger) || (opportunitySource == cOpportunitySourceAllyRequest) )
         {
            if (gMostRecentAllyOpportunityID >= 0)
            {
               aiDestroyOpportunity(gMostRecentAllyOpportunityID);
               aiEcho("Destroying opportunity "+gMostRecentAllyOpportunityID+" because of cancel command.");
               gMostRecentAllyOpportunityID = -1;
            }
         }
         if (opportunitySource == cOpportunitySourceTrigger)
         {
            if (gMostRecentTriggerOpportunityID >= 0)
            {
               aiDestroyOpportunity(gMostRecentTriggerOpportunityID);
               aiEcho("Destroying opportunity "+gMostRecentTriggerOpportunityID+" because of cancel command.");
               gMostRecentTriggerOpportunityID = -1;
            }       
            // Also, a trigger cancel must kill any active auto-generated attack or defend plans
            int numPlans = aiPlanGetNumber(cPlanMission, -1, true);
            int index = 0;
            int plan = -1;
            int planOpp = -1;
            for (index = 0; < numPlans)
            {
               plan = aiPlanGetIDByIndex(cPlanMission, -1, true, index);
               planOpp = aiPlanGetVariableInt(plan, cMissionPlanOpportunityID, 0);
               if (planOpp >= 0)
               {
                  if (aiGetOpportunitySourceType(planOpp) == cOpportunitySourceAutoGenerated)
                  {
                     aiEcho("--------DESTROYING MISSION "+plan+" "+aiPlanGetName(plan));
                     aiPlanDestroy(plan);
                  }
               }
            }
         }
         // Reset number of towers
         if (gPrevNumTowers >= 0)
            gNumTowers = gPrevNumTowers;
         break;
      }
      default:
      {
         aiEcho("    Command verb not found, verb value is: "+verb);
         break;
      }
   }
   aiEcho("********************************************");   
}

rule delayAttackMonitor
inactive
group tcComplete
minInterval 15
{
   // If this rule is active, it means that gDelayAttacks has been set true,
   // and we're on a diffuclty level where we can't attack until AFTER someone
   // has attacked us, or until we've reached age 4.  
   
   
   if (kbGetAge() >= cAge4)
   {
      if ( (gDelayAttacks == true) && (aiGetWorldDifficulty() >= cDifficultyEasy) )
      {
         aiEcho(" ");
         aiEcho("    OK, THE GLOVES COME OFF NOW!");
         aiEcho(" ");
         gDelayAttacks = false;
      }
      xsDisableSelf();
      return;
   }
   
   // See if we're under attack.
   if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
   {  // Main base is under attack
      if ( (gDelayAttacks == true) && (aiGetWorldDifficulty() >= cDifficultyEasy) )
      {
         aiEcho(" ");
         aiEcho("    OK, THE GLOVES COME OFF NOW!");
         aiEcho(" ");
         gDelayAttacks = false;
      }
      xsDisableSelf();  // If sandbox, just turn off.
   }  
}

//==============================================================================
// exploreMonitor
/*
   Used to correctly implement changes in cvOkToExplore.
   If it's off, make sure the explore plan is killed.
   If it's on, make sure the explore plan is active.

   Initially, the explore plan gets an explorer plus 5/15/20 military units,
   so that it can effectively gather nuggets.  We switch out of this mode 3 minutes
   after reaching age 2, unless the explore plan is in nugget gathering mode.
*/
//==============================================================================
rule exploreMonitor
inactive 
minInterval 15
{
   const int   cExploreModeStart = 0;     // Initial setting, when first starting out
   const int   cExploreModeNugget = 1;    // Explore and gather nuggets.  Heavy staffing, OK to recruit more units.
   const int   cExploreModeStaff = 2;     // Restaffing the plan, active for 10 seconds to let the plan grab 1 more unit.
   const int   cExploreModeExplore = 3;   // Normal...explore until this unit dies, check again in 5 minutes.
   
   static int  exploreMode = cExploreModeStart;
   static int  age2Time = -1;
   static int  nextStaffTime = -1;        // Prevent the explore plan from constantly sucking in units.
   
   if ( (age2Time < 0) && (kbGetAge() >= cAge2) )
      age2Time = xsGetTime();

   // Check for a failed plan
   if ( (gLandExplorePlan >= 0) && (aiPlanGetState(gLandExplorePlan) < 0) )
   {
      // Somehow, the plan has died.  Reset it to start up again if allowed.
      gLandExplorePlan = -1;
      exploreMode = cExploreModeStart;
      nextStaffTime = -1;
   }
   
   // Decide on which unit type to use as single scouts
   // If possible, converted guardians or cheap infantry units are used
   // Decide on which unit type to use as scout
   /*int scoutType = -1;
   if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeAbstractInfantry;
   else if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeAbstractCavalry;   
   else if (kbUnitCount(cMyID, cUnitTypeAbstractNativeWarrior, cUnitStateAlive) >= 1)
      scoutType = cUnitTypeAbstractNativeWarrior;
   else
      scoutType = cUnitTypeLogicalTypeLandMilitary;
   */

   if ( cvOkToExplore == true )
   {
      if (aiPlanGetActive(gLandExplorePlan) == false)
         if (gLandExplorePlan >= 0)
            aiPlanSetActive(gLandExplorePlan);     // Reactivate if we were shut off
      switch(exploreMode)
      {
         case cExploreModeStart:
         {
            if (aiPlanGetState(gLandExplorePlan) < 0)
            {  // Need to create it.
               gLandExplorePlan=aiPlanCreate("Land Explore", cPlanExplore);
               aiPlanSetDesiredPriority(gLandExplorePlan, 75);
               if (cvOkToGatherNuggets == true)
               {
                  switch(kbGetCiv())
                  {
                     case cCivXPAztec:
                     {
                        aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpAztecWarchief, 1, 1, 1);
                        break;
                     }
                     case cCivXPIroquois:
                     {
                        aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
                        break;
                     }
                     case cCivXPSioux:
                     {
                        aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
                        break;
                     }
                     case cCivChinese:
                     {
                        aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkChinese, 1, 1, 1);
                        break;
                     }
                     case cCivIndians:
                     {
                        aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian, 1, 1, 1);
                        aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian2, 1, 1, 1);
                        break;
                     }
                     case cCivJapanese:
                     {
                        aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese, 1, 1, 1);
                        aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
                        break;
                     }
                     default:
                     {
                        aiPlanAddUnitType(gLandExplorePlan, cUnitTypeExplorer, 1, 1, 1);
                        break;
                     }
                  }
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeAbstractRangedInfantry, 1, 6, 10);
                  aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanOkToGatherNuggets, 0, true);
                  exploreMode = cExploreModeNugget;
               }
               else
               {
                  if (cMyCiv == cCivDutch) // Dutch will only use envoys (mainly handled in envoyMonitor rule)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeEnvoy, 1, 1, 1);
                  }
                  else
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeAbstractRangedInfantry, 1, 1, 1);
                     aiPlanSetUnitStance(gLandExplorePlan, cUnitStanceDefensive);
                  }
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeExplorer, 0, 0, 0);
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpAztecWarchief, 0, 0, 0);
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpIroquoisWarChief, 0, 0, 0);
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpLakotaWarchief, 0, 0, 0);
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkChinese, 0, 0, 0);
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian, 0, 0, 0);
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian2, 0, 0, 0);
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese, 0, 0, 0);
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese2, 0, 0, 0);
                  aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanOkToGatherNuggets, 0, false);
                  exploreMode = cExploreModeStaff;
                  nextStaffTime = xsGetTime() + 120000;     // Two minutes from now, let it get another soldier if it loses this one.
                  if (gExplorerControlPlan < 0)
                  {
                     gExplorerControlPlan = aiPlanCreate("Explorer control plan", cPlanDefend);
                     switch(kbGetCiv())
                     {
                        case cCivXPAztec:
                        {
                           //aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
                           break;
                        }
                        case cCivXPIroquois:
                        {
                           //aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
                           break;
                        }
                        case cCivXPSioux:
                        {
                           //aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
                           break;
                        }
                        case cCivChinese:
                        {
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkChinese, 1, 1, 1);
                           break;
                        }
                        case cCivIndians:
                        {
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian, 1, 1, 1);
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
                           break;
                        }
                        case cCivJapanese:
                        {
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
                           break;
                        }
                        default:
                        {
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeExplorer, 1, 1, 1);
                           break;
                        }
                     }
                     aiPlanSetVariableVector(gExplorerControlPlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
                     aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanEngageRange, 0, 20.0);    // Tight
                     aiPlanSetVariableBool(gExplorerControlPlan, cDefendPlanPatrol, 0, false);
                     aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanGatherDistance, 0, 20.0);
                     aiPlanSetInitialPosition(gExplorerControlPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
                     aiPlanSetUnitStance(gExplorerControlPlan, cUnitStanceDefensive);
                     aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanRefreshFrequency, 0, 1);
                     aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
                     aiPlanSetDesiredPriority(gExplorerControlPlan, 90);    // Quite high, don't suck him into routine attack plans, etc.
                     if (kbGetCiv() == cCivJapanese)
			aiPlanSetDesiredPriority(gExplorerControlPlan, 10);
                     aiPlanSetActive(gExplorerControlPlan);      
                  }     
               }
               aiPlanSetEscrowID(gLandExplorePlan, cEconomyEscrowID);
               aiPlanSetBaseID(gLandExplorePlan, kbBaseGetMainID(cMyID));
               aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanDoLoops, 0, true);
               aiPlanSetVariableInt(gLandExplorePlan, cExplorePlanNumberOfLoops, 0, 1);
               aiPlanSetActive(gLandExplorePlan); 
            }
            else
            {
               exploreMode = cExploreModeNugget;
            }
            break;
         }
         case cExploreModeNugget:
         {  
            // Check to see if we're out of time, and switch to single-unit exploring if we are.
            if (age2Time >= 0)
            {
               if ((((xsGetTime() - age2Time) > 180000) && (aiPlanGetState(gLandExplorePlan) != cPlanStateClaimNugget) ) ||
                   ((xsGetTime() - age2Time) > 60000) )     // we've been in age 2 > 3 minutes, or > 3 minutes and not in gathering mode

               {  // Switch to a normal explore plan, create explorer control plan, enable local nugget gathering
                  if (gExplorerControlPlan < 0)
                  {
                     gExplorerControlPlan = aiPlanCreate("Explorer control plan", cPlanDefend);
                     switch(kbGetCiv())
                     {
                        case cCivXPAztec:
                        {
                           //aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
                           break;
                        }
                        case cCivXPIroquois:
                        {
                           //aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
                           break;
                        }
                        case cCivXPSioux:
                        {
                           //aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
                           break;
                        }
                        case cCivChinese:
                        {
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkChinese, 1, 1, 1);
                           break;
                        }
                        case cCivIndians:
                        {
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian, 1, 1, 1);
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
                           break;
                        }
                        case cCivJapanese:
                        {
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
                           break;
                        }
                        default:
                        {
                           aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeExplorer, 1, 1, 1);
                           break;
                        }
                     }
                     aiPlanSetVariableVector(gExplorerControlPlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
                     aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanEngageRange, 0, 20.0);    // Tight
                     aiPlanSetVariableBool(gExplorerControlPlan, cDefendPlanPatrol, 0, false);
                     aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanGatherDistance, 0, 20.0);
                     aiPlanSetInitialPosition(gExplorerControlPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
                     aiPlanSetUnitStance(gExplorerControlPlan, cUnitStanceDefensive);
                     aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanRefreshFrequency, 0, 1);
                     aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
                     aiPlanSetDesiredPriority(gExplorerControlPlan, 90);    // Quite high, don't suck him into routine attack plans, etc.
                     if (kbGetCiv() == cCivJapanese)
			aiPlanSetDesiredPriority(gExplorerControlPlan, 10);
                     aiPlanSetActive(gExplorerControlPlan);     
                     xsEnableRule("localNuggetGathering"); 
                  }
                     
                  // Destroy and re-create plan for single scout
                  aiPlanDestroy(gLandExplorePlan);
                  gLandExplorePlan=aiPlanCreate("Land Explore", cPlanExplore);
                  aiPlanSetDesiredPriority(gLandExplorePlan, 75);
                  if (cMyCiv == cCivDutch) // Dutch will only use envoys (mainly handled in envoyMonitor rule)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeEnvoy, 1, 1, 1);
                  }
                  else
                  if ((civIsNative() == true) || (civIsAsian() == true) || (civIsEuropean() == true)) // Dutch will only use envoys (mainly handled in envoyMonitor rule)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeNativeScout, 1, 1, 1);
                  }
                  else
                  if ((civIsNative() == true) || (civIsAsian() == true) || (civIsEuropean() == true)) // Dutch will only use envoys (mainly handled in envoyMonitor rule)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypNativeScout, 1, 1, 1);
                  }
                  else
                  if ((civIsNative() == true) || (civIsAsian() == true) || (civIsEuropean() == true)) // Dutch will only use envoys (mainly handled in envoyMonitor rule)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMongolScout, 1, 1, 1);
                  }
                  else
                  if ((civIsNative() == true) || (civIsAsian() == true) || (civIsEuropean() == true)) // Dutch will only use envoys (mainly handled in envoyMonitor rule)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeAbstractPet, 1, 1, 1);
                  }
                  else
                  if (cMyCiv == cCivSpanish)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeWarDog, 1, 1, 1);
                  }
                  else
                  if (cMyCiv == cCivChinese)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkDisciple, 1, 1, 1);
                  }
				  else
                  if (civIsNative() == true)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeGuardian, 1, 1, 1);
                  }
                  else
                  if (cMyCiv == cCivOttomans)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeJanissary, 1, 1, 1);
                  }
                  else
                  if (cMyCiv == cCivXPSioux)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpAxeRider, 1, 1, 1);
                  }
                  else
                  if (cMyCiv == cCivIndians)
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypSepoy, 1, 1, 1);
                  }
                  else
                  if ((civIsNative() == true) || (civIsAsian() == true))
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeAbstractArcher, 1, 1, 1);
                  }
                  else
                  {
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeNativeScout, 1, 1, 1);
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypNativeScout, 1, 1, 1);
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMongolScout, 1, 1, 1);
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeAbstractPet, 1, 1, 1);
                     aiPlanAddUnitType(gLandExplorePlan, cUnitTypeAbstractRangedInfantry, 1, 1, 1);
                  }
                  aiPlanSetNoMoreUnits(gLandExplorePlan, false);
                  aiPlanSetVariableInt(gLandExplorePlan, cExplorePlanNumberOfLoops, 0, 0);
                  aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanDoLoops, 0, false);
                  exploreMode = cExploreModeStaff;
                  nextStaffTime = xsGetTime() + 120000;     // Two minutes from now, let it get another soldier.
                  aiEcho("Allowing the explore plan to grab a unit.");
               }
            }
            if (cvOkToGatherNuggets == false)
            {
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeExplorer, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpAztecWarchief, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpIroquoisWarChief, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpLakotaWarchief, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkChinese, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian2, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese, 0, 0, 0);
               aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese2, 0, 0, 0);
               if (cMyCiv == cCivDutch) // Dutch will only use envoys (mainly handled in envoyMonitor rule)
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeEnvoy, 1, 1, 1);
               }
               else
               {
                  aiPlanAddUnitType(gLandExplorePlan, cUnitTypeAbstractRangedInfantry, 1, 1, 1);
                  aiPlanSetUnitStance(gLandExplorePlan, cUnitStanceDefensive);
               }
               aiPlanSetNoMoreUnits(gLandExplorePlan, false);
               aiPlanSetVariableInt(gLandExplorePlan, cExplorePlanNumberOfLoops, 0, 0);
               aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanDoLoops, 0, false);
               exploreMode = cExploreModeStaff;
               nextStaffTime = xsGetTime() + 120000;     // Two minutes from now, let it get another soldier.
               aiEcho("Allowing the explore plan to grab a unit.");               
            }
            break;
         }
         case cExploreModeStaff:
         {
            // We've been staffing for 10 seconds, set no more units to true
            aiPlanSetNoMoreUnits(gLandExplorePlan, true);
            exploreMode = cExploreModeExplore;
            aiEcho("Setting the explore plan to 'noMoreUnits'");
            break;
         }
         case cExploreModeExplore:
         {  // See if we're allowed to add another unit
            if (xsGetTime() > nextStaffTime)
            {
               aiPlanSetNoMoreUnits(gLandExplorePlan, false);     // Let it grab a unit
               aiEcho("Setting the explore plan to grab a unit if needed.");
               nextStaffTime = xsGetTime() + 120000;
               exploreMode = cExploreModeStaff;
            }
            break;
         }
      }
   }
   else // cvOkToExplore = false
   {
      aiPlanSetActive(gLandExplorePlan, false);
   }
   //////find an enemy's resource site to attack villagers///////
   int enemyID = aiGetMostHatedPlayerID();
   vector enemyMainBaseLocation = kbBaseGetLocation(enemyID, kbBaseGetMainID(enemyID));
   int resourceType = -1;
   int randomizer = aiRandInt(6);
   if (randomizer <= 1 + kbGetAge())
     resourceType = cUnitTypeMine;
   else 
     resourceType = cUnitTypeHuntable;
   float maxRange = 50 * kbGetAge() + 200.0;

   static int enemyResourceQuery = -1;
   if (enemyResourceQuery < 0)
   {
     enemyResourceQuery = kbUnitQueryCreate("Enemy's Resource Query");
     kbUnitQuerySetIgnoreKnockedOutUnits(enemyResourceQuery, true);
     kbUnitQuerySetState(enemyResourceQuery, cUnitStateAlive);
     kbUnitQuerySetPlayerID(enemyResourceQuery, 0);
   }
   kbUnitQuerySetUnitType(enemyResourceQuery, resourceType);
   kbUnitQuerySetPosition(enemyResourceQuery, enemyMainBaseLocation);
   kbUnitQuerySetMaximumDistance(enemyResourceQuery, maxRange);
   kbUnitQueryResetResults(enemyResourceQuery);
   int resourceCount = kbUnitQueryExecute(enemyResourceQuery);
   int recourceID = -1;
   vector resourceLocation = cInvalidVector;
   int mainAreaGroup = kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
   int resourceAreaGroup = -1;
   bool found = false;
   int numStart = aiRandInt(resourceCount);
   int j = 0;
   int i = 0;
   for (j=numStart; < numStart + resourceCount)
   {
      if (j > resourceCount)
        i = j - resourceCount;
      else
	i = j;
      recourceID = kbUnitQueryGetResult(enemyResourceQuery, i);
      resourceLocation = kbUnitGetPosition(recourceID);
      resourceAreaGroup =  kbAreaGroupGetIDByPosition(resourceLocation);
      if ( (distance(enemyMainBaseLocation, resourceLocation) > 70.0) && (resourceAreaGroup == mainAreaGroup) )
      {
	 found = true;
	 break;
      }
   }      
   if (found == false)
     return;
   //////find an enemy's resource site to attack///////

   if (aiPlanGetNumber(cPlanExplore, -1, true) < 3)
   {
      int resourceExplorePlan = aiPlanCreate("resourceExplorePlan", cPlanExplore);
      aiPlanSetDesiredPriority(resourceExplorePlan, 75); 
      aiPlanAddUnitType(resourceExplorePlan, cUnitTypeAbstractRangedInfantry, 1, 1, 1);           
      aiPlanSetUnitStance(resourceExplorePlan, cUnitStanceAggressive);
      aiPlanAddWaypoint(resourceExplorePlan, resourceLocation);
      aiPlanSetVariableBool(resourceExplorePlan, cExplorePlanDoLoops, 0, false);
      aiPlanSetVariableInt(resourceExplorePlan, cExplorePlanNumberOfLoops, 0, -1);
      aiPlanSetVariableBool(resourceExplorePlan, cExplorePlanAvoidingAttackedAreas, 0, true);
      aiPlanSetRequiresAllNeedUnits(resourceExplorePlan, true);
      aiPlanSetActive(resourceExplorePlan);
      aiEcho("start a new resourceExplorePlan");
      return;
   }
   if (((resourceExplorePlan >= 0) && (aiPlanGetActive(resourceExplorePlan) == false))||
       ((resourceExplorePlan >= 0) && (aiPlanGetState(resourceExplorePlan) < 0))|| 
       (getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cMyID, cUnitStateAlive, resourceLocation, 15.0) > 0))
   {
      aiPlanDestroy(resourceExplorePlan);
      resourceExplorePlan = -1;
   }
}



//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Opportunities and Missions
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================



void missionStartHandler(int missionID = -1)
{  // Track times for mission starts, so we can tell how long its been since
   // we had a mission of a given type.
   if (missionID < 0)
      return;
   
   int oppID = aiPlanGetVariableInt(missionID, cMissionPlanOpportunityID, 0);
   int oppType = aiGetOpportunityType(oppID);
   
   aiPlanSetVariableInt(missionID, cMissionPlanStartTime, 0, xsGetTime()); // Set the start time in ms.
   
   switch(oppType)
   {
      case cOpportunityTypeDestroy:
      {
         gLastAttackMissionTime = xsGetTime()-5000;
         aiEcho("-------- ATTACK MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
         break;
      }
      case cOpportunityTypeDefend:
      {
         gLastDefendMissionTime = xsGetTime()-5000;
         aiEcho("-------- DEFEND MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
         break;
      }
      case cOpportunityTypeClaim:
      {
         gLastClaimMissionTime = xsGetTime()-180000;
         aiEcho("-------- CLAIM MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
         break;
      }
      default:
      {
         aiEcho("-------- UNKNOWN MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
         break;
      }
   }
}


void missionEndHandler(int missionID = -1)
{
   aiEcho("-------- MISSION TERMINATION:  Mission "+missionID+", Opp "+aiGetOpportunityType(aiPlanGetVariableInt(missionID, cMissionPlanOpportunityID, 0)));
}


// Get a class rating, 0.0 to 1.0, for this type of opportunity.
// Scores zero when an opportunity of this type was just launched.
// Scores 1.0 when it has been 'gXXXMissionInterval' time since the last one.
float getClassRating(int oppType = -1, int target = -1)
{
   float retVal = 1.0;
   float timeElapsed = 0.0;
   int targetType = -1;
   
 
   switch(oppType)
   {
      case cOpportunityTypeDestroy:
      {
         timeElapsed = xsGetTime() - gLastAttackMissionTime;         
         retVal = 1.0 * (timeElapsed / gAttackMissionInterval);
         break;
      }
      case cOpportunityTypeDefend:
      {
         timeElapsed = xsGetTime() - gLastDefendMissionTime;
         retVal = 1.0 * (timeElapsed / gDefendMissionInterval);
         break;
      }
      case cOpportunityTypeClaim:
      {
         timeElapsed = xsGetTime() - gLastClaimMissionTime;
         if (kbVPSiteGetType(target) == cVPTrade)
         {
            if ( btBiasTrade > 0.0)
               timeElapsed = timeElapsed * (1.0 + btBiasTrade);   // Multiply by at least one, up to 2, i.e. btBiasTrade of 1.0 will double elapsed time.
            else
               timeElapsed = timeElapsed / ((-1.0 * btBiasTrade) + 1.0);  // Divide by 1.00 up to 2.00, i.e. cut it in half if btBiasTrade = -1.0
            retVal = 1.0 * (timeElapsed / gClaimMissionInterval);
         }
         else  // VPNative
         {
            if ( btBiasNative > 0.0)
               timeElapsed = timeElapsed * (1.0 + btBiasNative);   // Multiply by at least one, up to 2, i.e. btBiasNative of 1.0 will double elapsed time.
            else
               timeElapsed = timeElapsed / ((-1.0 * btBiasNative) + 1.0);  // Divide by 1.00 up to 2.00, i.e. cut it in half if btBiasNative = -1.0
            retVal = 1.0 * (timeElapsed / gClaimMissionInterval);
         }
         break;
      }
   }
   if (retVal > 1.0)
      retVal = 1.0;
   if (retVal < 0.0)
      retVal = 0.0;
   return(retVal);
}


// Calculate an approximate rating for enemy strength in/near this base.
float getBaseEnemyStrength(int baseID = -1)
{
   
   float retVal = 0.0;
   int owner = kbBaseGetOwner(baseID);
   static int allyBaseQuery = -1;
  
   if (allyBaseQuery < 0)
   {
      allyBaseQuery = kbUnitQueryCreate("Ally Base query");
      kbUnitQuerySetIgnoreKnockedOutUnits(allyBaseQuery, true);
      kbUnitQuerySetPlayerRelation(allyBaseQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetState(allyBaseQuery, cUnitStateABQ);
      kbUnitQuerySetUnitType(allyBaseQuery, cUnitTypeLogicalTypeLandMilitary);
   }

   
   if (baseID < 0)
      return(-1.0);
   
   if (owner <= 0)
      return(-1.0);
   
   if (kbIsPlayerEnemy(owner) == true)  
   {  // Enemy base, add up military factors normally
      retVal = retVal + (30.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeTownCenter));  // 5 points per TC
      retVal = retVal + (30.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemy, cUnitTypeFortFrontier));  // 10 points per fort
      retVal = retVal + (1.5 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeLogicalTypeLandMilitary)); // 1 point per soldier
      retVal = retVal + (10.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeOutpost));  // 3 points per outpost
      retVal = retVal + (10.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeBlockhouse));  // 3 points per blockhouse
      retVal = retVal + (10.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeWarHut));  // 3 points per war hut
      retVal = retVal + (10.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeNoblesHut));  // 5 points per nobles hut
      retVal = retVal + (10.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort2));  // 5 points per agra fort
      retVal = retVal + (15.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort3));
      retVal = retVal + (20.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort4));
      retVal = retVal + (25.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort5));
      retVal = retVal + (10.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypCastle));  // 5 points per castle
      retVal = retVal + (2.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeYPOutpostAsian));  // 3 points per Asian outpost
      retVal = retVal + (2.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeTradingPost));  // 5 points per trading post (Advanced TP suspected!)
   }
   else 
   {  // Ally base, we're considering defending.  Count enemy units present
      kbUnitQuerySetUnitType(allyBaseQuery, cUnitTypeLogicalTypeLandMilitary);
      kbUnitQuerySetPosition(allyBaseQuery, kbBaseGetLocation(owner, baseID));
      kbUnitQuerySetMaximumDistance(allyBaseQuery, 60.0);
      kbUnitQueryResetResults(allyBaseQuery);
      retVal = kbUnitQueryExecute(allyBaseQuery);
   }
   if (retVal < 1.0)
      retVal = 1.0;  // Return at least 1.
   return(retVal);
}


// Calculate an approximate strength rating for the enemy units/buildings near this point.
float getPointEnemyStrength(vector loc = cInvalidVector)
{
   float retVal = 0.0;
   static int enemyPointQuery = -1;
  
   if (enemyPointQuery < 0)
   {
      enemyPointQuery = kbUnitQueryCreate("Enemy Point query");
      kbUnitQuerySetIgnoreKnockedOutUnits(enemyPointQuery, true);
      kbUnitQuerySetPlayerRelation(enemyPointQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetState(enemyPointQuery, cUnitStateABQ);
      kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeLogicalTypeLandMilitary);
   }

   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeLogicalTypeLandMilitary);
   kbUnitQuerySetPosition(enemyPointQuery, loc);
   kbUnitQuerySetMaximumDistance(enemyPointQuery, 60.0);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = kbUnitQueryExecute(enemyPointQuery);

   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeFortFrontier);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 30.0 * kbUnitQueryExecute(enemyPointQuery);  // Each fort counts as 10 units
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeTownCenter);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 30.0 * kbUnitQueryExecute(enemyPointQuery);  // Each TC counts as 5 units
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeOutpost);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(enemyPointQuery);  // Each tower counts as 3 units
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeBlockhouse);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(enemyPointQuery);  // Each blockhouse counts as 3 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeWarHut);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(enemyPointQuery);  // Each war hut counts as 3 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeNoblesHut);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(enemyPointQuery);  // Each nobles hut counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort2);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort3);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 15.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort4);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 20.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort5);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 25.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypCastle);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(enemyPointQuery);  // Each castle counts as 5 units 
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeYPOutpostAsian);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 2.0 * kbUnitQueryExecute(enemyPointQuery);  // Each Asian outpost counts as 3 units
   
   kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeTradingPost);
   kbUnitQueryResetResults(enemyPointQuery);
   retVal = retVal + 2.0 * kbUnitQueryExecute(enemyPointQuery);  // Each trading post counts as 5 units (Advanced TP suspected!)
     
   if (retVal < 1.0)
      retVal = 1.0;  // Return at least 1.
   return(retVal);
}

// Calculate an approximate strength rating for the allied units/buildings near this point.
float getPointAllyStrength(vector loc = cInvalidVector)
{
   float retVal = 0.0;
   static int allyPointQuery = -1;
  
   if (allyPointQuery < 0)
   {
      allyPointQuery = kbUnitQueryCreate("Ally Point query 2");
      kbUnitQuerySetIgnoreKnockedOutUnits(allyPointQuery, true);
      kbUnitQuerySetPlayerRelation(allyPointQuery, cPlayerRelationAlly);
      kbUnitQuerySetState(allyPointQuery, cUnitStateABQ);
      kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeLogicalTypeLandMilitary);
   }
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeLogicalTypeLandMilitary);
   kbUnitQuerySetPosition(allyPointQuery, loc);
   kbUnitQuerySetMaximumDistance(allyPointQuery, 60.0);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = kbUnitQueryExecute(allyPointQuery);

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeFortFrontier);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 20.0 * kbUnitQueryExecute(allyPointQuery);  // Each fort counts as 10 units

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeTownCenter);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 10.0 * kbUnitQueryExecute(allyPointQuery);  // Each TC counts as 5 units
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeOutpost);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 3.0 * kbUnitQueryExecute(allyPointQuery);  // Each tower counts as 3 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeBlockhouse);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 3.0 * kbUnitQueryExecute(allyPointQuery);  // Each blockhouse counts as 3 units 

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeWarHut);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 3.0 * kbUnitQueryExecute(allyPointQuery);  // Each war hut counts as 3 units 

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeNoblesHut);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // Each nobles hut counts as 5 units 

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort2);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort3);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort4);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort5);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypCastle);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // Each castle counts as 5 units 
   
   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeYPOutpostAsian);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 1.0 * kbUnitQueryExecute(allyPointQuery);  // Each Asian outpost counts as 3 units

   kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeTradingPost);
   kbUnitQueryResetResults(allyPointQuery);
   retVal = retVal + 1.0 * kbUnitQueryExecute(allyPointQuery);  // Each trading post counts as 5 units (Advanced TP suspected!)
   
   if (retVal < 1.0)
      retVal = 1.0;  // Return at least 1.
   return(retVal);
}



// Calculate an approximate value for this base.
float getBaseValue(int baseID = -1)
{
   float retVal = 0.0;
   int owner = kbBaseGetOwner(baseID);
   int relation = -1;
   
   if (baseID < 0)
      return(-1.0);
   
   if (owner <= 0)
      return(-1.0);
   
   if (kbIsPlayerAlly(owner) == true)
      relation = cPlayerRelationAlly;
   else
      relation = cPlayerRelationEnemyNotGaia;
   
   retVal = retVal + (1.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeLogicalTypeBuildingsNotWalls));
   retVal = retVal + (600.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeTownCenter));  // 1000 points extra per TC
   retVal = retVal + (400.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypePlantation));  // 600 points extra per plantation
   retVal = retVal + (10.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeFortFrontier));  // 2000 points extra per fort
   retVal = retVal + (40.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeLogicalTypeLandMilitary)); // 150 points per soldier
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeSettler));  // 200 points per settler
   retVal = retVal + (250.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeCoureur));  // 200 points per coureur
   retVal = retVal + (250.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeCoureurCree));  // 200 points per cree coureur
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeSettlerNative));  // 200 points per native settler
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypSettlerAsian));  // 200 points per Asian settler
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypSettlerIndian));  // 200 points per Indian settler
   retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypSettlerJapanese));  // 200 points per Japanese settler
   retVal = retVal + (400.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeSettlerWagon));  // 300 points per settler wagon
   retVal = retVal + (1200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeTradingPost));  // 1000 points per trading post
   retVal = retVal + (4000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeFactory));  // 3000 points extra per factory
   retVal = retVal + (2000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeBank));  // 1000 points extra per bank
   /*
   retVal = retVal + (400.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypShrineJapanese));  // 300 points extra per Shrine
   retVal = retVal + (4000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeAbstractWonder));  // 3000 points extra per wonder
   retVal = retVal + (400.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypDojo));  // 300 points extra per dojo
   retVal = retVal + (400.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeAbstractdock));  // 300 points extra per dock
   */
   retVal = retVal + (400.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeMill));  // 200 points extra per mill
   retVal = retVal + (400.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeFarm));  // 200 points extra per farm
   retVal = retVal + (400.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypRicePaddy));  // 200 points extra per rice paddy

   if (retVal < 1.0)
      retVal = 1.0;  // Return at least 1.
   return(retVal);
}


// Calculate an approximate value for the playerRelation units/buildings near this point.
// I.e. if playerRelation is enemy, calculate strength of enemy units and buildings.
float getPointValue(vector loc = cInvalidVector, int relation = cPlayerRelationEnemyNotGaia)
{
   float retVal = 0.0;
   static int allyQuery = -1;
   static int enemyQuery = -1;
   int queryID = -1; // Use either enemy or ally query as needed.
   
   if (allyQuery < 0)
   {
      allyQuery = kbUnitQueryCreate("Ally point value query");
      kbUnitQuerySetIgnoreKnockedOutUnits(allyQuery, true);
      kbUnitQuerySetPlayerRelation(allyQuery, cPlayerRelationAlly);
      kbUnitQuerySetState(allyQuery, cUnitStateABQ);
   }

   if (enemyQuery < 0)
   {
      enemyQuery = kbUnitQueryCreate("Enemy point value query");
      kbUnitQuerySetIgnoreKnockedOutUnits(enemyQuery, true);
      kbUnitQuerySetPlayerRelation(enemyQuery, cPlayerRelationEnemyNotGaia);
      kbUnitQuerySetSeeableOnly(enemyQuery, true);
      kbUnitQuerySetState(enemyQuery, cUnitStateAlive);
   }   
   
   if ( (relation == cPlayerRelationEnemy) || (relation == cPlayerRelationEnemyNotGaia) )
      queryID = enemyQuery;
   else
      queryID = allyQuery;
   
   kbUnitQueryResetResults(queryID);
   kbUnitQuerySetUnitType(queryID, cUnitTypeLogicalTypeBuildingsNotWalls);
   kbUnitQueryResetResults(queryID);
   retVal = 1.0 * kbUnitQueryExecute(queryID);   // 200 points per building
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeTownCenter);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 600.0 * kbUnitQueryExecute(queryID);  // Extra 1000 per TC
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeTradingPost);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 1200.0 * kbUnitQueryExecute(queryID);  // Extra 1000 per trading post
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeFactory);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 4000.0 * kbUnitQueryExecute(queryID);  // Extra 800 per factory

   kbUnitQuerySetUnitType(queryID, cUnitTypePlantation);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 400.0 * kbUnitQueryExecute(queryID);  // Extra 600 per plantation

   kbUnitQuerySetUnitType(queryID, cUnitTypeBank);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 2000.0 * kbUnitQueryExecute(queryID);  // Extra 300 per bank
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeMill);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 400.0 * kbUnitQueryExecute(queryID);  // Extra 200 per mill
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeFarm);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 400.0 * kbUnitQueryExecute(queryID);  // Extra 200 per farm
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypRicePaddy);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 400.0 * kbUnitQueryExecute(queryID);  // Extra 200 per rice paddy
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeSPCXPMiningCamp);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 1000.0 * kbUnitQueryExecute(queryID);  // Extra 1000 per SPC mining camp for XPack scenario
      
   kbUnitQuerySetUnitType(queryID, cUnitTypeUnit);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 40.0 * kbUnitQueryExecute(queryID);  // 200 per unit.
   /*
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeSettler);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeSettlerNative);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypSettlerAsian);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypSettlerJapanese);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypSettlerIndian);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 200.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeSettlerWagon);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 400.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeCoureur);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 250.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeCoureurCree);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 250.0 * kbUnitQueryExecute(queryID); 
   
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypShrineJapanese);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 400.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeypDojo);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 400.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeAbstractdock);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 400.0 * kbUnitQueryExecute(queryID); 
   
   kbUnitQuerySetUnitType(queryID, cUnitTypeAbstractWonder);
   kbUnitQueryResetResults(queryID);
   retVal = retVal + 4000.0 * kbUnitQueryExecute(queryID); 
	
	*/

   if (retVal < 1.0)
      retVal = 1.0;
      
   return(retVal);
}

//==============================================================================
// Called for each opportunity that needs to be scored.
//==============================================================================
void scoreOpportunity(int oppID = -1)
{
   /*
   
   Sets all the scoring components for the opportunity, and a final score.  The scoring
   components and their meanings are:
   
   int PERMISSION  What level of permission is needed to do this?  
      cOpportunitySourceAutoGenerated is the lowest...go ahead and do it.
      cOpportunitySourceAllyRequest...the AI may not do it on its own, i.e. it may be against the rules for this difficulty.
      cOpportunitySourceTrigger...even ally requests are denied, as when prevented by control variables, but a trigger (gaia request) may do it.
      cOpportunitySourceTrigger+1...not allowed at all.
   
   float AFFORDABLE  Do I have what it takes to do this?  This includes appropriate army sizes, resources to pay for things (like trading posts)
      and required units like explorers.  0.80 indicates a neutral, good-to-go position.  1.0 means overstock, i.e. an army of 20 would be good, 
      and I have 35 units available.  0.5 means extreme shortfall, like the minimum you could possibly imagine.  0.0 means you simply can't do it,
      like no units at all.  Budget issues like amount of wood should never score below 0.5, scores below 0.5 mean deep, profound problems.
   
   int SOURCE  Who asked for this mission?  Uses the cOpportunitySource... constants above.
   
   float CLASS  How much do we want to do this type of mission?   Based on personality, how long it's been since the last mission of this type, etc.
      0.8 is a neutral, "this is a good mission" rating.  1.0 is extremely good, I really, really want to do this next.  0.5 is a poor score.  0.0 means 
      I just flat can't do it.  This class score will creep up over time for most classes, to make sure they get done once in a while.
   
   float INSTANCE  How good is this particular target?  Includes asset value (is it important to attack or defend this?) and distance.  Defense values
      are incorporated in the AFFORDABLE calculation above.  0.0 is no value, this target can't be attacked.  0.8 is a good solid target.  1.0 is a dream target.
   
   float TOTAL  Incorporates AFFORDABLE, CLASS and INSTANCE by multiplying them together, so a zero in any one sets total to zero.  Source is added as an int
      IF AND ONLY IF SOURCE >= PERMISSION.  If SOURCE < PERMISSION, the total is set to -1.  Otherwise, all ally source opportunities will outrank all self generated
      opportunities, and all trigger-generated opportunities will outrank both of those.  Since AFFORDABLE, CLASS and INSTANCE all aim for 0.8 as a good, solid
      par value, a total score of .5 is rougly "pretty good".  A score of 1.0 is nearly impossible and should be quite rare...a high-value target, weakly defended,
      while I have a huge army and the target is close to me and we haven't done one of those for a long, long time.  
   
   Total of 0.0 is an opportunity that should not be serviced.  >0 up to 1 indicates a self-generated opportunity, with 0.5 being decent, 1.0 a dream, and 0.2 kind
   of marginal.  Ally commands are in the range 1.0 to 2.0 (unless illegal), and triggers score 2.0 to 3.0.
   
   */
   	
   // Interim values for the scoring components:
   int  permission = 0; 
   float instance = 0.0;
   float classRating = 0.0;
   float total = 0.0;
   float affordable = 0.0;
   float score = 0.0;
   
   // Info about this opportunity
   int source = aiGetOpportunitySourceType(oppID);
   if (source < 0) 
      source = cOpportunitySourceAutoGenerated;
   if (source > cOpportunitySourceTrigger)
      source = cOpportunitySourceTrigger;
   int target = aiGetOpportunityTargetID(oppID);
   int targetType = aiGetOpportunityTargetType(oppID);
   int oppType = aiGetOpportunityType(oppID);
   int targetPlayer = aiGetOpportunityTargetPlayerID(oppID);
   int mostHatedPlayerID = aiGetMostHatedPlayerID(); // Get to the most hated player to attack
   vector location = aiGetOpportunityLocation(oppID);
   float radius = aiGetOpportunityRadius(oppID);
   if (radius < 40.0)
      radius = 40.0;
   int baseOwner = -1;
   float baseEnemyPower = 0.0;   // Used to measure troop and building strength.  Units roughly equal to unit count of army.
   float baseAllyPower = 0.0;    // Strength of allied buildings and units, roughly equal to unit count.
   float netEnemyPower = 0.0;    // Basically enemy minus ally, but the ally effect can, at most, cut 80% of enemy strength
   float baseAssets = 0.0;    // Rough estimate of base value, in aiCost.  
   float affordRatio = 0.0;
   bool  errorFound = false;  // Set true if we can't do a good score.  Ends up setting score to -1.

   // Variables for available number of units and plan to kill if any
   float armySizeAuto = 0.0;  // For source cOpportunitySourceAutoGenerated
   float armySizeAlly = 0.0;  // For ally-generated commands, how many units could we scrounge up?
   int missionToKillAlly = -1;   // Mission to cancel in order to provide the armySizeAlly number of units.  
   float armySizeTrigger = 0.0;  // For trigger-generated commands, how many units could we scrounge up?
   int missionToKillTrigger = -1;   // Mission to cancel in order to provide the armySizeTrigger number of units.
   float armySize = 0.0;      // The actual army size we'll use for calcs, depending on how big the target is.
   float missionToKill = -1;  // The actual mission to kill based on the army size we've selected.
   
   float oppDistance = 0.0;      // Distance to target location or base.
   bool  sameAreaGroup = true;   // Set false if opp is on another areagroup.

   bool defendingMonopoly = false;
   bool attackingMonopoly = false;
   int  tradePostID = -1;     // Set to trade post ID if this is a base target, and a trade post is nearby.
   
   bool defendingKOTH = false;
   bool attackingKOTH = false;
   int  KOTHID = -1;     // Set to the hill ID if this is a base target, and the hill is nearby.

   if (gIsMonopolyRunning == true)
   {
      //if (gMonopolyTeam == kbGetPlayerTeam(cMyID))
      //   defendingMonopoly = true;  // We're defending, let's not go launching any attacks
      //else
         attackingMonopoly = true;  // We're attacking, focus on trade posts
   }
   
   if (gIsKOTHRunning == true)
   {
      if (gKOTHTeam == kbGetPlayerTeam(cMyID))
         defendingKOTH = true;  // We're defending, let's not go launching any attacks
      else
         attackingKOTH = true;  // We're attacking, focus on the hill
   }

   //-- get the number of units in our reserve.
   armySizeAuto = aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
   armySizeAlly = armySizeAuto;
   armySizeTrigger = armySizeAlly;
   
//   aiEcho(" ");
//   aiEcho("Scoring opportunity "+oppID+", targetID "+target+", location "+location);
   
   // Get target info
   switch(targetType)
   {
      case cOpportunityTargetTypeBase:
      {
         location = kbBaseGetLocation(kbBaseGetOwner(target),target);
         //loc = kbBaseGetLocation(mostHatedPlayerID, kbBaseGetMainID(mostHatedPlayerID));
         tradePostID = getUnitByLocation(cUnitTypeTradingPost, kbBaseGetOwner(target), cUnitStateAlive, location, 40.0);   
         KOTHID = getUnitByLocation(cUnitTypeypKingsHill, kbBaseGetOwner(target), cUnitStateAlive);//, location, 40.0);   
         radius = 50.0;
         baseOwner = kbBaseGetOwner(target);
         baseEnemyPower = getBaseEnemyStrength(target);  // Calculate "defenses" as enemy units present
         baseAllyPower = getPointAllyStrength(kbBaseGetLocation(kbBaseGetOwner(target),target));
         if ( (baseEnemyPower*0.8) > baseAllyPower)   
            netEnemyPower = baseEnemyPower - baseAllyPower;   // Ally power is less than 80% of enemy
         else
            netEnemyPower = baseEnemyPower * 0.2;  // Ally power is more then 80%, but leave a token enemy rating anyway.
            
         baseAssets = getBaseValue(target);  //  Rough value of target
         if ( (gIsMonopolyRunning == true) && (tradePostID >= 0) )
            baseAssets = baseAssets + 10000; // Huge bump if this is a trade post (enemy or ally) and a monopoly is running            
         if ( (gIsKOTHRunning == true) && (KOTHID >= 0) )
            baseAssets = baseAssets + 10000; // Huge bump if this is the hill (enemy or ally) and a timer is running 
         if (mostHatedPlayerID >= 0) 
            baseAssets = baseAssets + 4000;         
         break;
      }
      case cOpportunityTargetTypePointRadius:
      {
         baseEnemyPower = getPointEnemyStrength(location);
         baseAllyPower = getPointAllyStrength(location);
         if ( (baseEnemyPower*0.8) > baseAllyPower)   
            netEnemyPower = baseEnemyPower - baseAllyPower;   // Ally power is less than 80% of enemy
         else
            netEnemyPower = baseEnemyPower * 0.2;  // Ally power is more then 80%, but leave a token enemy rating anyway.
            
         baseAssets = getPointValue(location);  //  Rough value of target
         break;
      }
      case cOpportunityTargetTypeVPSite:     // This is only for CLAIM missions.  A VP site that is owned will be a 
                                             // defend or destroy opportunity.
      {
         location = kbVPSiteGetLocation(target);
         radius = 50.0;
         
         baseEnemyPower = getPointEnemyStrength(location);
         baseAllyPower = getPointAllyStrength(location);
         if ( (baseEnemyPower*0.8) > baseAllyPower)   
            netEnemyPower = baseEnemyPower - baseAllyPower;   // Ally power is less than 80% of enemy
         else
            netEnemyPower = baseEnemyPower * 0.2;  // Ally power is more then 80%, but leave a token enemy rating anyway.
        
         baseAssets = 2000.0;    // Arbitrary...consider a claimable VP Site as worth 2000 resources.
         break;
      }
   }
   
   if (netEnemyPower < 1.0)
      netEnemyPower = 1.0;   // Avoid div 0
   
   oppDistance = distance(location, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
   if (oppDistance <= 0.0)
      oppDistance = 1.0;
   if ( kbAreaGroupGetIDByPosition(location) != kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) )
      sameAreaGroup = false;
   
   
   // Figure which armySize to use.  This currently is a placeholder, we may not need to mess with it.
   armySize = armySizeAuto;   // Default

//   aiEcho("    EnemyPower "+baseEnemyPower+", AllyPower "+baseAllyPower+", NetEnemyPower "+netEnemyPower);
//   aiEcho("    BaseAssets "+baseAssets+", myArmySize "+armySize);
   
   switch(oppType)
   {
      case cOpportunityTypeDestroy:
      {
         // Check permissions required.
         if(cvOkToAttack == false)
            permission = cOpportunitySourceTrigger;   // Only triggers can make us attack.
         
         if (gDelayAttacks == true)
            permission = cOpportunitySourceTrigger;   // Only triggers can override this difficulty setting.
         
         // Check affordability
         
         if (netEnemyPower < 0.0)
         {
            errorFound = true;
            affordable = 0.0;
         }
         else
         {
            // Set affordability.  Roughly armySize / baseEnemyPower, but broken into ranges.
            // 0.0 is no-can-do, i.e. no troops.  0.8 is "good", i.e. armySize is double baseEnemyPower.  
            // Above a 2.0 ratio, to 5.0, scale this into the 0.8 to 1.0 range.
            // Above 5.0, score it 1.0
            affordRatio = armySize / netEnemyPower;
            if (affordRatio < 2.0)
               affordable = affordRatio / 2.5;  // 0 -> 0.0,  2.0 -> 0.8
            else
               affordable = 0.8 + ((affordRatio - 2.0) / 15.0); // 2.0 -> 0.8 and 5.0 -> 1.0
            if (affordable > 1.0)
               affordable = 1.0;
            //if (mostHatedPlayerID > 0)
               //affordable = 1.0;
         }  // Affordability is done
            
         // Check target value, calculate INSTANCE score.
         if (baseAssets < 0.0)
         {
            errorFound = true;
         }
         // Clip base value to range of 100 to 10K for scoring
         if (baseAssets < 100.0)
            baseAssets = 100.0;
         if (baseAssets > 10000.0)
            baseAssets = 10000.0;
         // Start with an "instance" score of 0 to .8 for bases under 2K value.
         instance = (0.8 * baseAssets) / 2000.0;
         // Over 2000, adjust so 2K = 0.8, 30K = 1.0
         if (baseAssets > 2000.0)
            instance = 1.0;
            //instance = 0.8 + ( (0.2 * (baseAssets - 2000.0)) / 8000.0);
         
         // Instance is now 0..1, adjust for distance. If < 100m, leave as is.  Over 100m to 400m, penalize 10% per 100m.
         float penalty = 0.0;
         /*if (oppDistance > 100.0)
            penalty = (0.1 * (oppDistance - 100.0)) / 100.0;
         if (penalty > 0.6)
            penalty = 0.6;
         instance = instance * (1.0 - penalty); // Apply distance penalty, INSTANCE score is done.
         */
         if (sameAreaGroup = false)
            instance = instance / 2.0;         
         if (targetType == cOpportunityTargetTypeBase)
         {   
            if (kbHasPlayerLost(baseOwner) == true)
               instance = -1.0;
         }
         // Illegal if it's over water, i.e. a lone dock
         if (kbAreaGetType(kbAreaGetIDByPosition(location)) == cAreaTypeWater)
            instance = -1.0;
         
         // Check for weak target blocks, which means the content designer is telling us that this target needs its instance score bumped up
         int weakBlockCount = 0;
         int strongBlockCount = 0;
         
         if ( targetType == cOpportunityTargetTypeBase)
         {
            weakBlockCount = getUnitCountByLocation(cUnitTypeAITargetBlockWeak, cMyID, cUnitStateAlive, kbBaseGetLocation(baseOwner, target), 2000.0); 
            strongBlockCount = getUnitCountByLocation(cUnitTypeAITargetBlockStrong, cMyID, cUnitStateAlive, kbBaseGetLocation(baseOwner, target), 2000.0);
         }
         if ( (targetType == cOpportunityTargetTypeBase) || (weakBlockCount > 0) || (instance >= 0.0) )
         {  // We have a valid instance score, and there is at least one weak block in the area.  For each weak block, move the instance score halfway to 1.0.
            while (weakBlockCount > 0)
            {
               instance = instance + ((1.0-instance) / 2.0);   // halfway up to 1.0
               weakBlockCount--;
            }
         }        

         classRating = getClassRating(cOpportunityTypeDestroy);   // 0 to 1.0 depending on how long it's been.
         if ( (gIsMonopolyRunning == true) && (tradePostID < 0) ) // Monopoly, and this is not a trade post site
            classRating = 0.25;
         
         if ( defendingMonopoly == true )
            classRating = 1.0;      // If defending, don't attack other targets
         
         if ( ( attackingMonopoly == true) && (tradePostID >= 0) )  // We're attacking, and this is an enemy trade post...go get it
            classRating = 1.0;
            
         if ( (gIsKOTHRunning == true) && (KOTHID < 0) ) // KOTH, and this is the hill
            classRating = 0.0;
         
         if ( defendingKOTH == true )
            classRating = 0.0;      // If defending, don't attack other targets
         
         if ( ( attackingKOTH == true) && (KOTHID >= 0) )  // We're attacking, and this is an enemy hill...go get it
            classRating = 1.0;

         if (mostHatedPlayerID > 0) // this is an enemy.....go get it
            classRating = 1.0;

         if ( (targetType == cOpportunityTargetTypeBase) || (strongBlockCount > 0) || (classRating >= 0.0) )
         {  // We have a valid instance score, and there is at least one strong block in the area.  For each weak block, move the classRating score halfway to 1.0.
            while (strongBlockCount > 0)
            {
               classRating = 1.0;   // 1.0 is perfect
               strongBlockCount--;               
            }
         }
         
         if (aiTreatyActive() == true)
            classRating = 0.0;   // Do not attack anything if under treaty
 
         break;
      }
      case cOpportunityTypeClaim:
      {
         // Check permissions required.
         if( (cvOkToClaimTrade == false) && (kbVPSiteGetType(target) == cVPTrade) )
            permission = cOpportunitySourceTrigger;   // Only triggers can let us override this.
         if( (cvOkToAllyNatives == false) && (kbVPSiteGetType(target) == cVPNative) )
            permission = cOpportunitySourceTrigger;   // Only triggers can let us override this.
         if (gDelayAttacks == true)     // Taking trade sites and natives is sort of aggressive, turn it off on easy/sandbox.
            permission = cOpportunitySourceTrigger;   // Only triggers can override this difficulty setting.
         
         // Check affordability.  50-50 weight on military affordability and econ affordability
         //float milAfford = 0.0;
         float econAfford = 0.0;
         /*affordRatio = armySize / netEnemyPower;
         if (affordRatio < 2.0)
           milAfford = affordRatio / 2.5;  // 0 -> 0.0,  2.0 -> 0.8
         else
           milAfford = 0.8 + ((affordRatio - 2.0) / 15.0); // 2.0 -> 0.8 and 5.0 -> 1.0
         if (milAfford > 1.0)
           milAfford = 1.0; */

         if (aiGetGameMode() == cGameModeDeathmatch)  //DM jump-start
           affordRatio = kbUnitCostPerResource(cUnitTypeTradingPost, cResourceWood);
         if ( (kbResourceGet(cResourceWood) >= 400) && (aiGetGameMode() != cGameModeDeathmatch) )
           affordRatio = kbUnitCostPerResource(cUnitTypeTradingPost, cResourceWood);

         /*if (affordRatio < 1.0)
           econAfford = affordRatio;
         else
           econAfford = 1.0;
         if (econAfford > 1.0)
           econAfford = 1.0;      
         if (econAfford < 0.0)
           econAfford = 0.0;*/
         affordable = affordRatio; // Simple average
         
         // Instance
         instance = 1.0;   // Same for all, unless I prefer to do one type over other (personality)
         penalty = 0.0;
         if (oppDistance > 100.0)
            penalty = (0.1 * (oppDistance - 100.0)) / 100.0;
         if (penalty > 0.6)
            penalty = 0.6;
         instance = instance * (1.0 - penalty); // Apply distance penalty, INSTANCE score is done.         
         if (sameAreaGroup = false)
            instance = instance / 2.0;
         classRating = getClassRating(cOpportunityTypeClaim, target);   // 0 to 1.0 depending on how long it's been.
         
         break;
      }
      case cOpportunityTypeRaid:
      {
         break;
      }
      case cOpportunityTypeDefend:
      {  
        
         // Check affordability
 
         if (netEnemyPower < 0.0)
         {
            errorFound = true;
            affordable = 0.0;
         }
         else
         {
            // Set affordability.  Roughly armySize / netEnemyPower, but broken into ranges.
            // Very different than attack calculations.  Score high affordability if the ally is really 
            // in trouble, especially if my army is large.  Basically...does he need help?  Can I help?
            if (baseAllyPower < 1.0)
               baseAllyPower = 1.0;
            float enemyRatio = baseEnemyPower / baseAllyPower;
            float enemySurplus = baseEnemyPower - baseAllyPower;
            if (enemyRatio < 0.5)   // Enemy very weak, not a good opp.
            {
               affordRatio = enemyRatio;  // Low score, 0 to .5
               if (enemyRatio < 0.2)
                  affordRatio = 0.0;
            }
            else
               affordRatio = 0.5 + ( (enemyRatio - 0.5) / 5.0);   // ratio 0.5 scores 0.5, ratio 3.0 scores 1.0
            if ( (affordRatio * 10.0) > enemySurplus )
               affordRatio = enemySurplus / 10.0;  // Cap the afford ratio at 1/10 the enemy surplus, i.e. don't respond if he's just outnumbered 6:5 or something trivial.
            if (enemySurplus < 0)
               affordRatio = 0.0;
            if (affordRatio > 1.0)
               affordRatio = 1.0;
            // AffordRatio now represents how badly I'm needed...now, can I make a difference
            if (armySize < enemySurplus)  // I'm gonna get my butt handed to me
               affordRatio = affordRatio * (armySize / enemySurplus);   // If I'm outnumbered 3:1, divide by 3.
            // otherwise, leave it alone.
            
            affordable = affordRatio;
         }  // Affordability is done
            
         // Check target value, calculate INSTANCE score.
         if (baseAssets < 0.0)
         {
            errorFound = true;
         }
         // Clip base value to range of 100 to 30K for scoring
         if (baseAssets < 100.0)
            baseAssets = 100.0;
         if (baseAssets > 30000.0)
            baseAssets = 30000.0;
         // Start with an "instance" score of 0 to .8 for bases under 2K value.
         instance = (0.8 * baseAssets) / 1000.0;
         // Over 1000, adjust so 1K = 0.8, 30K = 1.0
         if (baseAssets > 1000.0)
            instance = 0.8 + ( (0.2 * (baseAssets - 1000.0)) / 29000.0);
         
         // Instance is now 0..1, adjust for distance. If < 200m, leave as is.  Over 200m to 400m, penalize 10% per 100m.
         penalty = 0.0;
         if (oppDistance > 200.0)
            penalty = (0.1 * (oppDistance - 200.0)) / 100.0;
         if (penalty > 0.6)
            penalty = 0.6;
         instance = instance * (1.0 - penalty); // Apply distance penalty, INSTANCE score is done.
         if (sameAreaGroup == false)
            instance = 0.0;
         if (targetType == cOpportunityTargetTypeBase)
         {   
            if (kbHasPlayerLost(baseOwner) == true)
              instance = -1.0;
         }       
         if ( (defendingMonopoly == true) && (tradePostID >= 0) && (instance > 0.0))
            instance = instance + ((1.0 - instance)/1.2);   // Bump it almost up to 1.0 if we're defending monopoly and this is a trade site.
         if ( (defendingKOTH == true) && (KOTHID >= 0) && (instance > 0.0))
            instance = instance + ((1.0 - instance)/1.2);   // Bump it almost up to 1.0 if we're defending the hill
         classRating = getClassRating(cOpportunityTypeDefend);   // 0 to 1.0 depending on how long it's been.
         if ( (defendingMonopoly == true) && (tradePostID >= 0) ) 
            classRating = 1.0;      // No time delay for 2nd defend mission if we're defending trading posts during monopoly.
         if (attackingMonopoly == true) 
            classRating = 0.0;   // Don't defend anything if we should be attacking a monopoly!
         if ( (defendingKOTH == true) && (KOTHID >= 0) ) 
            classRating = 1.0;      // No time delay for 2nd defend mission if we're defending the hill.
         if (attackingKOTH == true) 
            classRating = 0.0;   // Don't defend anything if we should be attacking the hill!
         break;    
      }
      case cOpportunityTypeRescueExplorer:
      {
         break;
      }
      default:
      {
         aiEcho("ERROR ERROR ERROR ERROR");
         aiEcho("scoreOpportunity() failed on opportunity "+oppID);
         aiEcho("Opportunity Type is "+oppType+" (invalid)");
         break;
      }
   }
   
   score = classRating * instance * affordable;
// aiEcho("Class "+classRating+", Instance "+instance+", affordable "+affordable);
// aiEcho("Final Score: "+score);
   
   if (score > 1.0)
      score = 1.0;
   if (score < 0.0)
      score = 0.0;
      
   score = score + source; // Add 1 if from ally, 2 if from trigger.
   
   if (permission > source)
      score = -1.0;
   if (errorFound == true)
      score = -1.0;
   if (cvOkToSelectMissions == false)
      score = -1.0;
   aiSetOpportunityScore(oppID, permission, affordable, classRating, instance, score);
}


//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
// Personality and chats
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================



rule introChat    // Send a greeting to allies and enemies
inactive
group startup
minInterval 1
{
   xsDisableSelf();
   sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIntro); 
   sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyIntro);
}



rule IKnowWhereYouLive  // Send a menacing chat when we discover the enemy player's location
inactive
group startup
minInterval 5
{
   static int targetPlayer = -1;
   
   if (targetPlayer < 0)
   {
      targetPlayer = getEnemyPlayerByTeamPosition(getTeamPosition(cMyID));    // Corresponding player on other team
      if (targetPlayer < 0)
      {
         xsDisableSelf();
         aiEcho("No corresponding player on other team, IKnowWhereYouLive is deactivating.");
         aiEcho("My team position is "+getTeamPosition(cMyID));
         return;
      }
      aiEcho("Rule IKnowWhereYouLive will threaten player #"+targetPlayer); 
   }
   
   if (kbUnitCount(targetPlayer, cUnitTypeTownCenter, cUnitStateAlive) > 0) 
   {  // We see his TC for the first time
      int tc = getUnit(cUnitTypeTownCenter, targetPlayer, cUnitStateAlive);
      if ( tc >= 0)
      {
         if ( getUnitByLocation(cUnitTypeUnit, cMyID, cUnitStateAlive, kbUnitGetPosition(tc), 50.0) >= 0 )
         {  // I have a unit nearby, presumably I have LOS.
            sendStatement(targetPlayer, cAICommPromptToEnemyISpotHisTC, kbUnitGetPosition(tc));             
            aiEcho("Rule IKnowWhereYouLive is threatening player #"+targetPlayer);
         }
      }
      xsDisableSelf();
   }
   if (kbUnitCount(targetPlayer, cUnitTypeWallConnector, cUnitStateAlive) > 0) 
   {  // We see his wall for the first time
      int wallID = getUnit(cUnitTypeWallConnector, targetPlayer, cUnitStateAlive);
      if ( wallID >= 0)
      {
         if ( getUnitByLocation(cUnitTypeUnit, cMyID, cUnitStateAlive, kbUnitGetPosition(wallID), 50.0) >= 0 )
         {  // I have a unit nearby, presumably I have LOS.
            sendStatement(targetPlayer, cAICommPromptToEnemyWhenHeWallsIn, kbUnitGetPosition(wallID));             
            aiEcho("Rule IKnowWhereYouLive is threatening player #"+targetPlayer);
         }
      }
      xsDisableSelf();
   }
}


rule tcChats
inactive
group tcComplete
minInterval 15
{  // Send chats about enemy TC placement
   static int tcID1 = -1;  // First enemy TC
   static int tcID2 = -1;  // Second
   static int enemy1 = -1; // ID of owner of first enemy TC.
   static int enemy2 = -1; // Second.
   static int secondTCQuery = -1;
   
   if (tcID1 < 0)
   {  // Look for first enemy TC
      tcID1 = getUnit(cUnitTypeTownCenter, cPlayerRelationEnemy, cUnitStateAlive);
      if (tcID1 >= 0)
         enemy1 = kbUnitGetPlayerID(tcID1);
      return;  // Done for now
   }
   
   // If we get here, we already know about one enemy TC.  Now, find the next closest enemy TC.
   if (secondTCQuery < 0)
   {  //init - find all enemy TC's within 200 meters of first one.
      secondTCQuery = kbUnitQueryCreate("Second enemy TC");
   }
   kbUnitQuerySetPlayerRelation(secondTCQuery, cPlayerRelationEnemy);
   kbUnitQuerySetUnitType(secondTCQuery, cUnitTypeTownCenter);
   kbUnitQuerySetState(secondTCQuery, cUnitStateAlive);
   kbUnitQuerySetPosition(secondTCQuery, kbUnitGetPosition(tcID1));
   kbUnitQuerySetMaximumDistance(secondTCQuery, 500.0);

   kbUnitQueryResetResults(secondTCQuery);
   int tcCount = kbUnitQueryExecute(secondTCQuery);
   if (tcCount > 1)  // Found another enemy TC
   {
      tcID2 = kbUnitQueryGetResult(secondTCQuery, 1); // Second unit in list
      enemy2 = kbUnitGetPlayerID(tcID2);
   }
   
   if (tcID2 < 0)
      return;
   
   // We have two TCs.  See if we have a unit in range.  If so, send a taunt if appropriate.  Either way, shut the rule off.
   xsDisableSelf();
   
   if (enemy1 == enemy2)
      return;  // Makes no sense to taunt if the same player owns both...
   
   bool haveLOS = false;
   if (getUnitByLocation(cUnitTypeUnit, cMyID, cUnitStateAlive, kbUnitGetPosition(tcID1), 50.0) >= 0)
      haveLOS = true;
   if (getUnitByLocation(cUnitTypeUnit, cMyID, cUnitStateAlive, kbUnitGetPosition(tcID2), 50.0) >= 0)
      haveLOS = true;
   
   if (haveLOS == true)
   {
      float d = distance(kbUnitGetPosition(tcID1), kbUnitGetPosition(tcID2));
      if (d < 100.0)
      {  // Close together.  Taunt the two, flaring the other's bases.
         aiEcho("Enemy TCs are "+d+" meters apart.  Taunting for closeness.");
         sendStatement(enemy1, cAICommPromptToEnemyHisTCNearAlly, kbUnitGetPosition(tcID2)); // Taunt enemy 1 about enemy 2's TC
         sendStatement(enemy2, cAICommPromptToEnemyHisTCNearAlly, kbUnitGetPosition(tcID1)); // Taunt enemy 2 about enemy 1's TC
      }
      if (d > 200.0)
      {  // Far apart.  Taunt.
         aiEcho("Enemy TCs are "+d+" meters apart.  Taunting for isolation.");
         sendStatement(enemy1, cAICommPromptToEnemyHisTCIsolated, kbUnitGetPosition(tcID2)); // Taunt enemy 1 about enemy 2's TC
         sendStatement(enemy2, cAICommPromptToEnemyHisTCIsolated, kbUnitGetPosition(tcID1)); // Taunt enemy 2 about enemy 1's TC         
      }
      aiEcho("Enemy TCs are "+d+" meters apart.");
   }  // Otherwise, rule is turned off, we missed our chance.   
   else
   {
      aiEcho("Had no LOS to enemy TCs");
   }
}


rule monitorScores
inactive
minInterval 60
group tcComplete
{
   static int startingScores = -1;  // Array holding initial scores for each player
   static int highScores = -1;      // Array, each player's high-score mark
   static int teamScores = -1;
   int player = -1;
   int teamSize = 0;
   int myTeam = kbGetPlayerTeam(cMyID);
   int enemyTeam = -1;
   int highAllyScore = -1;
   int highAllyPlayer = -1;
   int highEnemyScore = -1;
   int highEnemyPlayer = -1;
   int score = -1;
   int firstHumanAlly = -1;
   
   if (aiGetGameType() != cGameTypeRandom)
   {
      xsDisableSelf();
      return;
   }
   
   if (highScores < 0)
   {
      highScores = xsArrayCreateInt(cNumberPlayers, 1, "High Scores");   // create array, init below.
   }
   if (startingScores < 0)
   {
      if (aiGetNumberTeams() != 3)  // Gaia, plus two
      {
         // Only do this if there are two teams with the same number of players on each team.
         xsDisableSelf();
         return;
      }
      startingScores = xsArrayCreateInt(cNumberPlayers, 1, "Starting Scores");   // init array
      for (player = 1; <cNumberPlayers)
      {
         score = aiGetScore(player);            
         aiEcho("Starting score for player "+player+" is "+score);
         xsArraySetInt(startingScores, player, score);
         xsArraySetInt(highScores, player, 0);     // High scores will track score actual - starting score, to handle deathmatch better.
      }
   }
   
   teamSize = 0;
   for (player = 1; <cNumberPlayers)
   {
      if (kbGetPlayerTeam(player) == myTeam)
      {
         teamSize = teamSize + 1;
         if ( (kbIsPlayerHuman(player) == true) && (firstHumanAlly < 1) )
            firstHumanAlly = player;
      }
      else
         enemyTeam = kbGetPlayerTeam(player);   // Don't know if team numbers are 0..1 or 1..2, this works either way.
   }

   if ( (2 * teamSize) != (cNumberPlayers - 1) )   // Teams aren't equal size
   {
      xsDisableSelf();
      return;
   }
      
   // If we got this far, there are two teams and each has 'teamSize' players.  Otherwise, rule turns off.
   if (teamScores < 0)
   {
      teamScores = xsArrayCreateInt(3, 0, "Team total scores");
   }
  
   if (firstHumanAlly < 0) // No point if we don't have a human ally.
   {
      xsDisableSelf();
      return;
   }
   
   // Update team totals, check for new high scores
   xsArraySetInt(teamScores, myTeam, 0);
   xsArraySetInt(teamScores, enemyTeam, 0);
   highAllyScore = -1;
   highEnemyScore = -1;
   highAllyPlayer = -1;
   highEnemyPlayer = -1;
   int lowestRemainingScore = 100000;   // Very high, will be reset by first real score 
   int lowestRemainingPlayer = -1;
   int highestScore = -1;
   int highestPlayer = -1;
   
   for (player = 1; <cNumberPlayers)
   {
      score = aiGetScore(player) - xsArrayGetInt(startingScores, player);  // Actual score relative to initial score
      if (kbHasPlayerLost(player) == true)
         continue;
      if (score < lowestRemainingScore)
      {
         lowestRemainingScore = score;
         lowestRemainingPlayer = player;
      }
      if (score > highestScore)
      {
         highestScore = score;
         highestPlayer = player;
      }
      if (score > xsArrayGetInt(highScores, player) )   
         xsArraySetInt(highScores, player, score);   // Set personal high score
      if (kbGetPlayerTeam(player) == myTeam)    // Update team scores, check for highs
      {
         xsArraySetInt(teamScores, myTeam, xsArrayGetInt(teamScores, myTeam) + score);
         if (score > highAllyScore)
         {
            highAllyScore = score;
            highAllyPlayer = player;
         }
      }
      else
      {
         xsArraySetInt(teamScores, enemyTeam, xsArrayGetInt(teamScores, enemyTeam) + score);
         if (score > highEnemyScore)
         {
            highEnemyScore = score;
            highEnemyPlayer = player;
         }
      }
   }

   // Bools used to indicate chat usage, prevent re-use.
   static bool enemyNearlyDead = false;
   static bool enemyStrong = false;
   static bool losingEnemyStrong = false;
   static bool losingEnemyWeak = false;
   static bool losingAllyStrong = false;
   static bool losingAllyWeak = false;
   static bool winningNormal = false;
   static bool winningAllyStrong = false;
   static bool winningAllyWeak = false;
   
   static int shouldResignCount = 0;   // Set to 1, 2 and 3 as chats are used.
   static int shouldResignLastTime = 420000;   // When did I last suggest resigning?  Consider it again 3 min later.          
                                                   // Defaults to 7 min, so first suggestion won't be until 10 minutes.
   
   // Attempt to fire chats, from most specific to most general.
   // When we chat, mark that one used and exit for now, i.e no more than one chat per rule execution.
   
   // First, check the winning / losing / tie situations.  
   // Bail if earlier than 12 minutes
   if (xsGetTime() < 60*1000*12)
      return;
   
   if (aiTreatyActive() == true)
      return;
   
   bool winning = false;
   bool losing = false;
   float ourAverageScore = (aiGetScore(cMyID) + aiGetScore(firstHumanAlly)) / 2.0;   
   
   if ( xsArrayGetInt(teamScores, myTeam) > (1.20 * xsArrayGetInt(teamScores, enemyTeam)) )
   {  // We are winning
      winning = true;
            
      // Are we winning because my ally rocks?
      if ( (winningAllyStrong == false) && (firstHumanAlly == highestPlayer) )
      {
         winningAllyStrong = true;
         sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreWinningHeIsStronger);
         return;
      }
      
      // Are we winning in spite of my weak ally?
      if ( (winningAllyWeak == false) && (cMyID == highestPlayer) )
      {
         winningAllyWeak = true;
         sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreWinningHeIsWeaker);
         return;
      }     

      // OK, we're winning, but neither of us has high score.
      if (winningNormal == false)
      {
         winningNormal = true;
         sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreWinning);
         return;
      }
   }  // End chats while we're winning.
   
   
   if ( xsArrayGetInt(teamScores, myTeam) < (0.70 * xsArrayGetInt(teamScores, enemyTeam)) )
   {  // We are losing
      losing = true;
      
      // Talk about resigning?
      if ( (shouldResignCount < 3) && ( (xsGetTime() - shouldResignLastTime) > 5*60*1000) )  // Haven't done it 3 times or within 5 minutes
      {
         switch(shouldResignCount)
         {
            case 0:
            {
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeShouldResign1);
               break;
            }
            case 1:
            {
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeShouldResign2);
               break;
            }
            case 2:
            {
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeShouldResign3);
               break;
            }
         }
         shouldResignCount = shouldResignCount + 1;
         shouldResignLastTime = xsGetTime();
         return;
      }  // End resign
      
      // Check for "we are losing but let's kill the weakling"
      if ( (losingEnemyWeak == false) && (kbIsPlayerEnemy(lowestRemainingPlayer) == true) )
      {
         switch(kbGetCivForPlayer(lowestRemainingPlayer))
         {
            case cCivRussians:
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakRussian);
               return;  
               break;
            }
            case cCivFrench:
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakFrench);
               return;
               break;
            }
            case cCivGermans:
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakGerman);
               return;  
               break;
            }
            case cCivBritish:
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakBritish);
               return;
               break;
            }
            case cCivSpanish:
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakSpanish);
               return;  
               break;
            }
            case cCivDutch:
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakDutch);
               return;
               break;
            }
            case cCivPortuguese:
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakPortuguese);
               return;  
               break;
            }
            case cCivOttomans:
            {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakOttoman);
               return;
               break;
            }
            case cCivJapanese:
            {
              if (civIsAsian() == true) {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakJapanese);
               return;
               break;
              }
            }
            case cCivChinese:
            {
              if (civIsAsian() == true) {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakChinese);
               return;
               break;
              }
            }
            case cCivIndians:
            {
              if (civIsAsian() == true) {
               losingEnemyWeak = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakIndian);
               return;
               break;
              }
            }

         }
      }
      
      // Check for losing while enemy player has high score.
      if ( (losingEnemyStrong == false) && (kbIsPlayerEnemy(highestPlayer) == true) )
      {
         switch(kbGetCivForPlayer(highestPlayer))
         {
            case cCivRussians:
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongRussian);
               return;  
               break;
            }
            case cCivFrench:
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongFrench);
               return;
               break;
            }
            case cCivGermans:
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongGerman);
               return;  
               break;
            }
            case cCivBritish:
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongBritish);
               return;
               break;
            }
            case cCivSpanish:
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongSpanish);
               return;  
               break;
            }
            case cCivDutch:
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongDutch);
               return;
               break;
            }
            case cCivPortuguese:
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongPortuguese);
               return;  
               break;
            }
            case cCivOttomans:
            {
               losingEnemyStrong = true; // chat used.
               sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongOttoman);
               return;
               break;
            }
            case cCivJapanese:
              {
                if (civIsAsian() == true) {
                 losingEnemyStrong = true; // chat used.
                 sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongJapanese);
                 return;
                 break;
                }
              }
              case cCivChinese:
              {
                if (civIsAsian() == true) {
                 losingEnemyStrong = true; // chat used.
                 sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongChinese);
                 return;
                 break;
                }
              }
              case cCivIndians:
              {
                if (civIsAsian() == true) {
                 losingEnemyStrong = true; // chat used.
                 sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongIndian);
                 return;
                 break;
                }
              }
         }
      }
      
      // If we're here, we're losing but our team has the high score.  If it's my ally, we're losing because I suck.
      if ( (losingAllyStrong == false) && (firstHumanAlly == highestPlayer) )
      {
         losingAllyStrong = true;
         sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingHeIsStronger);
         return;
      }
      if ( (losingAllyWeak == false) && (cMyID == highestPlayer) )
      {
         losingAllyWeak = true;
         sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingHeIsWeaker);
         return;
      }      
   }  // End chats while we're losing.
   
   if ( (winning == false) && (losing == false) )
   {  // Close game
      
      // Check for a near-death enemy
      if ( (enemyNearlyDead == false) && (kbIsPlayerEnemy(lowestRemainingPlayer) == true) )// Haven't used this chat yet
      {
         if ( (lowestRemainingScore * 2) < xsArrayGetInt(highScores, lowestRemainingPlayer) )   // He's down to half his high score.
         {
            switch(kbGetCivForPlayer(lowestRemainingPlayer))
            {
               case cCivRussians:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadRussian);
                  return;  
                  break;
               }
               case cCivFrench:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadFrench);
                  return;
                  break;
               }
               case cCivBritish:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadBritish);
                  return;
                  break;
               }
               case cCivSpanish:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadSpanish);
                  return;
                  break;
               }
               case cCivGermans:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadGerman);
                  return;
                  break;
               }
               case cCivOttomans:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadOttoman);
                  return;
                  break;
               }
               case cCivDutch:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadDutch);
                  return;
                  break;
               }
               case cCivPortuguese:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadPortuguese);
                  return;
                  break;
               }
               case cCivJapanese:
                {
                  if (civIsAsian() == true) {
                   enemyNearlyDead = true; // chat used.
                   sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadJapanese);
                   return;
                   break;
                  }
                }
                case cCivChinese:
                {
                  if (civIsAsian() == true) {
                   enemyNearlyDead = true; // chat used.
                   sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadChinese);
                   return;
                   break;
                  }
                }
                case cCivIndians:
                {
                  if (civIsAsian() == true) {
                   enemyNearlyDead = true; // chat used.
                   sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadIndian);
                   return;
                   break;
                  }
                }
            }
         }
      }
      
      // Check for very strong enemy
      if ( (enemyStrong == false) && (kbIsPlayerEnemy(highestPlayer) == true) )
      {
         if ( (ourAverageScore * 1.5) < highestScore) 
         {  // Enemy has high score, it's at least 50% above our average.
            switch(kbGetCivForPlayer(highestPlayer))
            {
               case cCivRussians:
               {
                  enemyStrong = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongRussian);
                  return;  
                  break;
               }
               case cCivFrench:
               {
                  enemyStrong = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongFrench);
                  return;
                  break;
               }
               case cCivBritish:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongBritish);
                  return;
                  break;
               }
               case cCivSpanish:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongSpanish);
                  return;
                  break;
               }
               case cCivGermans:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongGerman);
                  return;
                  break;
               }
               case cCivOttomans:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongOttoman);
                  return;
                  break;
               }
               case cCivDutch:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongDutch);
                  return;
                  break;
               }
               case cCivPortuguese:
               {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongPortuguese);
                  return;
                  break;
               }
               case cCivJapanese:
               {
                 if (civIsAsian() == true) {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongJapanese);
                  return;
                  break;
                 }
               }
               case cCivChinese:
               {
                 if (civIsAsian() == true) {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongChinese);
                  return;
                  break;
                 }
               }
               case cCivIndians:
               {
                 if (civIsAsian() == true) {
                  enemyNearlyDead = true; // chat used.
                  sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongIndian);
                  return;
                  break;
                 }
               }
            }
         }
      }        
   }  // End chats for close game 
}


rule firstEnemyUnitSpotted
inactive
group startup
minInterval 5
{
   static int targetPlayer = -1;
   
   if (targetPlayer < 0)
   {
      targetPlayer = getEnemyPlayerByTeamPosition(getTeamPosition(cMyID));    // Corresponding player on other team
      if (targetPlayer < 0)
      {
         xsDisableSelf();
         aiEcho("No corresponding player on other team, firstEnemyUnitSpotted is deactivating.");
         aiEcho("    My team position is "+getTeamPosition(cMyID));
         return;
      }
      aiEcho("Rule firstEnemyUnitSpotted will watch for player #"+targetPlayer); 
   }
   
   if (kbUnitCount(targetPlayer, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive) > 0) 
   {  // We see one of this player's units for the first time...let's do some analysis on it
      int unitID = getUnit(cUnitTypeLogicalTypeLandMilitary, targetPlayer, cUnitStateAlive); // Get the (or one of the) enemy units
      if (unitID < 0)
      {
         aiEcho("kbUnitCount said there are enemies, but getUnit finds nothing.");
         return;
      }
      
      aiEcho("Enemy unit spotted at "+kbUnitGetPosition(unitID));
      aiEcho("My base is at "+kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiEcho("Distance is "+distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), kbUnitGetPosition(unitID)));
      aiEcho("Unit ID is "+unitID);
      // Three tests in priority order....anything near my town, an explorer anywhere, or default.
      // In my town?
      if ( distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), kbUnitGetPosition(unitID)) < 40.0 )
      {
         sendStatement(targetPlayer, cAICommPromptToEnemyISeeHisFirstMilitaryMyTown, kbUnitGetPosition(unitID));
         aiEcho("Spotted a unit near my town, so I'm threatening player #"+targetPlayer);
         xsDisableSelf();         
         return;
      }
      // Is it an explorer?
      if ( kbUnitIsType(unitID, cUnitTypeExplorer) == true )
      {
         sendStatement(targetPlayer, cAICommPromptToEnemyISeeHisExplorerFirstTime, kbUnitGetPosition(unitID));
         aiEcho("Spotted an enemy explorer, so I'm threatening player #"+targetPlayer);
         xsDisableSelf();         
         return;
      }
      // Generic
      if (getUnitByLocation(cUnitTypeTownCenter, cPlayerRelationAny, cUnitStateAlive, kbUnitGetPosition(unitID), 70.0) < 0)   
      {  // No TCs nearby
         sendStatement(targetPlayer, cAICommPromptToEnemyISeeHisFirstMilitary, kbUnitGetPosition(unitID));
         aiEcho("Spotted an enemy military unit for the first time, so I'm threatening player #"+targetPlayer);
      }
      xsDisableSelf();         
      return;
   }
}

//==============================================================================
// main
//==============================================================================
void main(void)
{ 
   aiEcho("Main is starting.");
   aiEcho("Game type is "+aiGetGameType()+", 0=Scn, 1=Saved, 2=Rand, 3=GC, 4=Cmpgn");
   aiEcho("Map name is "+cRandomMapName);
   
   ////////////////Introduction////////////////
   int Player = -1; 
   int firstNonHumanplayer = -1;

   for (Player = 1; <cNumberPlayers)
   {
      if (kbIsPlayerHuman(Player) == false) 
      {
        firstNonHumanplayer = Player;
        break;
      }
   }
   if (cMyID == firstNonHumanplayer )
   {
      for (Player = 1; <cNumberPlayers)
      {  
         aiChat(Player, "This is a modification based on Felix Hermansson's Drauger AI, but has varied improvements.");           
      }
   }
   ////////////////Introduction////////////////

   initArrays();              // Create the global arrays
   aiRandSetSeed(-1);         // Set our random seed.  "-1" is a random init.
   kbAreaCalculate();         // Analyze the map, create area matrix
   aiPopulatePoliticianList(); // Fill out the PoliticanLists.
   
   if ( (aiGetGameType() == cGameTypeCampaign) || (aiGetGameType() == cGameTypeScenario) )
      gSPC = true;
   else
      gSPC = false;  // RM game

   int intDifficulty = -1;
   float difficulty = aiGetWorldDifficulty();
   float diffRemainder = -1.0;
   intDifficulty = difficulty;
   diffRemainder = difficulty - intDifficulty;
   
   // Call the rule once as a function, to get all the pop limits set up.
   popManager();     
   
   aiEcho("I see "+kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag)+" water flags.");

   //-- setup the handicaps.
   // baseLineHandicap is a global multiplier that we can use to adjust all up or down.  Probably will remain at 1.0.
   // startingHandicap is the handicap set at game launch in the UI, i.e. boost this player 10% == 1.10.  That needs to be
   // multiplied by the appropriate difficulty for each level.
   float startingHandicap = kbGetPlayerHandicap(cMyID);
   switch(intDifficulty)
   {
	case cDifficultySandbox: // Sandbox
	{
	   kbSetPlayerHandicap( cMyID, startingHandicap * baselineHandicap * 0.3 );    // Set handicap to a small fraction of baseline, i.e. minus 70%.
           gDelayAttacks = true;      // Prevent attacks...actually stays that way, never turns true.
           cvOkToBuildForts = false;
 	   break;
	}
	case cDifficultyEasy: // Easiest
	{
           if (gSPC == true)
              kbSetPlayerHandicap( cMyID, startingHandicap * baselineHandicap * 0.5 ); // minus 50 percent for scenarios
           else
              kbSetPlayerHandicap( cMyID, startingHandicap * baselineHandicap * 0.4 ); // minus 60 percent
            
           gDelayAttacks = true;
           cvOkToBuildForts = false;
           xsEnableRule("delayAttackMonitor");    // Wait until I am attacked, then let slip the hounds of war.
	   break;
	}
	case cDifficultyModerate: // Moderate
	{
           if (gSPC == true)
              kbSetPlayerHandicap( cMyID, startingHandicap * baselineHandicap * 0.75 ); // minus 25% for scenarios
           else
              kbSetPlayerHandicap( cMyID, startingHandicap * baselineHandicap * 0.65 ); // minus 35%
	   break;
	}
	case cDifficultyHard: // Hard
	{
	   kbSetPlayerHandicap( cMyID, startingHandicap * baselineHandicap * 1.0 );    // 1.0 handicap at hard, i.e. no bonus
	   break;
	}
	case cDifficultyExpert: // Expert
	{
           kbSetPlayerHandicap( cMyID, startingHandicap * baselineHandicap * 1.5 );    // +50% boost.
           break;
	}
   }
   aiEcho("Handicap is "+kbGetPlayerHandicap(cMyID));
   aiEcho("Difficulty is "+aiGetWorldDifficulty());

   // Do some overrides for the SPC/campaign games before the loader file wakes up.
   SPCInit();

   // Find out what our personality is, init variables from it.
   initPersonality(); 
   
   // Allow loader file to change default values before we start.
   preInit();
   if (cvInactiveAI == true)
   {
      cvOkToSelectMissions = false;
      cvOkToTrainArmy = false;
      cvOkToAllyNatives = false;
      cvOkToClaimTrade = false;
      cvOkToGatherFood = false;
      cvOkToGatherGold = false;
      cvOkToGatherWood = false;
      cvOkToExplore = false;
      cvOkToResign  = false;
      cvOkToAttack = false;
   }
   
   // Figure out the starting conditions, and deal with them.
   if (gSPC == true)
   {     
      aiEcho("Start mode:  Scenario, details TBD after aiStart object is found.");
		// Wait for the aiStart unit to appear, then figure out what to do.
		// That rule will have to set the start mode to ScenarioTC or ScenarioNoTC.
      xsEnableRule("waitForStartup");     
   }
   else
   {  
      // RM or GC game
	aiSetRandomMap(true);
      // Check for a TC.
		if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) > 0) 
      {  
			// TC start
         aiEcho("Start mode:  Land TC");
         gStartMode = cStartModeLandTC;
         // Call init directly.
			init();
      }
      else 
      {
         // Check for a Boat.
			if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) > 0) 
         {
            gStartMode = cStartModeBoat;
            aiEcho("Start mode: Boat");
            // Needed for first transport unloading 
	    aiSetHandler("transportArrive", cXSHomeCityTransportArriveHandler);	

            // Rule that fires after 30 seconds in case
	    // something goes wrong with unloading
	    xsEnableRule("transportArriveFailsafe");	
         }
         else
         {  
	    // This must be a land nomad start
            aiEcho("Start mode:  Land Wagon");
            gStartMode = cStartModeLandWagon;  
            // Call the function that sets up explore plans, etc.
	    transportArrive();
         }
      }
   }

	//-- set the default Resource Selector factor.
	kbSetTargetSelectorFactor(cTSFactorDistance, gTSFactorDistance);
	kbSetTargetSelectorFactor(cTSFactorPoint, gTSFactorPoint);
	kbSetTargetSelectorFactor(cTSFactorTimeToDone, gTSFactorTimeToDone);
	kbSetTargetSelectorFactor(cTSFactorBase, gTSFactorBase);
	kbSetTargetSelectorFactor(cTSFactorDanger, gTSFactorDanger);
   
   xsEnableRule("autoSave");
   // Trigger first autosave immediately
	autoSave(); 
 
   // postInit() is called by transportArrive() or by the waitForStartup rule.
}



rule waitForStartup
inactive
minInterval 1
{
   if (kbUnitCount(cMyID, cUnitTypeAIStart, cUnitStateAny) < 1)
      return;
   xsDisableSelf();
   
   if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) > 0)
   {
      aiEcho("Start mode:  Scenario TC.");
      gStartMode = cStartModeScenarioTC;
   }
   else
   {
      if (kbUnitCount(cMyID, gCoveredWagonUnit, cUnitStateAlive) > 0)
      {
         aiEcho("Start mode:  Scenario wagon.");
         gStartMode = cStartModeScenarioWagon;
      }
      else
      {
         aiEcho("Start mode:  Scenario, no TC.");
         gStartMode = cStartModeScenarioNoTC;
      }
   }
   if (cvInactiveAI == false)
      transportArrive();
}

void testHandler(int parm=-1)
{
   aiEcho("StateChanged EventHandlerCalled with PlanID " + parm);
}


//==============================================================================
// RULE fillInWallGaps
//==============================================================================

rule fillInWallGaps
minInterval 31
inactive
{
   int i=0;

   while(i<3)
   {
      //If we're not building walls, go away.
      if (gBuildWalls == false)
      {
         xsDisableSelf();
         return;
      }

      //If we already have a build wall plan, don't make another one.
      if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
         return;

      int wallPlanID=aiPlanCreate("FillInWallGaps", cPlanBuildWall);
      if (wallPlanID != -1)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         //aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 80.0+20*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 20+20*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
         i++;
      }
   }
}

/*
rule fillInWallGapss
minInterval 30
inactive
{
   
      //If we're not building walls, go away.
      if (gBuildWalls == false)
    {
         xsDisableSelf();
         return;
    }

      //If we already have a build wall plan, don't make another one.
      if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
         return;

      int wallPlanID=aiPlanCreate("FillInWallGaps", cPlanBuildWall);
      if (wallPlanID != -1)
	{
	
	  	if  (kbGetAge() == cAge5)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 120.0);//+9*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 12);//*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
   
	  	  if  (kbGetAge() == cAge5)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 100.0);//+9*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 10);//*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }

	  	  if  (kbGetAge() == cAge5)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 80.0);//+9*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 8);//*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
	  
	  	  if  (kbGetAge() == cAge5)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0,60.0);//+9*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 6);//*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
	  
	  	  if  (kbGetAge() == cAge5)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0,26.0);//+9*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 2);//*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
	  	  if  (kbGetAge() == cAge5)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypePlantation, cMyID, cUnitStateAlive)));
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeFarm, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0,20.0);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 2);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
	}
}


rule fillInWallGaps1
minInterval 31
inactive
{
   int i=0;

   while(i<3)
   {
      //If we're not building walls, go away.
      if (gBuildWalls == false)
      {
         xsDisableSelf();
         return;
      }

      //If we already have a build wall plan, don't make another one.
      if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
         return;

      int wallPlanID=aiPlanCreate("FillInWallGaps", cPlanBuildWall);
      if (wallPlanID != -1)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 120.0);//+9*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 12);//*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
   }
}

rule fillInWallGaps2
minInterval 31
inactive
{
   int i=0;

   while(i<3)
   {
      //If we're not building walls, go away.
      if (gBuildWalls == false)
      {
         xsDisableSelf();
         return;
      }

      //If we already have a build wall plan, don't make another one.
      if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
         return;

      int wallPlanID=aiPlanCreate("FillInWallGaps", cPlanBuildWall);
      if (wallPlanID != -1)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 100.0);//+9*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 10);//*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
   }
}

rule fillInWallGaps3
minInterval 31
inactive
{
   int i=0;

   while(i<3)
   {
      //If we're not building walls, go away.
      if (gBuildWalls == false)
      {
         xsDisableSelf();
         return;
      }

      //If we already have a build wall plan, don't make another one.
      if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
         return;

      int wallPlanID=aiPlanCreate("FillInWallGaps", cPlanBuildWall);
      if (wallPlanID != -1)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, 80.0);//+9*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 8);//*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
   }
}

rule fillInWallGaps4
minInterval 31
inactive
{
   int i=0;

   while(i<3)
   {
      //If we're not building walls, go away.
      if (gBuildWalls == false)
      {
         xsDisableSelf();
         return;
      }

      //If we already have a build wall plan, don't make another one.
      if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
         return;

      int wallPlanID=aiPlanCreate("FillInWallGaps", cPlanBuildWall);
      if (wallPlanID != -1)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0,60.0);//+9*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 6);//*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
   }
}

rule fillInWallGaps5
minInterval 31
inactive
{
   int i=0;

   while(i<3)
   {
      //If we're not building walls, go away.
      if (gBuildWalls == false)
      {
         xsDisableSelf();
         return;
      }

      //If we already have a build wall plan, don't make another one.
      if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
         return;

      int wallPlanID=aiPlanCreate("FillInWallGaps", cPlanBuildWall);
      if (wallPlanID != -1)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeBuildingsThatShoot, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0,26.0);//+9*i);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 2);//*i);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
   }
}

rule fillInWallGaps6
minInterval 31
inactive
{
   int i=0;

   while(i<3)
   {
      //If we're not building walls, go away.
      if (gBuildWalls == false)
      {
         xsDisableSelf();
         return;
      }

      //If we already have a build wall plan, don't make another one.
      if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
         return;

      int wallPlanID=aiPlanCreate("FillInWallGaps", cPlanBuildWall);
      if (wallPlanID != -1)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypePlantation, cMyID, cUnitStateAlive)));
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(gFarmUnit, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0,20.0);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 2);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
   }
}

rule fillInWallGaps7
minInterval 31
inactive
{
   int i=0;

   while(i<3)
   {
      //If we're not building walls, go away.
      if (gBuildWalls == false)
      {
         xsDisableSelf();
         return;
      }

      //If we already have a build wall plan, don't make another one.
      if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
         return;

      int wallPlanID=aiPlanCreate("FillInWallGaps", cPlanBuildWall);
      if (wallPlanID != -1)
      {
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
         aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 3, 5);
         aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeMilitaryBuilding, cMyID, cUnitStateAlive)));
         aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0,40.0);
         aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 4);
         aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
         aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
         aiPlanSetDesiredPriority(wallPlanID,80);
         aiPlanSetActive(wallPlanID, true);
      }
   }
}
*/
void monopolyStartHandler(int teamID=-1)
{
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("MonopolyStartHandler:  Team "+teamID);
   if (teamID < 0)
      return;
   
   // If this is my team, congratulate teammates and taunt enemies
   if ( kbGetPlayerTeam(cMyID) == teamID)
   {
      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenWeGetMonopoly, cInvalidVector);
      sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyWhenWeGetMonopoly, cInvalidVector);
   }
   else // Otherwise, snide comment to enemies and condolences to partners
   {
      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenEnemiesGetMonopoly, cInvalidVector);
      sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyWhenTheyGetMonopoly, cInvalidVector);
   }      
   gIsMonopolyRunning = true;
   gMonopolyTeam = teamID;
   gMonopolyEndTime = xsGetTime() + 5*60*1000; 
   xsEnableRule("monopolyTimer");
}


void monopolyEndHandler(int teamID=-1)
{
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("MonopolyEndHandler:  Team "+teamID);
   if (teamID < 0)
      return;
   // If this is my team, console partners, and send defiant message to enemies
   if ( kbGetPlayerTeam(cMyID) == teamID)
   {
      sendStatement(cPlayerRelationAlly, cAICommPromptToAllyEnemyDestroyedMonopoly, cInvalidVector);
      sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyTheyDestroyedMonopoly, cInvalidVector);
   }
   else // Otherwise, gloat at enemies
   {
      sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyIDestroyedMonopoly, cInvalidVector);
   }         
   gIsMonopolyRunning = false;
   gMonopolyTeam = -1;
   gMonopolyEndTime = -1;
   xsDisableRule("monopolyTimer");
}

rule monopolyTimer
inactive
minInterval 15
{
   if ((gIsMonopolyRunning == false) || (gMonopolyEndTime < 0))
   {
      xsDisableSelf();
      return;
   }
   if (xsGetTime() > gMonopolyEndTime)
   {
      // If this is my team, congratulate teammates and taunt enemies
      if (kbGetPlayerTeam(cMyID) == gMonopolyTeam)
      {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAlly1MinuteLeftOurMonopoly, cInvalidVector);
         sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemy1MinuteLeftOurMonopoly, cInvalidVector);
      }
      else // Otherwise, snide comment to enemies and panic to partners
      {
         sendStatement(cPlayerRelationAlly, cAICommPromptToAlly1MinuteLeftEnemyMonopoly, cInvalidVector);
         sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemy1MinuteLeftEnemyMonopoly, cInvalidVector);
      }       
      xsDisableSelf();
      return;
   }
}

rule monopolyManager
minInterval 21
inactive
group tcComplete
{
   if (aiTreatyActive() == true)
   {
      aiEcho("Monopoly delayed because treaty is active.");
      return;
   }
   if (aiIsMonopolyAllowed() == false)
   {
      aiEcho("Monopoly not allowed, terminating rule.");
      xsDisableSelf();
   }
   if ( kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) < 1)
      return;     // Not allowed to research without a building...

   if (aiReadyForTradeMonopoly() == true)
   {
      aiEcho("Trade monopoly is available.");
      if (kbResourceGet(cResourceGold) >= kbTechCostPerResource(cTechTradeMonopoly, cResourceGold) && 
          kbResourceGet(cResourceFood) >= kbTechCostPerResource(cTechTradeMonopoly, cResourceFood) &&
          kbResourceGet(cResourceWood) >= kbTechCostPerResource(cTechTradeMonopoly, cResourceWood))
      {
         aiEcho("Attempting trade monopoly");
         if (aiDoTradeMonopoly() == true)
            kbEscrowAllocateCurrentResources();
      }
      else
      {
         aiEcho("....but I can't afford it.");
      }
   }
}


void KOTHVictoryStartHandler(int teamID=-1)
{
   int newOppID = -1;
   
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("KOTHStartHandler:  Team "+teamID);
   if (teamID < 0)
      return;
      
   gIsKOTHRunning = true;
   gKOTHTeam = teamID;
}


void KOTHVictoryEndHandler(int teamID=-1)
{
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("     ");
   aiEcho("KOTHEndHandler:  Team "+teamID);
   if (teamID < 0)
      return;
      
   gIsKOTHRunning = false;
   gKOTHTeam = -1;
}


//==============================================================================
// New rules for the Draugur AI
//==============================================================================

rule checkEscrow
active
minInterval 30
{ 
   static int failCount = 0;
   static bool initialResetDone = false;

   if (initialResetDone == false)
   {
      initialResetDone = true;
      kbEscrowAllocateCurrentResources();
      return;
   }

   bool fishingReset = false;    // Special reset in first 5 minutes for wood imbalance while fishing
                                 // (Every fishing boat trained gets double-billed.)
   bool needReset = false;
   int res = -1;
   for (res = 0; < 3)
   {
      int escrowQty = -1;
      int actualQty = -1;
      int delta = -1;
      escrowQty = kbEscrowGetAmount(cEconomyEscrowID, res);
      escrowQty = escrowQty + kbEscrowGetAmount(cMilitaryEscrowID, res);
      escrowQty = escrowQty + kbEscrowGetAmount(cRootEscrowID, res);
      actualQty = kbResourceGet(res);
      delta = actualQty - escrowQty;
      if (delta < 0)
          delta = delta * -1;
      if ( (delta > 20) && (delta > actualQty/5) ) // Off by at least 20, and 20%
      {
          needReset = true;
          if (res == cResourceGold)
            aiEcho("Gold imbalance.  Escrow says "+escrowQty+", actual is "+actualQty);
          if (res == cResourceWood)
          {
             //aiEcho("Wood imbalance.  Escrow says "+escrowQty+", actual is "+actualQty);
             if ( (gGoodFishingMap == true) && (xsGetTime()<(8*60*1000)) )
               fishingReset = true; // We're fishing, it's in the first 8 min, and wood is off.
          }
          if (res == cResourceFood)
             aiEcho("Food imbalance.  Escrow says "+escrowQty+", actual is "+actualQty);          
      }
   }
   
   if (fishingReset == true)
   {
      kbEscrowAllocateCurrentResources();
      return;
   }
    
   if (needReset == true)
   {
      failCount = failCount+1;
      if ( (failCount > 5) || ( (failCount > 0) && (xsGetTime() < 30*1000) ) )
      {
         aiEcho("ERROR:  Escrow balances invalid.  Reallocating");
         kbEscrowAllocateCurrentResources();
      }
   }
    else
        failCount = 0;

   float goldSupply = kbResourceGet(cResourceGold);
   float woodSupply = kbResourceGet(cResourceWood);
   float foodSupply = kbResourceGet(cResourceFood);
   
   static int count = 0;


      if  (xsGetTime() > 8*60*1000)
	  {
      kbEscrowFlush(cMilitaryEscrowID, cResourceWood, true);
      kbEscrowFlush(cMilitaryEscrowID, cResourceGold, true);
      kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
	  
		  kbEscrowFlush(cEconomyEscrowID, cResourceFood, true);
		  kbEscrowFlush(cEconomyEscrowID, cResourceWood, true); 
		  kbEscrowFlush(cEconomyEscrowID, cResourceGold, true);
		  }/*
		  
	  
	      if (((xsGetTime() > 15*60*1000) && (kbGetAge() < 3)) || ((xsGetTime() > 20*60*1000) && (kbGetAge() < 4)) || ((xsGetTime() > 25*60*1000) && (kbGetAge() < 3))) 
		  {
		  kbEscrowFlush(cEconomyEscrowID, cResourceFood, false);
		  kbEscrowFlush(cEconomyEscrowID, cResourceWood, false); 
		  kbEscrowFlush(cEconomyEscrowID, cResourceGold, false);
		  }
		  else
		  if ((cMyCiv == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)))
		  {
		  kbEscrowFlush(cEconomyEscrowID, cResourceFood, false);
		  kbEscrowFlush(cEconomyEscrowID, cResourceWood, false); 
		  kbEscrowFlush(cEconomyEscrowID, cResourceGold, true);
		  }
		  //else
		  //kbEscrowFlush(cEconomyEscrowID, cResourceFood, true);
		  //kbEscrowFlush(cEconomyEscrowID, cResourceWood, true); 
		  //kbEscrowFlush(cEconomyEscrowID, cResourceGold, true);
		  
	  

   if (foodSupply < 90)
   {
      kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
      aiEcho("Flushing military food escrow");
      if (kbUnitCount(cMyID, gMarketUnit, cUnitStateAlive) > 0)
      {
         if ((aiGetMarketBuyCost(cResourceFood) < goldSupply) && (count > 0))
         {
            aiBuyResourceOnMarket(cResourceFood);
            aiEcho("Food supply below 90, buying food.");
            count = 0;
         }
         else
           count = count + 1;
      }
   }
   else
   {  count = 0;  }

   
   if ( (kbGetCiv() == cCivDutch) && (woodSupply > 1000) && (foodSupply > 1000) )
   {
      kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);      
      kbEscrowFlush(cEconomyEscrowID, cResourceFood, true);      
      aiEcho("Flushing wood and food escrow");
   }      

		if ((xsGetTime() < 10*60*1000) && (kbGetAge() < 3)) || ((xsGetTime() < 15*60*1000) && (kbGetAge() < 4)) ||
		((xsGetTime() < 20*60*1000) && (kbGetAge() < 5)) || (kbGetAge() == 5))
		{
		
   if (foodSupply > 200)
   {
      kbEscrowFlush(cEconomyEscrowID, cResourceFood, true);
   }
   
   if (goldSupply > 200) 
   {
      kbEscrowFlush(cEconomyEscrowID, cResourceGold, true);
   }
   
   if (woodSupply > 200) 
   {
      kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);
   }
      aiEcho("Flushing military wood, food and gold escrow");
	  
   }
   else
   {
   if (foodSupply > 2000)
   {
      kbEscrowFlush(cEconomyEscrowID, cResourceFood, true);
   }
   
   if (goldSupply > 2000) 
   {
      kbEscrowFlush(cEconomyEscrowID, cResourceGold, true);
   }
   
   if (woodSupply > 2000) 
   {
      kbEscrowFlush(cEconomyEscrowID, cResourceWood, true);
   }
      aiEcho("Flushing military wood, food and gold escrow");
	  
   }
   
   
   if (woodSupply > 2000)
   {
      kbEscrowFlush(cMilitaryEscrowID, cResourceWood, true);
      aiEcho("Flushing military wood and gold escrow");
   }
   
   if (goldSupply > 2000)
   {
      kbEscrowFlush(cMilitaryEscrowID, cResourceGold, true);
      aiEcho("Flushing military wood and gold escrow");
   }
   
   if (foodSupply > 2000)
   {
      kbEscrowFlush(cMilitaryEscrowID, cResourceFood, true);
      aiEcho("Flushing military wood and gold escrow");
   } */ 
} 

//BHG: the AI cannot handle properly
rule idleFishingBoatCheck
minInterval 42
inactive
{   
   //Get a count of fish.
   int fishCount=kbUnitCount(0, cUnitTypeAbstractFish, cUnitStateAlive);
   if (fishCount > 0)
      return;

   //Firstly, create/get our query.
   //Secondly,find a idle fish Boat to delete.
   static int fishingBoatQuery=-1;
   if (fishingBoatQuery < 0)
   {
      fishingBoatQuery=kbUnitQueryCreate("fishingBoat");
      if (fishingBoatQuery == 0)
      {
         xsDisableRule("startFishing");	
         return;
      }
   }
   kbUnitQuerySetPlayerID(fishingBoatQuery, cMyID);
   kbUnitQuerySetUnitType(fishingBoatQuery, gFishingUnit);
   kbUnitQuerySetState(fishingBoatQuery, cUnitStateAlive);
   kbUnitQueryResetResults(fishingBoatQuery);
   int numberFishingBoat = kbUnitQueryExecute(fishingBoatQuery);
   for (i=0; < numberFishingBoat)
   {
       int fishingBoatID=kbUnitQueryGetResult(fishingBoatQuery, i);
       if (aiTaskUnitDelete(fishingBoatID) == true)
          return;
   }
}

rule upgradeWallConnector
inactive
minInterval 30
{
   // Must be setup for wood and Gold before we do any of this.
   if ( (kbResourceGet(cResourceWood) < 400) && (kbResourceGet(cResourceGold) < 600) )
      return;

   if (kbTechGetStatus(cTechBastion) == cTechStatusActive)
   {
      xsDisableSelf();
      return;
   }
   int WallConnector = getUnit(cUnitTypeWallConnector, cMyID, cUnitStateAlive);
   if (WallConnector >= 0)
   {
      createSimpleResearchPlan(cTechBastion,WallConnector,cEconomyEscrowID, 80);
      xsDisableSelf();	
   }

} 

/*
rule priestMonitor
inactive
minInterval 10
{
   static int priestPlan = -1;

   // Create maintain plan (for European only)
   if ((cMyCiv == cCivBritish) || (cMyCiv == cCivFrench) || (cMyCiv == cCivRussians) || (cMyCiv == cCivGermans) || (cMyCiv == cCivDutch) || (cMyCiv == cCivPortuguese))
   {
      if (priestPlan < 0)
      {
         priestPlan = createSimpleMaintainPlan(cUnitTypePriest, 2, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when priest available
   if (kbUnitCount(cMyID, cUnitTypePriest) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}

rule missionaryMonitor
inactive
minInterval 10
{
   static int missionaryPlan = -1;

   // Create maintain plan (for Spanish only)
   if (cMyCiv == cCivSpanish)
   {
      if (missionaryPlan < 0)
      {
         missionaryPlan = createSimpleMaintainPlan(cUnitTypeMissionary, 5, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when missionary available
   if (kbUnitCount(cMyID, cUnitTypeMissionary) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}

rule imamMonitor
inactive
minInterval 10
{
   static int imamPlan = -1;

   // Create maintain plan (for Ottoman only)
   if (cMyCiv == cCivOttomans)
   {
      if (imamPlan < 0)
      {
         imamPlan = createSimpleMaintainPlan(cUnitTypeImam, 2, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when imam available
   if (kbUnitCount(cMyID, cUnitTypeImam) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}
*/

rule envoyMonitor
inactive
minInterval 10
{
   static int envoyPlan = -1;

   // Create maintain plan (for Dutch only)
   if (cMyCiv == cCivDutch)
   {
      if (envoyPlan < 0)
      {
         envoyPlan = createSimpleMaintainPlan(cUnitTypeEnvoy, 1, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when envoy available
   if ((kbUnitCount(cMyID, cUnitTypeEnvoy) == 0) || (cvOkToExplore == false))
   {
      return;
   }

   // Create explore plan
   int envoyExplore = aiPlanCreate("Envoy Explore", cPlanExplore);
   aiPlanSetDesiredPriority(envoyExplore, 99);
   aiPlanAddUnitType(envoyExplore, cUnitTypeEnvoy, 1, 1, 1);
   aiPlanSetEscrowID(envoyExplore, cEconomyEscrowID);
   aiPlanSetBaseID(envoyExplore, kbBaseGetMainID(cMyID));
   aiPlanSetVariableBool(envoyExplore, cExplorePlanDoLoops, 0, false);
   aiPlanSetActive(envoyExplore);

   // Disable rule
   xsDisableSelf();   
}


rule nativeScoutMonitor
inactive
minInterval 10
{
   static int nativeScoutPlan = -1;

   // Create maintain plan (for native only)
   if (civIsNative() == true)
   {
      if (nativeScoutPlan < 0)
      {
         nativeScoutPlan = createSimpleMaintainPlan(cUnitTypeNativeScout, 5, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when native scout available
   if ((kbUnitCount(cMyID, cUnitTypeNativeScout) == 0) || (cvOkToExplore == false))
   {
      return;
   }

   // Create explore plan
   int nativeExplore = aiPlanCreate("Native Explore", cPlanExplore);
   aiPlanSetDesiredPriority(nativeExplore, 99);
   aiPlanAddUnitType(nativeExplore, cUnitTypeNativeScout, 5, 1, 1);
   aiPlanSetEscrowID(nativeExplore, cEconomyEscrowID);
   aiPlanSetBaseID(nativeExplore, kbBaseGetMainID(cMyID));
   aiPlanSetVariableBool(nativeExplore, cExplorePlanDoLoops, 0, false);
   aiPlanSetActive(nativeExplore);

   // Disable rule
   xsDisableSelf();      
}


rule mongolScoutMonitor
inactive
minInterval 10
{
   // Create plan only when mongol scout available
   if ((kbUnitCount(cMyID, cUnitTypeypMongolScout) == 0) || (cvOkToExplore == false))
   {
      return;
   }

   // Create explore plan
   int mongolExplore = aiPlanCreate("Mongol Explore", cPlanExplore);
   aiPlanSetDesiredPriority(mongolExplore, 99);
   aiPlanAddUnitType(mongolExplore, cUnitTypeypMongolScout, 1, 1, 1);
   aiPlanSetEscrowID(mongolExplore, cEconomyEscrowID);
   aiPlanSetBaseID(mongolExplore, kbBaseGetMainID(cMyID));
   aiPlanSetVariableBool(mongolExplore, cExplorePlanDoLoops, 0, false);
   aiPlanSetActive(mongolExplore);

   // Disable rule
   xsDisableSelf();      
}
/*
rule musketeerMonitor
inactive
minInterval 20
{
   static int musketeerPlan = -1;

   // Create maintain plan (for Russians only)
   if (cMyCiv == cCivRussians)
   {
      if (musketeerPlan < 0)
      {
         musketeerPlan = createSimpleMaintainPlan(cUnitTypeMusketeer, 10, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when musketeer available
   if (kbUnitCount(cMyID, cUnitTypeMusketeer) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}

rule grenadierMonitor
inactive
minInterval 10
{
   static int grenadierPlan = -1;

   // Create maintain plan
   if ((cMyCiv == cCivBritish) || (cMyCiv == cCivRussians) || (cMyCiv == cCivOttomans))
   {
      if (grenadierPlan < 0)
      {
         grenadierPlan = createSimpleMaintainPlan(cUnitTypeGrenadier, 8, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when grenadier available
   if (kbUnitCount(cMyID, cUnitTypeGrenadier) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}


rule organgunMonitor
inactive
minInterval 10
{
   static int organgunPlan = -1;

   // Create maintain plan (for Portuguese only)
   if (cMyCiv == cCivPortuguese)
   {
      if (organgunPlan < 0)
      {
         organgunPlan = createSimpleMaintainPlan(cUnitTypeOrganGun, 5, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when organgun available
   if (kbUnitCount(cMyID, cUnitTypeOrganGun) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}

rule oprichnikMonitor
inactive
minInterval 20
{
   static int oprichnikPlan = -1;

   // Create maintain plan (for Russians only)
   if (cMyCiv == cCivRussians)
   {
      if (oprichnikPlan < 0)
      {
         oprichnikPlan = createSimpleMaintainPlan(cUnitTypeOprichnik, 10, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when oprichnik available
   if (kbUnitCount(cMyID, cUnitTypeOprichnik) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}

rule flamethrowerMonitor
inactive
minInterval 10
{
   static int flamethrowerPlan = -1;

   // Create maintain plan (for Chinese only)
   if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) ) 
   {
      if (flamethrowerPlan < 0)
      {
         flamethrowerPlan = createSimpleMaintainPlan(cUnitTypeypFlameThrower, 8, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when flamethrower available
   if (kbUnitCount(cMyID, cUnitTypeypFlameThrower) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}


rule fireshipMonitor
inactive
minInterval 60
{
   static int fireshipPlan = -1;

   // Create maintain plan (for Chinese only)
   if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) ) 
   {
      if (fireshipPlan < 0)
      {
         fireshipPlan = createSimpleMaintainPlan(cUnitTypeypFireship, 10, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when fireship available
   if (kbUnitCount(cMyID, cUnitTypeypFireship) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}
*/

rule daimyoMonitor
inactive
minInterval 10
{
   static int masamunePlan = -1;
   static int kiyomasaPlan = -1;
   static int mototadaPlan = -1;
   static int tokugawaPlan = -1;
      
   // Create maintain plan (for Japanese only)
   if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) ) 
   {
      if (masamunePlan < 0)
      {
         masamunePlan = createSimpleMaintainPlan(cUnitTypeypDaimyoMasamune, 1, false, kbBaseGetMainID(cMyID));
      }
   }
   // Create plan only when masamune available
   if (kbUnitCount(cMyID, cUnitTypeypDaimyoMasamune) == 0)
   {
      return;
   }
   
   // Create maintain plan (for Japanese only)
   if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) ) 
   {
      if (kiyomasaPlan < 0)
      {
         kiyomasaPlan = createSimpleMaintainPlan(cUnitTypeypDaimyoKiyomasa, 1, false, kbBaseGetMainID(cMyID));
      }
   }
   // Create plan only when kiyomasa available
   if (kbUnitCount(cMyID, cUnitTypeypDaimyoKiyomasa) == 0)
   {
      return;
   }
   
   // Create maintain plan (for Japanese only)
   if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) ) 
   {
      if (mototadaPlan < 0)
      {
         mototadaPlan = createSimpleMaintainPlan(cUnitTypeypDaimyoMototada, 1, false, kbBaseGetMainID(cMyID));
      }
   }
   // Create plan only when mototada available
   if (kbUnitCount(cMyID, cUnitTypeypDaimyoMototada) == 0)
   {
      return;
   }

   // Create maintain plan (for Japanese only)
   if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) ) 
   {
      if (tokugawaPlan < 0)
      {
         tokugawaPlan = createSimpleMaintainPlan(cUnitTypeypShogunTokugawa, 1, false, kbBaseGetMainID(cMyID));
      }
   }
   // Create plan only when mototada available
   if (kbUnitCount(cMyID, cUnitTypeypShogunTokugawa) == 0)
   {
      return;
   }   
         
   // Disable rule
   xsDisableSelf();   
}

/*
rule daimyoMasamuneMonitor
inactive
group tcComplete
minInterval 30
{
   if (kbGetCiv() != cCivJapanese)
   {
      xsDisableSelf();
      return;
   }

   if (aiTreatyActive() == true) //Can't attack under treaty!
       return;

   int targetPlayer = aiGetMostHatedPlayerID();
   int unitID = getUnit(cUnitTypeLogicalTypeLandMilitary, targetPlayer, cUnitStateAlive);
   
   //gotta find the masamune
   static int masamuneQuery=-1;
   if (masamuneQuery < 0)
   {
      masamuneQuery=kbUnitQueryCreate("Daimyomasamune");
      if (masamuneQuery < 0)
      {
         xsDisableSelf();
         return;
      }
   }
   kbUnitQuerySetPlayerID(masamuneQuery, cMyID);
   kbUnitQuerySetUnitType(masamuneQuery, cUnitTypeypDaimyoMasamune);
   kbUnitQuerySetState(masamuneQuery, cUnitStateAlive);
   kbUnitQueryResetResults(masamuneQuery);
   int numberFound = kbUnitQueryExecute(masamuneQuery);
   
   for (i=0; < numberFound)
   {      
      int daimyoMasamuneID=kbUnitQueryGetResult(masamuneQuery, i);  

      if (kbUnitGetHealth(daimyoMasamuneID) < 0.3)
      {
        aiTaskUnitMove(daimyoMasamuneID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      }
      else
      {
        if (kbUnitIsType(unitID, cUnitTypeAbstractLightCavalry) == true)
          aiTaskUnitTrain(daimyoMasamuneID, cUnitTypeypAshigaru); 
        else if (kbUnitIsType(unitID, cUnitTypeAbstractHeavyInfantry) == true)
          aiTaskUnitTrain(daimyoMasamuneID, cUnitTypeypYumi);
        else if (kbUnitIsType(unitID, cUnitTypeAbstractHeavyCavalry) == true)
          aiTaskUnitTrain(daimyoMasamuneID, cUnitTypeypYabusame);
        else
          aiTaskUnitTrain(daimyoMasamuneID, cUnitTypeypNaginataRider);
      }     
      // We need to set fast mode
      xsSetRuleMinIntervalSelf(1);
      aiEcho("Going to fast mode.");                                 
      return;
   }   
}

rule daimyoKiyomasaMonitor
inactive
group tcComplete
minInterval 30
{
   if (kbGetCiv() != cCivJapanese)
   {
      xsDisableSelf();
      return;
   }
      
   if (aiTreatyActive() == true) //Can't attack under treaty!
       return;

   int targetPlayer = aiGetMostHatedPlayerID();
   int unitID = getUnit(cUnitTypeLogicalTypeLandMilitary, targetPlayer, cUnitStateAlive);
   
   //gotta find the kiyomasa
   static int kiyomasaQuery=-1;
   if (kiyomasaQuery < 0)
   {
      kiyomasaQuery=kbUnitQueryCreate("Daimyokiyomasa");
      if (kiyomasaQuery < 0)
      {
         xsDisableSelf();
         return;
      }
   }
   kbUnitQuerySetPlayerID(kiyomasaQuery, cMyID);
   kbUnitQuerySetUnitType(kiyomasaQuery, cUnitTypeypDaimyoKiyomasa);
   kbUnitQuerySetState(kiyomasaQuery, cUnitStateAlive);
   kbUnitQueryResetResults(kiyomasaQuery);
   int numberFound = kbUnitQueryExecute(kiyomasaQuery);

   for (i=0; < numberFound)
   {        
      int daimyokiyomasaID=kbUnitQueryGetResult(kiyomasaQuery, i);

      if (kbUnitGetHealth(daimyokiyomasaID) < 0.3)
      {
        aiTaskUnitMove(daimyokiyomasaID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      }
      else
      {  
        if (kbUnitIsType(unitID, cUnitTypeAbstractLightCavalry) == true)
          aiTaskUnitTrain(daimyokiyomasaID, cUnitTypeypAshigaru); 
        else if (kbUnitIsType(unitID, cUnitTypeAbstractHeavyInfantry) == true)
          aiTaskUnitTrain(daimyokiyomasaID, cUnitTypeypYumi);
        else if (kbUnitIsType(unitID, cUnitTypeAbstractHeavyCavalry) == true)
          aiTaskUnitTrain(daimyokiyomasaID, cUnitTypeypYabusame);
        else
          aiTaskUnitTrain(daimyokiyomasaID, cUnitTypeypNaginataRider); 
      }     
      // We need to set fast mode
      xsSetRuleMinIntervalSelf(1);
      aiEcho("Going to fast mode.");                       
      return;
   }   
}

rule daimyoMototadaMonitor
inactive
group tcComplete
minInterval 30
{
   if (kbGetCiv() != cCivJapanese) 
   {
      xsDisableSelf();
      return;
   }
  
   if (aiTreatyActive() == true) //Can't attack under treaty!
       return;

   int targetPlayer = aiGetMostHatedPlayerID();
   int unitID = getUnit(cUnitTypeLogicalTypeLandMilitary, targetPlayer, cUnitStateAlive);
   
   //gotta find the daimyo
   static int daimyoQueryID=-1;
   //If we don't have the query yet, create one.
   if (daimyoQueryID < 0)
   {
      daimyoQueryID=kbUnitQueryCreate("daimyoGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(daimyoQueryID, true);
   }
   //Define a query to get all matching units
   if (daimyoQueryID != -1) 
   {
      kbUnitQuerySetPlayerRelation(daimyoQueryID, -1);
      kbUnitQuerySetPlayerID(daimyoQueryID, cMyID);
      kbUnitQuerySetUnitType(daimyoQueryID, cUnitTypeypDaimyoMototada);      
      kbUnitQuerySetState(daimyoQueryID, cUnitStateAlive);
   }
   else 
   {  return;  }

    kbUnitQueryResetResults(daimyoQueryID);
    int numberFound = kbUnitQueryExecute(daimyoQueryID);
    
    for (i=0; < numberFound)
    {         
       int daimyoID=kbUnitQueryGetResult(daimyoQueryID, i);
       if (kbUnitGetHealth(daimyoID) < 0.3)
       {
          aiTaskUnitMove(daimyoID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
       }
       else
       { 
         if (kbUnitIsType(unitID, cUnitTypeAbstractLightCavalry) == true)
          aiTaskUnitTrain(daimyoID, cUnitTypeypAshigaru); 
        else if (kbUnitIsType(unitID, cUnitTypeAbstractHeavyInfantry) == true)
          aiTaskUnitTrain(daimyoID, cUnitTypeypYumi);
        else if (kbUnitIsType(unitID, cUnitTypeAbstractHeavyCavalry) == true)
          aiTaskUnitTrain(daimyoID, cUnitTypeypYabusame);
        else
          aiTaskUnitTrain(daimyoID, cUnitTypeypNaginataRider);  
       }        
       // We need to set fast mode
       xsSetRuleMinIntervalSelf(1);
       aiEcho("Going to fast mode.");              
       return;
    }
}

rule daimyoTokugawaMonitor
inactive
group tcComplete
minInterval 30
{
   if (kbGetCiv() != cCivJapanese) 
   {
      xsDisableSelf();
      return;
   }
  
   if (aiTreatyActive() == true) //Can't attack under treaty!
       return;

   int targetPlayer = aiGetMostHatedPlayerID();
   int unitID = getUnit(cUnitTypeLogicalTypeLandMilitary, targetPlayer, cUnitStateAlive);

   //gotta find the tokugawa
   static int tokugawaQueryID=-1;
   //If we don't have the query yet, create one.
   if (tokugawaQueryID < 0)
   {
      tokugawaQueryID=kbUnitQueryCreate("tokugawaGetUnitQuery");
      kbUnitQuerySetIgnoreKnockedOutUnits(tokugawaQueryID, true);
   }
   //Define a query to get all matching units
   if (tokugawaQueryID != -1) 
   {
      kbUnitQuerySetPlayerRelation(tokugawaQueryID, -1);
      kbUnitQuerySetPlayerID(tokugawaQueryID, cMyID);
      kbUnitQuerySetUnitType(tokugawaQueryID, cUnitTypeypShogunTokugawa);      
      kbUnitQuerySetState(tokugawaQueryID, cUnitStateAlive);
   }
   else 
   {  return;  }

    kbUnitQueryResetResults(tokugawaQueryID);
    int numberFound = kbUnitQueryExecute(tokugawaQueryID);
    
    for (i=0; < numberFound)
    {       
       int tokugawaID=kbUnitQueryGetResult(tokugawaQueryID, i);  
       if (kbUnitGetHealth(tokugawaID) < 0.3)
       {
          aiTaskUnitMove(tokugawaID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
       }
       else
       {   
         if (kbUnitIsType(unitID, cUnitTypeAbstractInfantry) == true)  
           aiTaskUnitTrain(tokugawaID, cUnitTypeypFlamingArrow); 
         //else
           //aiTaskUnitTrain(tokugawaID, cUnitTypeypMorutaru);
       }
       // We need to set fast mode
       xsSetRuleMinIntervalSelf(1);
       aiEcho("Going to fast mode.");    
       return;
    }
}


rule shogunMonitor
inactive
minInterval 10
{
   static int shogunPlan = -1;

   // Create maintain plan (for Japanese only)
   if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) ) 
   {
      if (shogunPlan < 0)
      {
         shogunPlan = createSimpleMaintainPlan(cUnitTypeypShogunTokugawa, 1, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when shogun available
   if (kbUnitCount(cMyID, cUnitTypeypShogunTokugawa) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}

rule arrowknightMonitor
inactive
minInterval 10
{
   static int arrowknightPlan = -1;

   // Create maintain plan (for Aztec only)
   if (cMyCiv == cCivXPAztec)
   {
      if (arrowknightPlan < 0)
      {
         arrowknightPlan = createSimpleMaintainPlan(cUnitTypexpArrowKnight, 10, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when arrowknight available
   if (kbUnitCount(cMyID, cUnitTypexpArrowKnight) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}

rule tlaloccanoeMonitor
inactive
minInterval 60
{
   static int tlaloccanoePlan = -1;

   // Create maintain plan (for Aztec only)
   if (cMyCiv == cCivXPAztec)
   {
      if (tlaloccanoePlan < 0)
      {
         tlaloccanoePlan = createSimpleMaintainPlan(cUnitTypexpTlalocCanoe, 5, false, kbBaseGetMainID(cMyID));
      }
   }

   // Create plan only when tlaloccanoe available
   if (kbUnitCount(cMyID, cUnitTypexpTlalocCanoe) == 0)
   {
      return;
   }

   // Disable rule
   xsDisableSelf();   
}
*/

rule churchUpgradeMonitor
inactive
minInterval 50
{
   int upgradePlanID = -1;

   // Disable rule for native or Asian civs
   if (civIsEuropean() == false)
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechChurchTownWatch) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchMercantilism) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchStateReligion) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechChurchMercantilism) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMercantilism);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchMercantilism, getUnit(cUnitTypeChurch), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechChurchTownWatch) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTownWatch);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchTownWatch, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGasLighting);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchGasLighting, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchStandingArmy);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchStandingArmy, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMassCavalry);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchMassCavalry, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
      return;
   }   
   if (kbTechGetStatus(cTechChurchStateReligion) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchStateReligion);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchStateReligion, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
      return;
   }
}


rule churchUpgradeAsianMonitor
inactive
minInterval 50
{
   int upgradePlanID = -1;

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechChurchTownWatch) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusActive) &&
       (kbTechGetStatus(cTechChurchMercantilism) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no special church built from a wagon araound
   if (kbUnitCount(cMyID, cUnitTypeypChurch, cUnitStateAlive) < 1)
   {
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechChurchMercantilism) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMercantilism);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchMercantilism, getUnit(cUnitTypeypChurch), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechChurchTownWatch) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTownWatch);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchTownWatch, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGasLighting);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchGasLighting, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchStandingArmy);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchStandingArmy, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMassCavalry);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChurchMassCavalry, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
      return;
   }
}


rule royalDecreeMonitor
inactive
minInterval 45
{
   int decreePlanID = -1;

   // Disable rule for native or Asian civs
   if (civIsEuropean() == false)
   {
      xsDisableSelf();
      return;
   }

   if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1)
      return;

   switch(kbGetCiv())
   {
      case cCivBritish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchThinRedLine) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchBlackWatch) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchRogersRangers) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchThinRedLine) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchThinRedLine);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchThinRedLine, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchBlackWatch) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchBlackWatch);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchBlackWatch, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchRogersRangers) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchRogersRangers);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchRogersRangers, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         break;
      }
      case cCivDutch:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchCoffeeTrade) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchWaardgelders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchStadholders) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchCoffeeTrade) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchCoffeeTrade);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchCoffeeTrade, getUnit(cUnitTypeChurch), cEconomyEscrowID, 50);
         }
         if ((kbTechGetStatus(cTechChurchWaardgelders) == cTechStatusObtainable) && (kbGetAge() >= cAge4))
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchWaardgelders);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchWaardgelders, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if ((kbTechGetStatus(cTechChurchStadholders) == cTechStatusObtainable) && (kbGetAge() >= cAge4))
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchStadholders);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchStadholders, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         break;
      }
      case cCivFrench:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchCodeNapoleon) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchGardeImperial1) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchGardeImperial2) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchGardeImperial3) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if ( (kbTechGetStatus(cTechChurchCodeNapoleon) == cTechStatusObtainable) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 70) )
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchCodeNapoleon);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchCodeNapoleon, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if ((kbTechGetStatus(cTechChurchGardeImperial1) == cTechStatusObtainable) && (kbGetAge() >= cAge4))
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGardeImperial1);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchGardeImperial1, getUnit(cUnitTypeChurch), cEconomyEscrowID, 50);
         }
         if ((kbTechGetStatus(cTechChurchGardeImperial2) == cTechStatusObtainable) && (kbGetAge() >= cAge4))
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGardeImperial2);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchGardeImperial2, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if ((kbTechGetStatus(cTechChurchGardeImperial3) == cTechStatusObtainable) && (kbGetAge() >= cAge4))
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGardeImperial3);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchGardeImperial3, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         break;
      }
      case cCivGermans:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchTillysDiscipline) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchZweihander) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchTillysDiscipline) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTillysDiscipline);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchTillysDiscipline, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchZweihander) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchZweihander);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchZweihander, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         break;
      }
      case cCivOttomans:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchTufanciCorps) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchTopcuCorps) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchTufanciCorps) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTufanciCorps);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchTufanciCorps, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchTopcuCorps) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTopcuCorps);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchTopcuCorps, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         break;
      }
      case cCivPortuguese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchBestieros) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchTowerAndSword) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchBestieros) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchBestieros);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchBestieros, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchTowerAndSword) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTowerAndSword);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchTowerAndSword, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         break;
      }
      case cCivRussians:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchWesternization) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchPetrineReforms) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchKalmucks) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchBashkirPonies) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchWesternization) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchWesternization);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchWesternization, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchPetrineReforms) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchPetrineReforms);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchPetrineReforms, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchKalmucks) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchKalmucks);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchKalmucks, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchBashkirPonies) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchBashkirPonies);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchBashkirPonies, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         break;
      }
      case cCivSpanish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChurchCorsolet) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchQuatrefage) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChurchWildGeeseSpanish) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         // Get upgrades/troops as they become available
         if (kbTechGetStatus(cTechChurchCorsolet) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchCorsolet);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchCorsolet, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchQuatrefage) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchQuatrefage);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchQuatrefage, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         if (kbTechGetStatus(cTechChurchWildGeeseSpanish) == cTechStatusObtainable)
         {
            decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchWildGeeseSpanish);
            if (decreePlanID >= 0)
               aiPlanDestroy(decreePlanID);
            createSimpleResearchPlan(cTechChurchWildGeeseSpanish, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
         }
         break;
      }
   }
}

rule spiesMonitor
inactive
minInterval 20
{
   if (aiGetWorldDifficulty() < cDifficultyModerate)
   {  // Easy and Sandbox will never research.    
      xsDisableSelf();
      return;
   }
  
   //If we can afford it, then get it.
   float goldCost=kbTechCostPerResource(cTechSpies, cResourceGold);
   float currentGold=kbResourceGet(cResourceGold);
   if(goldCost>currentGold)
      return;

   //Get Omniscience
   int spiesPID=aiPlanCreate("Get_Spies", cPlanProgression);
   if (spiesPID != 0)
   {
      aiPlanSetVariableInt(spiesPID, cProgressionPlanGoalTechID, 0, cTechSpies);
      aiPlanSetDesiredPriority(spiesPID, 50);
      aiPlanSetEscrowID(spiesPID, cMilitaryEscrowID);
      aiPlanSetActive(spiesPID);
   }  
   xsDisableSelf();
}

rule spiesNativeMonitor
inactive
minInterval 20
{
   if (aiGetWorldDifficulty() < cDifficultyModerate)
   {  // Easy and Sandbox will never research.    
      xsDisableSelf();
      return;
   }

   //If we can afford it, then get it.
   float goldCost=kbTechCostPerResource(cTechSpiesNative, cResourceGold);
   float currentGold=kbResourceGet(cResourceGold);
   if(goldCost>currentGold)
      return;

   //Get Omniscience
   int spiesPID=aiPlanCreate("Get_Spies", cPlanProgression);
   if (spiesPID != 0)
   {
      aiPlanSetVariableInt(spiesPID, cProgressionPlanGoalTechID, 0, cTechSpiesNative);
      aiPlanSetDesiredPriority(spiesPID, 50);
      aiPlanSetEscrowID(spiesPID, cMilitaryEscrowID);
      aiPlanSetActive(spiesPID);
   }  
   xsDisableSelf();
}

rule blockadeMonitor
inactive
minInterval 60
{
   if (aiGetWorldDifficulty() < cDifficultyModerate)
   {  // Easy and Sandbox will never research.    
      xsDisableSelf();
      return;
   }
 
   //If we can afford it, then get it.
   float goldCost=kbTechCostPerResource(cTechHCBlockade, cResourceGold);
   float currentGold=kbResourceGet(cResourceGold);
   if(goldCost>currentGold)
      return;

   //Get Blockade
   int hCBlockadePID=aiPlanCreate("Get_HC_Blockade", cPlanProgression);
   if (hCBlockadePID != 0)
   {
      aiPlanSetVariableInt(hCBlockadePID, cProgressionPlanGoalTechID, 0, cTechHCBlockade);
      aiPlanSetDesiredPriority(hCBlockadePID, 50);
      aiPlanSetEscrowID(hCBlockadePID, cMilitaryEscrowID);
      aiPlanSetActive(hCBlockadePID);
   }
   xsDisableSelf();
}

rule blockadeNativeMonitor
inactive
minInterval 60
{
   if (aiGetWorldDifficulty() < cDifficultyModerate)
   {  // Easy and Sandbox will never research.    
      xsDisableSelf();
      return;
   }

   //If we can afford it, then get it.
   float goldCost=kbTechCostPerResource(cTechHCBlockade, cResourceGold);
   float currentGold=kbResourceGet(cResourceGold);
   if(goldCost>currentGold)
      return;

   //Get Blockade
   int hCBlockadePID=aiPlanCreate("Get_HC_Blockade", cPlanProgression);
   if (hCBlockadePID != 0)
   {
      aiPlanSetVariableInt(hCBlockadePID, cProgressionPlanGoalTechID, 0, cTechHCBlockadeNative);
      aiPlanSetDesiredPriority(hCBlockadePID, 50);
      aiPlanSetEscrowID(hCBlockadePID, cMilitaryEscrowID);
      aiPlanSetActive(hCBlockadePID);
   }
   xsDisableSelf();
}

rule capitolUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Disable rule for native or Asian civs
   if (civIsEuropean() == false)
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechImpKnighthood) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpPeerage) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpLargeScaleAgriculture) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpDeforestation) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpExcessiveTaxation) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpImmigrants) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpLegendaryNatives) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechImpKnighthood) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpKnighthood);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpKnighthood, getUnit(cUnitTypeCapitol), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpPeerage) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpPeerage);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpPeerage, getUnit(cUnitTypeCapitol), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpLargeScaleAgriculture) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLargeScaleAgriculture);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpLargeScaleAgriculture, getUnit(cUnitTypeCapitol), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpDeforestation) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpDeforestation);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpDeforestation, getUnit(cUnitTypeCapitol), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpExcessiveTaxation) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpExcessiveTaxation);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpExcessiveTaxation, getUnit(cUnitTypeCapitol), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpImmigrants) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpImmigrants);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpImmigrants, getUnit(cUnitTypeCapitol), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpLegendaryNatives) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryNatives);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpLegendaryNatives, getUnit(cUnitTypeCapitol), cMilitaryEscrowID, 50);
      return;
   }
}

rule europeanUpgradeMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;

   // Disable rule for native or Asian civs
   if ((civIsNative() == true) || (civIsAsian() == true))
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechHuntingDogs) == cTechStatusActive) &&
       (kbTechGetStatus(cTechSteelTraps) == cTechStatusActive) &&
       (kbTechGetStatus(cTechSeedDrill) == cTechStatusActive) &&
       (kbTechGetStatus(cTechArtificialFertilizer) == cTechStatusActive) &&
       (kbTechGetStatus(cTechGangsaw) == cTechStatusActive) &&
       (kbTechGetStatus(cTechLogFlume) == cTechStatusActive) &&
       (kbTechGetStatus(cTechCircularSaw) == cTechStatusActive) &&
       (kbTechGetStatus(cTechBookkeeping) == cTechStatusActive) &&
       (kbTechGetStatus(cTechHomesteading) == cTechStatusActive) &&
       (kbTechGetStatus(cTechOreRefining) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechHuntingDogs) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHuntingDogs);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechHuntingDogs, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechSteelTraps) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechSteelTraps);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechSteelTraps, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechSeedDrill) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechSeedDrill);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechSeedDrill, getUnit(cUnitTypeMill), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechArtificialFertilizer) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechArtificialFertilizer);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechArtificialFertilizer, getUnit(cUnitTypeMill), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechGangsaw) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGangsaw);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechGangsaw, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechLogFlume) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechLogFlume);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechLogFlume, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechCircularSaw) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCircularSaw);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechCircularSaw, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechBookkeeping) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBookkeeping);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechBookkeeping, getUnit(cUnitTypePlantation), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechHomesteading) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHomesteading);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechHomesteading, getUnit(cUnitTypePlantation), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechOreRefining) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechOreRefining);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechOreRefining, getUnit(cUnitTypePlantation), cEconomyEscrowID, 50);
      return;
   }
}

rule bigMarketNewYearMonitor
inactive
minInterval 20
{
   int upgradePlanID = -1;
    
   // Disable rule for non-native civs
   if (civIsNative() == false)
   {
      xsDisableSelf();
      return;
   }
   if (kbTechGetStatus(cTechBigMarketNewYear) == cTechStatusActive)
   {
      xsDisableSelf();
      return;
   }  
   // If we can afford it twice over, then get it.
   float foodCost=kbTechCostPerResource(cTechBigMarketNewYear, cResourceFood);
   float woodCost=kbTechCostPerResource(cTechBigMarketNewYear, cResourceWood);
   float goldCost=kbTechCostPerResource(cTechBigMarketNewYear, cResourceGold);

   float currentFood=kbResourceGet(cResourceFood);
   float currentWood=kbResourceGet(cResourceWood);
   float currentGold=kbResourceGet(cResourceGold);
   if ((foodCost>currentFood) && (woodCost>currentWood) && (goldCost>currentGold))
      return;

   int bigMarketNewYearPID=aiPlanCreate("Get_BigMarketNewYear", cPlanProgression);
   if (bigMarketNewYearPID != 0)
   {
      aiPlanSetVariableInt(bigMarketNewYearPID, cProgressionPlanGoalTechID, 0, cTechBigMarketNewYear);
      aiPlanSetDesiredPriority(bigMarketNewYearPID, 60);
      aiPlanSetEscrowID(bigMarketNewYearPID, cEconomyEscrowID);
      aiPlanSetActive(bigMarketNewYearPID);
   }
}

rule nativeUpgradeMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;

   // Disable rule for non-native civs
   if (civIsNative() == false)
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechHuntingDogs) == cTechStatusActive) &&
       (kbTechGetStatus(cTechGreatFeast) == cTechStatusActive) &&
       (kbTechGetStatus(cTechHarvestCeremony) == cTechStatusActive) &&
       (kbTechGetStatus(cTechGreenCornCeremony) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpLargeScaleGathering) == cTechStatusActive) &&
       (kbTechGetStatus(cTechLumberCeremony) == cTechStatusActive) &&
       (kbTechGetStatus(cTechForestPeopleCeremony) == cTechStatusActive) &&
       (kbTechGetStatus(cTechForestSpiritCeremony) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpDeforestationNative) == cTechStatusActive) &&
       (kbTechGetStatus(cTechEarthCeremony) == cTechStatusActive) &&
       (kbTechGetStatus(cTechEarthGiftCeremony) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpExcessiveTributeNative) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpLegendaryNativesNatives) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpImmigrantsNative) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechHuntingDogs) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHuntingDogs);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechHuntingDogs, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechGreatFeast) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGreatFeast);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechGreatFeast, getUnit(cUnitTypeFarm), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechHarvestCeremony) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHarvestCeremony);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechHarvestCeremony, getUnit(cUnitTypeFarm), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechGreenCornCeremony) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGreenCornCeremony);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechGreenCornCeremony, getUnit(cUnitTypeFarm), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpLargeScaleGathering) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLargeScaleGathering);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpLargeScaleGathering, getUnit(cUnitTypeFarm), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechLumberCeremony) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechLumberCeremony);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechLumberCeremony, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechForestPeopleCeremony) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechForestPeopleCeremony);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechForestPeopleCeremony, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechForestSpiritCeremony) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechForestSpiritCeremony);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechForestSpiritCeremony, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpDeforestationNative) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpDeforestationNative);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpDeforestationNative, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechEarthCeremony) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEarthCeremony);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechEarthCeremony, getUnit(cUnitTypePlantation), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechEarthGiftCeremony) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEarthGiftCeremony);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechEarthGiftCeremony, getUnit(cUnitTypePlantation), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpExcessiveTributeNative) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpExcessiveTributeNative);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpExcessiveTributeNative, getUnit(cUnitTypePlantation), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpLegendaryNativesNatives) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryNativesNatives);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpLegendaryNativesNatives, getUnit(cUnitTypeTownCenter), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpImmigrantsNative) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpImmigrantsNative);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpImmigrantsNative, getUnit(cUnitTypeTownCenter), cEconomyEscrowID, 50);
      return;
   }
}


rule asianUpgradeMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;

   // Disable rule for non-Asian civilizations
   if (civIsAsian() == false) 
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechypMarketHuntingDogs) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypMarketWheelbarrow) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypMarketWheelbarrow2) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypCultivateWasteland) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypWaterConservancy) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypIrrigationSystems) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypImpLargeScaleAgricultureAsian) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypMarketGangsaw) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypMarketLogFlume) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypMarketCircularSaw) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypImpDeforestationAsian) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypCropMarket) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypSharecropping) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypLandRedistribution) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypCooperative) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypImpExcessiveTributeAsian) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypImpLegendaryNatives2) == cTechStatusActive) &&
       (kbTechGetStatus(cTechImpImmigrantsNative) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechypMarketHuntingDogs) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMarketHuntingDogs);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMarketHuntingDogs, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMarketWheelbarrow) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMarketWheelbarrow);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMarketWheelbarrow, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMarketWheelbarrow2) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMarketWheelbarrow2);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMarketWheelbarrow2, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypCultivateWasteland) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypCultivateWasteland);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypCultivateWasteland, getUnit(cUnitTypeypRicePaddy), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypWaterConservancy) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypWaterConservancy);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypWaterConservancy, getUnit(cUnitTypeypRicePaddy), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypIrrigationSystems) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypIrrigationSystems);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypIrrigationSystems, getUnit(cUnitTypeypRicePaddy), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypImpLargeScaleAgricultureAsian) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypImpLargeScaleAgricultureAsian);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypImpLargeScaleAgricultureAsian, getUnit(cUnitTypeypRicePaddy), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMarketGangsaw) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMarketGangsaw);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMarketGangsaw, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMarketLogFlume) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMarketLogFlume);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMarketLogFlume, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMarketCircularSaw) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMarketCircularSaw);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMarketCircularSaw, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypImpDeforestationAsian) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypImpDeforestationAsian);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypImpDeforestationAsian, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypCropMarket) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypCropMarket);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypCropMarket, getUnit(cUnitTypeypRicePaddy), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypSharecropping) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypSharecropping);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypSharecropping, getUnit(cUnitTypeypRicePaddy), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypLandRedistribution) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypLandRedistribution);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypLandRedistribution, getUnit(cUnitTypeypRicePaddy), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypCooperative) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypCooperative);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypCooperative, getUnit(cUnitTypeypRicePaddy), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypImpExcessiveTributeAsian) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypImpExcessiveTributeAsian);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypImpExcessiveTributeAsian, getUnit(cUnitTypeypRicePaddy), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypImpLegendaryNatives2) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypImpLegendaryNatives2);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypImpLegendaryNatives2, getUnit(cUnitTypeTownCenter), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechImpImmigrantsNative) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpImmigrantsNative);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpImmigrantsNative, getUnit(cUnitTypeTownCenter), cEconomyEscrowID, 50);
      return;
   }
}


rule rescueExplorer
inactive
minInterval 10
{
   static int rescuePlan = -1;

   // Disable rule for native civs
   if (civIsNative() == true)
   {
      xsDisableSelf();
      return;
   }

   // Destroy old rescue plan (if any)
   if (rescuePlan >= 0)
   {
      aiPlanDestroy(rescuePlan);
      rescuePlan = -1;
      aiEcho("Killing old rescue plan");
   }

   // Use only in Age 2 and above
   if ((kbGetAge() < cAge2) || (aiGetFallenExplorerID() < 0))
   {
      aiEcho("No explorer to rescue");
      return;
   }

   // Use only when explorer is strong enough
   if (kbUnitGetHealth(aiGetFallenExplorerID()) < 0.3)
   {
      aiEcho("Explorer too weak to be rescued");
      return;
   }
   
   // Get position of fallen explorer and send scout unit there
   vector fallenExplorerLocation = kbUnitGetPosition(aiGetFallenExplorerID());
   rescuePlan = aiPlanCreate("Rescue Explorer", cPlanExplore);
   if (rescuePlan >= 0)
   {
      aiPlanAddUnitType(rescuePlan, cUnitTypeAbstractRangedInfantry, 1, 1, 1);
      aiPlanAddWaypoint(rescuePlan, fallenExplorerLocation);
      aiPlanSetVariableBool(rescuePlan, cExplorePlanDoLoops, 0, false);
      aiPlanSetVariableBool(rescuePlan, cExplorePlanAvoidingAttackedAreas, 0, false);
      aiPlanSetVariableInt(rescuePlan, cExplorePlanNumberOfLoops, 0, -1);
      aiPlanSetRequiresAllNeedUnits(rescuePlan, true);
      aiPlanSetDesiredPriority(rescuePlan, 99);
      aiPlanSetActive(rescuePlan);
      aiEcho("Trying to rescue explorer");
   }
}
/*
rule defendBase
inactive
group tcComplete
minInterval 15
{
   static int baseDefendPlan = -1;
   int baseDefensePop = 0;
   int ownMilitaryCount = 0;

   // Number of units for base defend plan, 25% of army
   ownMilitaryCount = kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive);
   if (ownMilitaryCount > 0)
   {
      baseDefensePop = 0; //ownMilitaryCount / 4;
   }
   else
   {
      baseDefensePop = 0;
   }

   switch (gForwardBaseState)
   {
      case cForwardBaseStateNone:
      {
         if (baseDefendPlan >= 0)
         {
            aiPlanDestroy(baseDefendPlan);
            baseDefendPlan = 0;
            aiEcho("Forward base destroyed, additional defend plan deleted");
         }
         else
         {
            aiEcho("No forward base found, no additional defend plan for main base");
         }
         break;
      }
      case cForwardBaseStateActive:
      {
         if (baseDefendPlan < 0)
         {
            baseDefendPlan = aiPlanCreate("Base Defend", cPlanDefend);
            aiPlanAddUnitType(baseDefendPlan, cUnitTypeLogicalTypeLandMilitary , baseDefensePop, baseDefensePop, baseDefensePop); 

            aiPlanSetVariableVector(baseDefendPlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
            aiPlanSetVariableFloat(baseDefendPlan, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);  
            aiPlanSetVariableFloat(baseDefendPlan, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusActive - 10.0);
            aiPlanSetVariableBool(baseDefendPlan, cDefendPlanPatrol, 0, false);
            aiPlanSetVariableFloat(baseDefendPlan, cDefendPlanGatherDistance, 0, 20.0);
            aiPlanSetInitialPosition(baseDefendPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
            aiPlanSetUnitStance(baseDefendPlan, cUnitStanceDefensive);
            aiPlanSetVariableInt(baseDefendPlan, cDefendPlanRefreshFrequency, 0, 1);
            aiPlanSetVariableInt(baseDefendPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit);
            aiPlanSetDesiredPriority(baseDefendPlan, 95);  // High priority to keep units from being drafted into attack plans
            aiPlanSetActive(baseDefendPlan); 
            aiEcho("Creating base defend plan, "+baseDefensePop+" units assigned");
         }
         else
         {
            aiPlanAddUnitType(baseDefendPlan, cUnitTypeLogicalTypeLandMilitary , baseDefensePop, baseDefensePop, baseDefensePop); 
            aiEcho("Updating base defend plan, "+baseDefensePop+" units assigned");
         }
         break;
      }
      default: // cForwardBaseStateBuilding
      {
         aiEcho("Forward base being built, wait with additional defend plan for main base");
         break;
      }
   }
}
*/

rule stageCoachMonitor
inactive
minInterval 30
{
   if ( (kbTechGetStatus(cTechTradeRouteUpgrade1) == cTechStatusActive) || 
        (kbTechGetStatus(cTechypTradeRouteUpgrade1) == cTechStatusActive) )
   {
      xsDisableSelf();
      return;
   }

   static int stagecoachPlan = -1;
   static int stagecoachAttempts = 0;

   // Kill existing plan (cleanup)
   if (stagecoachPlan >= 0)
   {
      aiPlanDestroy(stagecoachPlan);
      stagecoachPlan = -1;
      aiEcho("Destroying old stage coach plan");
   }

   // Disable if upgrade has been attempted three times, assuming that only native TPs are left now
   // As the kbVPSiteGetType() function does not work properly, this is a workaround to keep the AI from 
   // wasting resources by constantly researching the upgrade at native TPs (which is actually possible)
   if (stagecoachAttempts >= 5)
      xsDisableSelf();

   // Check if trade route upgrade makes sense
   int ownTPList = kbVPSiteQuery(cVPTrade, cMyID, cVPStateCompleted);
   int alliedTPList = kbVPSiteQuery(cVPTrade, cPlayerRelationAlly, cVPStateCompleted);
   int numTeamTPs = xsArrayGetSize(ownTPList) + xsArrayGetSize(alliedTPList);

   // Team controlling two trade posts, ok to upgrade to stage coach
   if (numTeamTPs >= 2) 
   {
      aiEcho("Team controlling two TPs, ok to upgrade trade route to stage coach");
      if ((kbTechGetStatus(cTechTradeRouteUpgrade1) == cTechStatusObtainable) || (kbTechGetStatus(cTechypTradeRouteUpgrade1) == cTechStatusObtainable))
      {
         // Research stage coach tech at random TP
         if (kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) > 0)  // Standard trade route
           stagecoachPlan = createSimpleResearchPlan(cTechTradeRouteUpgrade1, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
         else  // Asian map specific trade route
           stagecoachPlan = createSimpleResearchPlan(cTechypTradeRouteUpgrade1, getUnit(cUnitTypeypTradingPostAsian), cEconomyEscrowID, 50);
         if (stagecoachPlan >= 0)
         {
            aiEcho("Attempting trade route upgrade to stage coach");
            stagecoachAttempts = stagecoachAttempts + 1;
            return;
         }
      }
   }
}


rule ironHorseMonitor
inactive
minInterval 30
{
   if ( (kbTechGetStatus(cTechTradeRouteUpgrade2) == cTechStatusActive) || 
        (kbTechGetStatus(cTechypTradeRouteUpgrade2) == cTechStatusActive) )
   {
      xsDisableSelf();
      return;
   }

   static int ironhorsePlan = -1;
   static int ironhorseAttempts = 0;

   // Kill existing plan (cleanup)
   if (ironhorsePlan >= 0)
   {
      aiPlanDestroy(ironhorsePlan);
      ironhorsePlan = -1;
      aiEcho("Destroying old iron horse plan");
   }

   // Disable if upgrade has been attempted 1 time, assuming that only native TPs are left now
   // As the kbVPSiteGetType() function does not work properly, this is a workaround to keep the AI from 
   // wasting resources by constantly researching the upgrade at native TPs (which is actually possible)
   if (ironhorseAttempts >= 5)
      xsDisableSelf();

   // Check if trade route upgrade makes sense
   int ownTPList = kbVPSiteQuery(cVPTrade, cMyID, cVPStateCompleted);
   int alliedTPList = kbVPSiteQuery(cVPTrade, cPlayerRelationAlly, cVPStateCompleted);
   int numTeamTPs = xsArrayGetSize(ownTPList) + xsArrayGetSize(alliedTPList);

   // Team controlling one trade post, ok to upgrade to iron horse
   if (numTeamTPs >= 1) 
   {
      aiEcho("Team controlling one TP, ok to upgrade trade route to iron horse");
      if ((kbTechGetStatus(cTechTradeRouteUpgrade2) == cTechStatusObtainable) || (kbTechGetStatus(cTechypTradeRouteUpgrade2) == cTechStatusObtainable))
      {
         // Research iron horse tech at random TP
         if (kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) > 0)  // Standard trade route
           ironhorsePlan = createSimpleResearchPlan(cTechTradeRouteUpgrade2, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
         else  // Asian map specific trade route
           ironhorsePlan = createSimpleResearchPlan(cTechypTradeRouteUpgrade2, getUnit(cUnitTypeypTradingPostAsian), cEconomyEscrowID, 50);
         if (ironhorsePlan >= 0)
         {
            aiEcho("Attempting trade route upgrade to iron horse");
            ironhorseAttempts = ironhorseAttempts + 1;
            return;
         }
      }
   }
}


rule livestockMonitor
inactive
group startup
minInterval 15
{
   static int livestockPlan = -1;

   // Livestock pen for Europeans, village for Chinese, shrine for Japanese
   // and sacred field for Indians, as defined in initEcon()
   if (civIsNative() == false)
   {
      if (kbUnitCount(cMyID, gLivestockPenUnit, cUnitStateAlive) > 0)
      {
         // Create herd plan
         if (livestockPlan < 0)
         {
            livestockPlan = aiPlanCreate("Livestock Plan", cPlanHerd);
            aiPlanSetDesiredPriority(livestockPlan, 99);
            aiPlanAddUnitType(livestockPlan, cUnitTypeHerdable, 0, 100, 100);
            aiPlanSetVariableInt(livestockPlan, cHerdPlanBuildingTypeID, 0, gLivestockPenUnit);
            aiPlanSetVariableFloat(livestockPlan, cHerdPlanDistance, 0, 0.0);
            aiPlanSetActive(livestockPlan);
         }
      }
      else
      {
         aiPlanDestroy(livestockPlan);  // Destroy plan to have it recreated with a new pen
         livestockPlan = -1;
      }
   }
   else // natives use second farm for livestock
   {
      if (kbUnitCount(cMyID, cUnitTypeFarm, cUnitStateAlive) > 1)
      {
         // Create herd plan
         if (livestockPlan < 0)
         {
            livestockPlan = aiPlanCreate("Livestock Plan", cPlanHerd);
            aiPlanSetDesiredPriority(livestockPlan, 99);
            aiPlanAddUnitType(livestockPlan, cUnitTypeHerdable, 0, 100, 100);
            aiPlanSetVariableInt(livestockPlan, cHerdPlanBuildingTypeID, 0, gLivestockPenUnit);
            aiPlanSetVariableFloat(livestockPlan, cHerdPlanDistance, 0, 0.0);
            aiPlanSetActive(livestockPlan);
         }
      }
      else
      {
         aiPlanDestroy(livestockPlan);  // Destroy plan to have it recreated with a new pen
         livestockPlan = -1;
      }
   }
}


rule herdableMonitor
inactive
group startup
minInterval 25
{
   int tempExplorePlan = -1;
   int envoyExplorePlan = -1;
   int mongolExplorePlan = -1;
   int nativeExplorePlan = -1;
   int herdableCount = kbUnitCount(0, cUnitTypeHerdable, cUnitStateAlive);

   if (herdableCount > 0)
   {
      vector herdVec = kbUnitGetPosition(getUnit(cUnitTypeHerdable, 0, cUnitStateAlive));

      int explorePlanCount = aiPlanGetNumber(cPlanExplore, -1, true);
      if (explorePlanCount > 1)
      {
         for (i=0; < explorePlanCount)
         {
            tempExplorePlan = aiPlanGetIDByIndex(cPlanExplore, -1, true, i);
            if (aiPlanGetNumberUnits(tempExplorePlan, cUnitTypeEnvoy) > 0)
               envoyExplorePlan = tempExplorePlan;
            if (aiPlanGetNumberUnits(tempExplorePlan, cUnitTypeypMongolScout) > 0)
               mongolExplorePlan = tempExplorePlan;
            if (aiPlanGetNumberUnits(tempExplorePlan, cUnitTypeNativeScout) > 0)
               nativeExplorePlan = tempExplorePlan;
         }
      }
      if (mongolExplorePlan > 0)
      {
         aiPlanAddWaypoint(mongolExplorePlan, herdVec);
      }
      else if (nativeExplorePlan > 0)
      {
         aiPlanAddWaypoint(nativeExplorePlan, herdVec);
      }
      else if (envoyExplorePlan > 0)
      {
         aiPlanAddWaypoint(envoyExplorePlan, herdVec);
      }
      else if (gLandExplorePlan > 0)
      {
         aiPlanAddWaypoint(gLandExplorePlan, herdVec);
      }
   }
}


rule slaughterMonitor
inactive
group tcComplete
minInterval 15
{
   // Disable rule for Indians and Japanese
   if ((kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivJapanese))
   {
      xsDisableSelf();
      return;
   }

   static int slaughterPlanID = -1;
   int numCattle = -1;
   int gatherersWanted = -1;
   vector homeBaseVec = cInvalidVector;

   // Don't slaughter cattle in the early stages
   if ( (kbGetAge() < cAge3) || (xsGetTime() < 480000) )
   {
      return;
   }

   // If we have a main base, count the number of herdables in it
   if (kbBaseGetMainID(cMyID) < 0)
      return;

   homeBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   numCattle = getUnitCountByLocation(cUnitTypeHerdable, cPlayerRelationAny, cUnitStateAny, homeBaseVec, 75.0);

   if (numCattle == 0)
   {
      gatherersWanted = 0;
   }
   else
   {
      gatherersWanted = 3;
   }

   if (aiPlanGetState(slaughterPlanID) == -1)
   {
      aiEcho("Cattle gather plan "+slaughterPlanID+" is invalid.");
      aiPlanDestroy(slaughterPlanID);
      slaughterPlanID = -1;
   }
   if (slaughterPlanID < 0)
   {  // Initialize the plan
      slaughterPlanID = aiPlanCreate("Cattle slaughter", cPlanGather);
      aiPlanSetBaseID(slaughterPlanID, kbBaseGetMainID(cMyID));
      aiPlanSetVariableInt(slaughterPlanID, cGatherPlanResourceUnitTypeFilter, 0, cUnitTypeHerdable);
      aiPlanSetVariableInt(slaughterPlanID, cGatherPlanResourceType, 0, cAllResources);
      aiPlanAddUnitType(slaughterPlanID, gEconUnit, gatherersWanted, gatherersWanted, 2*gatherersWanted); // 2-6 gatherers if there is cattle
      aiPlanSetDesiredPriority(slaughterPlanID, 85);
      aiPlanSetActive(slaughterPlanID);
      aiEcho("Activated cattle slaughter plan "+slaughterPlanID);
   }
   else
   {
      aiPlanAddUnitType(slaughterPlanID, gEconUnit, gatherersWanted, gatherersWanted, 2*gatherersWanted); // 2-6 gatherers if there is cattle
   }
}


rule slaughterGoatMonitor
inactive
group tcComplete
minInterval 15
{
   // Disable rule for Indians and Japanese
   if ((kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivJapanese))
   {
      xsDisableSelf();
      return;
   }

   static int slaughterPlanID = -1;
   int numGoats = -1;
   int gatherersWanted = -1;
   vector homeBaseVec = cInvalidVector;

   // Don't slaughter goats in the early stages
   if ( (kbGetAge() < cAge3) || (xsGetTime() < 480000) )
   {
      return;
   }

   // If we have a main base, count the number of goats in it
   if (kbBaseGetMainID(cMyID) < 0)
      return;

   homeBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   numGoats = getUnitCountByLocation(cUnitTypeypGoat, cPlayerRelationAny, cUnitStateAny, homeBaseVec, 75.0);

   if (numGoats == 0)
   {
      gatherersWanted = 0;
   }
   else
   {
      gatherersWanted = 3;
   }

   if (aiPlanGetState(slaughterPlanID) == -1)
   {
      aiEcho("Goats gather plan "+slaughterPlanID+" is invalid.");
      aiPlanDestroy(slaughterPlanID);
      slaughterPlanID = -1;
   }
   if (slaughterPlanID < 0)
   {  // Initialize the plan
      slaughterPlanID = aiPlanCreate("Goats slaughter", cPlanGather);
      aiPlanSetBaseID(slaughterPlanID, kbBaseGetMainID(cMyID));
      aiPlanSetVariableInt(slaughterPlanID, cGatherPlanResourceUnitTypeFilter, 0, cUnitTypeypGoat);
      aiPlanSetVariableInt(slaughterPlanID, cGatherPlanResourceType, 0, cAllResources);
      aiPlanAddUnitType(slaughterPlanID, gEconUnit, gatherersWanted, gatherersWanted, 2*gatherersWanted); // 3-6 gatherers if there is cattle
      aiPlanSetDesiredPriority(slaughterPlanID, 85);
      aiPlanSetActive(slaughterPlanID);
      aiEcho("Activated Goats slaughter plan "+slaughterPlanID);
   }
   else
   {
      aiPlanAddUnitType(slaughterPlanID, gEconUnit, gatherersWanted, gatherersWanted, 2*gatherersWanted); // 3-6 gatherers if there is cattle
   }
}


rule ransomExplorer
inactive
minInterval 23
{
   // Disable rule for native or Asian civs
   if (civIsNative() == true)
   {
      xsDisableSelf();
      return;
   }
  
   // Use only in Age 2 and above
   if ((kbGetAge() < cAge2) || (aiGetFallenExplorerID() < 0))
   {
      return;
   }
   else
   {
      aiRansomExplorer(aiGetFallenExplorerID(), cMilitaryEscrowID, 99);          
      aiEcho("Ransoming explorer");
   }
}


rule localNuggetGathering
inactive
minInterval 33
{
   static int localNuggetPlanStartTime = 0;
   if (localNuggetPlanStartTime == 0)
   {
      localNuggetPlanStartTime = xsGetTime(); // set time and quit when rule is called for the first time
      return;
   }

   static int localNuggetPlan = -1;
   vector homeBaseVec = cInvalidVector;

   if (kbUnitCount(cMyID, cUnitTypeTownCenter, cUnitStateAlive) > 0)
   {
      homeBaseVec = kbUnitGetPosition(getUnit(cUnitTypeTownCenter, cMyID)); // use random own TC position as basis for plans
   }
   else
   {
      return; // quit if there is no TC
   }

   // If there already is a plan destroy it, re-initialize explorer control plan, and wait for next call
   if (localNuggetPlan >= 0)
   {
      aiPlanDestroy(localNuggetPlan);
      localNuggetPlan = -1;

      // Re-initialize explorer control plan
      if (gExplorerControlPlan < 0)
      {
         gExplorerControlPlan = aiPlanCreate("Explorer control plan", cPlanDefend);
         switch(kbGetCiv())
         {
            case cCivXPAztec:
            {
               //aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
               break;
            }
            case cCivXPIroquois:
            {
               //aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
               break;
            }
            case cCivXPSioux:
            {
               //aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
               break;
            }
            case cCivChinese:
            {
               aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkChinese, 1, 1, 1);
               break;
            }
            case cCivIndians:
            {
               aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian, 1, 1, 1);
               aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
               break;
            }
            case cCivJapanese:
            {
               aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
               aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
               break;
            }
            default:
            {
               aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeExplorer, 1, 1, 1);
               break;
            }
         }
         aiPlanSetVariableVector(gExplorerControlPlan, cDefendPlanDefendPoint, 0, homeBaseVec);
         aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanEngageRange, 0, 20.0);    // Tight
         aiPlanSetVariableBool(gExplorerControlPlan, cDefendPlanPatrol, 0, false);
         aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanGatherDistance, 0, 20.0);
         aiPlanSetInitialPosition(gExplorerControlPlan, homeBaseVec);
         aiPlanSetUnitStance(gExplorerControlPlan, cUnitStanceDefensive);
         aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanRefreshFrequency, 0, 1);
         aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
         aiPlanSetDesiredPriority(gExplorerControlPlan, 90);    // Quite high, don't suck him into routine attack plans, etc.
         aiPlanSetActive(gExplorerControlPlan);      
      }
      return;
   }

   // Quit if no local nuggets are around, if nugget gathering is not allowed, if explorer is ko, 
   // or if the last plan was created less than 3 minutes ago
   int localNuggetCount = getUnitCountByLocation(cUnitTypeAbstractNugget, cPlayerRelationAny, cUnitStateABQ, homeBaseVec, 75.0);

   if ((localNuggetCount == 0) || 
       (cvOkToGatherNuggets == false) || 
       (aiGetFallenExplorerID() >= 0) ||
       (xsGetTime() - localNuggetPlanStartTime < 180000))
   {
      return;
   }
   else   
   {
      // Destroy explorer control plan
      aiPlanDestroy(gExplorerControlPlan);
      gExplorerControlPlan = -1;

      // Find a random local nugget
      int localNugget = getUnitByLocation(cUnitTypeAbstractNugget, cPlayerRelationAny, cUnitStateABQ, homeBaseVec, 75.0);
      vector localNuggetVec = kbUnitGetPosition(localNugget);

      // Create temporary explore plan to gather local nuggets
      localNuggetPlan = aiPlanCreate("Local Nuggets", cPlanExplore);
      aiPlanSetDesiredPriority(localNuggetPlan, 75);
      aiPlanSetInitialPosition(localNuggetPlan, localNuggetVec);
      switch(kbGetCiv())
      {
         case cCivXPAztec:
         {
            aiPlanAddUnitType(localNuggetPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
            break;
         }
         case cCivXPIroquois:
         {
            aiPlanAddUnitType(localNuggetPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
            break;
         }
         case cCivXPSioux:
         {
            aiPlanAddUnitType(localNuggetPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
            break;
         }
         case cCivChinese:
         {
            aiPlanAddUnitType(localNuggetPlan, cUnitTypeypMonkChinese, 1, 1, 1);
            break;
         }
         case cCivIndians:
         {
            aiPlanAddUnitType(localNuggetPlan, cUnitTypeypMonkIndian, 1, 1, 1);
            aiPlanAddUnitType(localNuggetPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
            break;
         }
         case cCivJapanese:
         {
            aiPlanAddUnitType(localNuggetPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
            aiPlanAddUnitType(localNuggetPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
            break;
         }
         default:
         {
            aiPlanAddUnitType(localNuggetPlan, cUnitTypeExplorer, 1, 1, 1);
            break;
         }
      }
      aiPlanSetVariableBool(localNuggetPlan, cExplorePlanOkToGatherNuggets, 0, true);
      aiPlanSetEscrowID(localNuggetPlan, cMilitaryEscrowID);
      aiPlanSetBaseID(localNuggetPlan, kbBaseGetMainID(cMyID));
      aiPlanSetVariableBool(localNuggetPlan, cExplorePlanDoLoops, 0, false);
      aiPlanSetActive(localNuggetPlan);

      // Set start time
      localNuggetPlanStartTime = xsGetTime();
   }
}


rule navyUpgradeMonitor
inactive
minInterval 60
{
   // Disable rule for native civs
   if (civIsNative() == true)
   {
      xsDisableSelf();
      return;
   }

   // Quit and disable immediately if we're not on a water map
   if (gNavyMap == false)
   {
      xsDisableSelf();
      return;
   }

   // Quit if there are not enough warships to make upgrades worthwhile
   int navySize = kbUnitCount(cMyID, cUnitTypeLogicalTypeNavalMilitary, cUnitStateAlive);
   if ( (navySize < 2) && (kbGetAge() < cAge2) )
   {
      return;
   }

   // Disable rule once both upgrades are available
   // (Percussion Lock is not researched as the AI never fires broadsides)
   if ((kbTechGetStatus(cTechGillNets) == cTechStatusActive) &&
       (kbTechGetStatus(cTechLongLines) == cTechStatusActive) &&
       (kbTechGetStatus(cTechCarronade) == cTechStatusActive) &&
       (kbTechGetStatus(cTechArmorPlating) == cTechStatusActive) &&
       (kbTechGetStatus(cTechShipHowitzers) == cTechStatusActive) &&
       (kbTechGetStatus(cTechPercussionLocks) == cTechStatusActive) &&
       ((kbTechGetStatus(cTechYPExaltedFuchuan) == cTechStatusActive) ||
       (kbTechGetStatus(cTechYPExaltedTekkousen) == cTechStatusActive)) &&
       ((kbTechGetStatus(cTechImperialManOWar) == cTechStatusActive) ||
       (kbTechGetStatus(cTechImperialMonitors) == cTechStatusActive)))
   {
      xsDisableSelf();
      return;
   }

   // Get upgrades one at a time as they become available
   int upgradePlanID = -1;

   if (kbTechGetStatus(cTechGillNets) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGillNets);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
         createSimpleResearchPlan(cTechGillNets, getUnit(cUnitTypeDock), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechLongLines) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechLongLines);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
         createSimpleResearchPlan(cTechLongLines, getUnit(cUnitTypeDock), cEconomyEscrowID, 50);        
      return;
   }
   if (kbTechGetStatus(cTechCarronade) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCarronade);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
         createSimpleResearchPlan(cTechCarronade, getUnit(cUnitTypeDock), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechArmorPlating) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechArmorPlating);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
         createSimpleResearchPlan(cTechArmorPlating, getUnit(cUnitTypeDock), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechShipHowitzers) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) >= 1))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechShipHowitzers);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
         createSimpleResearchPlan(cTechShipHowitzers, getUnit(cUnitTypeDock), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechPercussionLocks) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) >= 3))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPercussionLocks);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
         createSimpleResearchPlan(cTechPercussionLocks, getUnit(cUnitTypeDock), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechImperialManOWar) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, gFrigateUnit, cUnitStateAlive) >= 3))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialManOWar);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
         createSimpleResearchPlan(cTechImperialManOWar, getUnit(cUnitTypeDock), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechImperialMonitors) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) >= 2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialMonitors);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
         createSimpleResearchPlan(cTechImperialMonitors, getUnit(cUnitTypeDock), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedFuchuan) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypFuchuan, cUnitStateAlive) > 1))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedFuchuan);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedFuchuan, getUnit(cUnitTypeYPDockAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedTekkousen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypTekkousen, cUnitStateAlive) > 1))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedTekkousen);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedTekkousen, getUnit(cUnitTypeYPDockAsian), cMilitaryEscrowID, 50);
      return;
   }
}


rule healerMonitor
inactive
group tcComplete
minInterval 30
{
   static int healerPlan = -1;

   int priestCount = kbUnitCount(cMyID, cUnitTypePriest, cUnitStateAlive);
   int missionaryCount = kbUnitCount(cMyID, cUnitTypeMissionary, cUnitStateAlive);
   int surgeonCount = kbUnitCount(cMyID, cUnitTypeSurgeon, cUnitStateAlive);
   int imamCount = kbUnitCount(cMyID, cUnitTypeImam, cUnitStateAlive);
   int natMedicineManCount = kbUnitCount(cMyID, cUnitTypeNatMedicineMan, cUnitStateAlive);
   int xpMedicineManCount = kbUnitCount(cMyID, cUnitTypexpMedicineMan, cUnitStateAlive);
   int xpMedicineManAztecCount = kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive);

   //if (kbGetCiv() == cCivSpanish) 
      //createSimpleMaintainPlanGivenBuilding(cUnitTypeMissionary, 5, true, kbBaseGetMainID(cMyID), 1, getUnit(cUnitTypeChurch));

   if (healerPlan < 0)
   {
      healerPlan = aiPlanCreate("Healer Control Plan", cPlanDefend);

      aiPlanAddUnitType(healerPlan, cUnitTypePriest, priestCount, priestCount, priestCount); 
      aiPlanAddUnitType(healerPlan, cUnitTypeMissionary, missionaryCount, missionaryCount, missionaryCount); 
      aiPlanAddUnitType(healerPlan, cUnitTypeSurgeon, surgeonCount, surgeonCount, surgeonCount); 
      aiPlanAddUnitType(healerPlan, cUnitTypeImam, imamCount, imamCount, imamCount); 
      aiPlanAddUnitType(healerPlan, cUnitTypeNatMedicineMan, natMedicineManCount, natMedicineManCount, natMedicineManCount); 
      aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineMan, xpMedicineManCount, xpMedicineManCount, xpMedicineManCount); 
      if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1) // Add warrior priest only if there is no fire pit to dance at
      {
         aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineManAztec, xpMedicineManAztecCount, xpMedicineManAztecCount, xpMedicineManAztecCount); 
      }
      else
      {
         aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineManAztec, 0, 0, 0); 
      }
      if ((kbGetCiv() == cCivJapanese)&&(kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) > 15))
         aiPlanAddUnitType(healerPlan, cUnitTypeAbstractJapaneseMonk, 0, 1, 2); 
      if ((kbGetCiv() == cCivIndians)&&(kbGetAge() >= cAge3))
         aiPlanAddUnitType(healerPlan, cUnitTypeAbstractIndianMonk, 0, 1, 2);
      aiPlanSetVariableVector(healerPlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetVariableFloat(healerPlan, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);  
      aiPlanSetVariableBool(healerPlan, cDefendPlanPatrol, 0, false);
      aiPlanSetVariableFloat(healerPlan, cDefendPlanGatherDistance, 0, 10.0);
      aiPlanSetInitialPosition(healerPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
      aiPlanSetUnitStance(healerPlan, cUnitStanceDefensive);
      aiPlanSetVariableInt(healerPlan, cDefendPlanRefreshFrequency, 0, 1);
      aiPlanSetVariableInt(healerPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit);
      aiPlanSetDesiredPriority(healerPlan, 95);  // High priority to keep units from being sucked into other plans
      aiPlanSetActive(healerPlan); 
      aiEcho("Creating healer plan");
   }
   else
   {
      aiPlanAddUnitType(healerPlan, cUnitTypePriest, priestCount, priestCount, priestCount); 
      aiPlanAddUnitType(healerPlan, cUnitTypeMissionary, missionaryCount, missionaryCount, missionaryCount); 
      aiPlanAddUnitType(healerPlan, cUnitTypeSurgeon, surgeonCount, surgeonCount, surgeonCount); 
      aiPlanAddUnitType(healerPlan, cUnitTypeImam, imamCount, imamCount, imamCount); 
      aiPlanAddUnitType(healerPlan, cUnitTypeNatMedicineMan, natMedicineManCount, natMedicineManCount, natMedicineManCount); 
      aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineMan, xpMedicineManCount, xpMedicineManCount, xpMedicineManCount); 
      if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1) // Add warrior priest only if there is no fire pit to dance at
      {
         aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineManAztec, xpMedicineManAztecCount, xpMedicineManAztecCount, xpMedicineManAztecCount); 
      }
      else
      {
         aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineManAztec, 0, 0, 0); 
      }
      if ((kbGetCiv() == cCivJapanese)&&(kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) > 15))
         aiPlanAddUnitType(healerPlan, cUnitTypeAbstractJapaneseMonk, 0, 1, 2); 
      if ((kbGetCiv() == cCivIndians)&&(kbGetAge() >= cAge3))
         aiPlanAddUnitType(healerPlan, cUnitTypeAbstractIndianMonk, 0, 1, 2);

      if ((gDefenseReflexBaseID != kbBaseGetMainID(cMyID)) && 
	  (getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)), 100.0) < 5))
      {
         aiPlanSetVariableVector(healerPlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
	 aiPlanSetVariableFloat(healerPlan, cDefendPlanEngageRange, 0, 20);
	 aiPlanSetVariableFloat(healerPlan, cDefendPlanGatherDistance, 0, 10.0);		    
      }
      else
      {
         aiPlanSetVariableVector(healerPlan, cDefendPlanDefendPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	 aiPlanSetVariableFloat(healerPlan, cDefendPlanEngageRange, 0, 20);  
	 aiPlanSetVariableFloat(healerPlan, cDefendPlanGatherDistance, 0, 10.0);
      }
      aiEcho("Updating healer plan");
   }
}


rule useWarParties
inactive
group tcComplete
minInterval 21
{
   // Check to see if town is being overrun. If so, generate a plan
   // to research available war party. 

   // Disable rule for non-native civs
   if (civIsNative() == false)
   {
      xsDisableSelf();
      return;
   }
   
   static int partyPlan = -1;
   vector mainBaseVec = cInvalidVector;
   
   mainBaseVec =  kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, mainBaseVec, 40.0);
   int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive, mainBaseVec, 40.0);

   if (enemyCount >= (allyCount+6)) // We're behind by 6 or more
   {
      aiEcho("***** Starting a party plan, there are "+enemyCount+" enemy units in my base against "+allyCount+" friendlies.");
      if (cMyCiv == cCivXPAztec)
      {
         if(kbTechGetStatus(cTechBigAztecScoutingParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigAztecScoutingParty, getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
         else if(kbTechGetStatus(cTechBigAztecRaidingParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigAztecRaidingParty, getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
         else if(kbTechGetStatus(cTechBigAztecWarParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigAztecWarParty, getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
      }
      else if (cMyCiv == cCivXPIroquois)
      {
         if(kbTechGetStatus(cTechBigIroquoisScoutingParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigIroquoisScoutingParty, getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
         else if(kbTechGetStatus(cTechBigIroquoisRaidingParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigIroquoisRaidingParty, getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
         else if(kbTechGetStatus(cTechBigIroquoisWarParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigIroquoisWarParty, getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
      }
      else // cMyCiv == cCivXPSioux
      {
         if(xsGetTime() > 20*60*1000) // Use only after at least 20 minutes of game time (i.e. 7 units)
            partyPlan = createSimpleResearchPlan(cTechBigSiouxDogSoldiers, getUnitByLocation(cUnitTypeTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
      }
   }
}

rule ManorMonitor
inactive
minInterval 15
{
   if (kbGetCiv() != cCivBritish)  
  {
    xsDisableSelf();
    return;
   }

   if (kbGetBuildLimit(cMyID, gEconUnit) <= kbUnitCount(cMyID, gEconUnit, cUnitStateAlive))
      return;     // Don't build if we're at limit.

   static int ManorPlan = -1;
   int numUnits = 0;  
   int limit = 0;
       
   numUnits = kbGetBuildLimit(cMyID, gEconUnit);
   if (limit < 1)
      return;

   // Create/update maintain plan
   if (ManorPlan < 0)
   {
      ManorPlan = createSimpleMaintainPlan(gEconUnit, numUnits, true, kbBaseGetMainID(cMyID), 1);
   }
   else
   {
      aiPlanSetVariableInt(ManorPlan, cTrainPlanNumberToMaintain, 0, numUnits);
   }
}

rule GermantownFarmersMonitor
inactive
minInterval 30
{     
   if (kbGetCiv() != cCivGermans)  
  {
    xsDisableSelf();
    return;
   }

   if (kbGetBuildLimit(cMyID, cUnitTypeSettlerWagon) <= kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive))
      return;     // Don't build if we're at limit.

   static int SettlerWagonPlan = -1;  
   int numUnits = 0;
   int limit = 0;
        
   limit = kbGetBuildLimit(cMyID, cUnitTypeSettlerWagon);
   if (limit < 1)
      return;

   // Check number of Settler Wagon
   numUnits = kbGetBuildLimit(cMyID, cUnitTypeSettlerWagon);
 
   // Create/update maintain plan
   if (SettlerWagonPlan < 0)
   {
      SettlerWagonPlan = createSimpleMaintainPlan(cUnitTypeSettlerWagon, numUnits, true, kbBaseGetMainID(cMyID), 1);
   }
   else
   {
      aiPlanSetVariableInt(SettlerWagonPlan, cTrainPlanNumberToMaintain, 0, numUnits);
   }  
}

rule createHerdPlan
inactive
group tcComplete
minInterval 22
{
   // Create a herd plan to gather all herdables that we ecounter.
   gHerdPlanID = aiPlanCreate("GatherHerdable Plan", cPlanHerd);
   if (gHerdPlanID >= 0)
   {
      aiPlanAddUnitType(gHerdPlanID, cUnitTypeHerdable, 0, 100, 100);
      aiPlanSetVariableInt(gHerdPlanID, cHerdPlanBuildingTypeID, 0, cUnitTypeTownCenter);
      aiPlanSetVariableFloat(gHerdPlanID, cHerdPlanDistance, 0, 5.0);
      aiPlanSetActive(gHerdPlanID);
   }

   // Disable rule once it's been run
   xsDisableSelf();
}


rule minorTribeTechMonitor
inactive
minInterval 90
{
   int techPlanID = -1;

   // Get techs from different minor tribes one at a time as they become available
   // Unavailable tribes and techs are simply ignored
   // Research plans are "blindly" tried at different trading posts as there is no way to 
   // identify specific trading posts in the AI script

   // Apache techs
   if (kbTechGetStatus(cTechNatXPApacheCactus) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPApacheCactus);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPApacheCactus, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPApacheRaiding) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPApacheRaiding);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPApacheRaiding, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPApacheEndurance) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPApacheEndurance);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPApacheEndurance, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }

   // Carib techs
   if ((kbTechGetStatus(cTechNatCeremonialFeast) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatBlowgunAmbusher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercBlowgunWarrior, cUnitStateAlive) >= 10))
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCeremonialFeast);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatCeremonialFeast, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatKasiriBeer) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatKasiriBeer);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatKasiriBeer, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatCeremonialFeast) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCeremonialFeast);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatCeremonialFeast, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatKasiriBeer) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatKasiriBeer);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatKasiriBeer, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ( (kbTechGetStatus(cTechNatBlowgunnerAmbush) == cTechStatusObtainable) && (kbGetAge() >= cAge3) )
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatBlowgunnerAmbush);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatBlowgunnerAmbush, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }

   // Cherokee techs
   if (kbTechGetStatus(cTechNatBasketweaving) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatBasketweaving);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatBasketweaving, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatSequoyahSyllabary) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatSequoyahSyllabary);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatSequoyahSyllabary, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatWarDance) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatWarDance);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatWarDance, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }

   // Cheyenne techs
   if (kbTechGetStatus(cTechNatXPCheyenneHuntingGrounds) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPCheyenneHuntingGrounds);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPCheyenneHuntingGrounds, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPCheyenneHorseTrading) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPCheyenneHorseTrading);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPCheyenneHorseTrading, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPCheyenneFury) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPCheyenneFury);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPCheyenneFury, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }

   // Comanche techs
   if (kbTechGetStatus(cTechNatTradeLanguage) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatTradeLanguage);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatTradeLanguage, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatHorseBreeding) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatHorseBreeding);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatHorseBreeding, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatMustangs) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatMustangs);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatMustangs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }

   // Cree techs
   if (kbTechGetStatus(cTechNatTextileCraftsmanship) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatTextileCraftsmanship);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatTextileCraftsmanship, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatTanning) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatTanning);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatTanning, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }

   // Huron techs
   if ((kbTechGetStatus(cTechNatXPHuronTradeMonopoly) == cTechStatusObtainable) &&
       (xsGetTime() > 20*60*1000)) // Use only after at least 20 minutes of game time (i.e. 10 units)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPHuronTradeMonopoly);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPHuronTradeMonopoly, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }

   // Inca techs
   if (kbTechGetStatus(cTechNatMetalworking) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatMetalworking);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatMetalworking, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatChasquisMessengers) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatChasquisMessengers);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatChasquisMessengers, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatRoadbuilding) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatRoadbuilding);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatRoadbuilding, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }

   // Klamath techs
   if (kbTechGetStatus(cTechNatXPKlamathWorkEthos) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPKlamathWorkEthos);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPKlamathWorkEthos, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPKlamathStrategy) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPKlamathStrategy);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPKlamathStrategy, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechNatXPKlamathHuckleberryFeast) == cTechStatusObtainable) &&
       (xsGetTime() > 21*60*1000)) // Use only after at least 21 minutes of game time (i.e. 7 crates)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPKlamathHuckleberryFeast);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPKlamathHuckleberryFeast, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }

   // Mapuche techs
   if (kbTechGetStatus(cTechNatXPMapucheTactics) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPMapucheTactics);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPMapucheTactics, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPMapucheAdMapu) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPMapucheAdMapu);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPMapucheAdMapu, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechNatXPMapucheTreatyOfQuillin) == cTechStatusObtainable) &&
       (xsGetTime() > 20*60*1000)) // Use only after at least 20 minutes of game time (i.e. 10 crates)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPMapucheTreatyOfQuillin);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPMapucheTreatyOfQuillin, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }

   // Maya techs
   if (kbTechGetStatus(cTechNatCalendar) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCalendar);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatCalendar, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatCottonArmor) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCottonArmor);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatCottonArmor, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }

   // Navajo techs
   if (kbTechGetStatus(cTechNatXPNavajoCraftsmanship) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPNavajoCraftsmanship);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPNavajoCraftsmanship, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }

   // Seminole techs
   if (kbTechGetStatus(cTechNatBowyery) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatBowyery);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatBowyery, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }

   // Tupi techs
   if (kbTechGetStatus(cTechNatPoisonArrowFrogs) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatPoisonArrowFrogs);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatPoisonArrowFrogs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatForestBurning) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatForestBurning);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatForestBurning, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatAnimalLore) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatAnimalLore);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatAnimalLore, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   // Zapotec techs
   if (kbTechGetStatus(cTechNatXPZapotecCultOfTheDead) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPZapotecCultOfTheDead);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPZapotecCultOfTheDead, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechNatXPZapotecFoodOfTheGods) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPZapotecFoodOfTheGods);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPZapotecFoodOfTheGods, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechNatXPZapotecCloudPeople) == cTechStatusObtainable) &&
       (xsGetTime() > 20*60*1000)) // Use only after at least 20 minutes of game time (i.e. 10 crates)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPZapotecCloudPeople);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechNatXPZapotecCloudPeople, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
      return;
   }
}


rule minorAsianTribeTechMonitor
inactive
minInterval 90
{
   int techPlanID = -1;

   // Get techs from different minor Asian tribes one at a time as they become available
   // Unavailable tribes and techs are simply ignored
   // Research plans are "blindly" tried at different trading posts as there is no way to 
   // identify specific trading posts in the AI script

   // Bhakti techs
   if (kbTechGetStatus(cTechYPNatBhaktiYoga) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatBhaktiYoga);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatBhaktiYoga, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPNatBhaktiReinforcedGuantlets) == cTechStatusObtainable) && (kbGetAge() > cAge3) && (kbUnitCount(cMyID, cUnitTypeypNatTigerClaw, cUnitStateAlive) >= 10)) 
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatBhaktiReinforcedGuantlets);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatBhaktiReinforcedGuantlets, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }

   // Jesuit techs
   if (kbTechGetStatus(cTechYPNatJesuitSmokelessPowder) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatJesuitSmokelessPowder);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatJesuitSmokelessPowder, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechYPNatJesuitFlyingButtress) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatJesuitFlyingButtress);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatJesuitFlyingButtress, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }

   // Shaolin techs
   if (kbTechGetStatus(cTechYPNatShaolinWoodClearing) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatShaolinWoodClearing);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatShaolinWoodClearing, getUnit(cUnitTypeypTradingPostAsian), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechYPNatShaolinClenchedFist) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatShaolinClenchedFist);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatShaolinClenchedFist, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPNatShaolinDimMak) == cTechStatusObtainable) && (kbGetAge() > cAge3) && (kbUnitCount(cMyID, cUnitTypeypNatRattanShield, cUnitStateAlive) >= 10)) 
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatShaolinDimMak);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatShaolinDimMak, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }

   // Sufi techs
   if (kbTechGetStatus(cTechYPNatSufiFasting) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatSufiFasting);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatSufiFasting, getUnit(cUnitTypeypTradingPostAsian), cEconomyEscrowID, 50);
      return;
   }

   // Udasi techs
   if (kbTechGetStatus(cTechYPNatUdasiNewYear) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatUdasiNewYear);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatUdasiNewYear, getUnit(cUnitTypeypTradingPostAsian), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechYPNatUdasiGurus) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatUdasiGurus);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatUdasiGurus, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPNatUdasiArmyOfThePure) == cTechStatusObtainable) && (kbGetAge() > cAge3) && (kbUnitCount(cMyID, cUnitTypeypNatChakram, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercChakram, cUnitStateAlive) >= 10)) 
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatUdasiArmyOfThePure);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatUdasiArmyOfThePure, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }

   // Zen techs
   if (kbTechGetStatus(cTechYPNatZenMasterLessons) == cTechStatusObtainable)
   {
      techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatZenMasterLessons);
      if (techPlanID >= 0)
         aiPlanDestroy(techPlanID);
      createSimpleResearchPlan(cTechYPNatZenMasterLessons, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
}


rule balloonMonitor
inactive
minInterval 22
{
   // Create plan only when balloon available and exploring allowed
   if ((kbUnitCount(cMyID, cUnitTypexpAdvancedBalloon) == 0) || (cvOkToExplore == false))
   {
      return;
   }

   // Create explore plan
   int balloonExplore = aiPlanCreate("Balloon Explore", cPlanExplore);
   aiPlanSetDesiredPriority(balloonExplore, 99);
   aiPlanAddUnitType(balloonExplore, cUnitTypexpAdvancedBalloon, 1, 1, 1);
   aiPlanSetEscrowID(balloonExplore, cEconomyEscrowID);
   aiPlanSetBaseID(balloonExplore, kbBaseGetMainID(cMyID));
   aiPlanSetVariableBool(balloonExplore, cExplorePlanDoLoops, 0, false);
   aiPlanSetActive(balloonExplore);

   // Disable rule
   xsDisableSelf();   
}


rule settlerUpgradeMonitor
inactive
minInterval 180 // research to be started 3 minutes into Age 2
{
   int upgradePlanID = -1;

   // Disable rule once the upgrades are available
   if (civIsNative() == true)
   {
      if (kbTechGetStatus(cTechSpiritMedicine) == cTechStatusActive)
      {
         xsDisableSelf();
         return;
      }
   }
   else if (civIsAsian() == true)
   {
      if (kbTechGetStatus(cTechypMarketSpiritMedicine) == cTechStatusActive)
      {
         xsDisableSelf();
         return;
      }
   }
   else
   {
      if ((kbTechGetStatus(cTechGreatCoat) == cTechStatusActive) &&
          (kbTechGetStatus(cTechBlunderbuss) == cTechStatusActive))
      {
         xsDisableSelf();
         return;
      }
   }

   // Get upgrades one at a time
   if (kbTechGetStatus(cTechSpiritMedicine) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechSpiritMedicine);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechSpiritMedicine, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypMarketSpiritMedicine) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMarketSpiritMedicine);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypMarketSpiritMedicine, getUnit(cUnitTypeypTradeMarketAsian), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechGreatCoat) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGreatCoat);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechGreatCoat, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechBlunderbuss) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBlunderbuss);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechBlunderbuss, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
      return;
   }
}


rule arsenalUpgradeMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;

   // Disable rule for native or Asian civs
   if (civIsEuropean() == false)
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechRifling) == cTechStatusActive) &&
       (kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
       (kbTechGetStatus(cTechBayonet) == cTechStatusActive) &&
       (kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
       (kbTechGetStatus(cTechCaracole) == cTechStatusActive) &&
       (kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusActive) &&
       ((kbTechGetStatus(cTechHeatedShot) == cTechStatusActive) || (getUnit(cUnitTypeHomeCityWaterSpawnFlag) <= 0)))
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no arsenal
   if (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateAlive) < 1)
   {
      return;
   }

   // Get 'Heated Shot' upgrade on water maps
   if ((kbTechGetStatus(cTechHeatedShot) == cTechStatusObtainable) && (getUnit(cUnitTypeHomeCityWaterSpawnFlag) > 0))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeatedShot);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechHeatedShot, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }

   // Get other upgrades one at the time, provided a sufficient number of units to be improved are available
   if ((kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGunnersQuadrant);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechGunnersQuadrant, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechRifling) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatRifleman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatMercRifleman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeMercJaeger, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatTracker, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatMercTracker, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatKlamathRifleman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatNavajoRifleman, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRifling);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechRifling, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechBayonet) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeMercHighlander, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeMercFusilier, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateGuerreiros, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateStadhouders, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBayonet);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechBayonet, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechCaracole) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractLightCavalry, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCaracole);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechCaracole, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechCavalryCuirass) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCavalryCuirass);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechCavalryCuirass, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHandInfantry, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypShinobiHorse, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateShinobi, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateBestieros, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechInfantryBreastplate);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechInfantryBreastplate, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
}


rule arsenalUpgradeAsianMonitor
inactive
minInterval 60
{
   // Disable rule if not Japanese
   if (kbGetCiv() != cCivJapanese)
   {
      xsDisableSelf();
      return;
   }

   int upgradePlanID = -1;

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
       (kbTechGetStatus(cTechBayonet) == cTechStatusActive) &&
       (kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
       (kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusActive) &&
       ((kbTechGetStatus(cTechHeatedShot) == cTechStatusActive) || (getUnit(cUnitTypeHomeCityWaterSpawnFlag) <= 0)))
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no special arsenal built from a wagon around
   if (kbUnitCount(cMyID, cUnitTypeypArsenalAsian, cUnitStateAlive) < 1)
   {
      return;
   }

   // Get 'Heated Shot' upgrade on water maps
   if ((kbTechGetStatus(cTechHeatedShot) == cTechStatusObtainable) && (getUnit(cUnitTypeHomeCityWaterSpawnFlag) > 0))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeatedShot);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechHeatedShot, getUnit(cUnitTypeypArsenalAsian), cMilitaryEscrowID, 50);
      return;
   }

   // Get other upgrades one at the time, provided a sufficient number of units to be improved are available
   if ((kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGunnersQuadrant);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechGunnersQuadrant, getUnit(cUnitTypeypArsenalAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechBayonet) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeMercHighlander, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeMercFusilier, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateGuerreiros, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateStadhouders, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBayonet);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechBayonet, getUnit(cUnitTypeypArsenalAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechCavalryCuirass) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCavalryCuirass);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechCavalryCuirass, getUnit(cUnitTypeypArsenalAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHandInfantry, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypShinobiHorse, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateShinobi, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateBestieros, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechInfantryBreastplate);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechInfantryBreastplate, getUnit(cUnitTypeypArsenalAsian), cMilitaryEscrowID, 50);
      return;
   }
}


rule advancedArsenalUpgradeMonitor
inactive
minInterval 60
{
   int upgradePlanID = -1;

   // Disable rule for native or Asian civs
   if (civIsEuropean() == false)
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechPaperCartridge) == cTechStatusActive) &&
       (kbTechGetStatus(cTechFlintlock) == cTechStatusActive) &&
       (kbTechGetStatus(cTechMilitaryDrummers) == cTechStatusActive) &&
       (kbTechGetStatus(cTechProfessionalGunners) == cTechStatusActive) &&
       (kbTechGetStatus(cTechTrunion) == cTechStatusActive) &&
       (kbTechGetStatus(cTechPillage) == cTechStatusActive) &&
       (kbTechGetStatus(cTechIncendiaryGrenades) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no arsenal
   if (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateAlive) < 1)
   {
      return;
   }

   // Get upgrades one at the time, provided a sufficient number of units to be improved are available
   if ((kbTechGetStatus(cTechPaperCartridge) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPaperCartridge);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechPaperCartridge, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechFlintlock) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFlintlock);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechFlintlock, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechMilitaryDrummers) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechMilitaryDrummers);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechMilitaryDrummers, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechProfessionalGunners) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechProfessionalGunners);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechProfessionalGunners, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechTrunion) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechTrunion);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechTrunion, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechPillage) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 8))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPillage);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechPillage, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechIncendiaryGrenades) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechIncendiaryGrenades);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechIncendiaryGrenades, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
      return;
   }
}


rule goldenPavillionUpgradeMonitor
inactive
minInterval 60
{
   // Disable rule if not Japanese
   if (kbGetCiv() != cCivJapanese)
   {
      xsDisableSelf();
      return;
   }

   int upgradePlanID = -1;
   int pavillionType = -1;

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechPaperCartridge) == cTechStatusActive) &&
       (kbTechGetStatus(cTechFlintlock) == cTechStatusActive) &&
       (kbTechGetStatus(cTechProfessionalGunners) == cTechStatusActive) &&
       (kbTechGetStatus(cTechPillage) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Check for golden pavillion
   if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion2, cUnitStateAlive) > 0)
   {
      pavillionType = cUnitTypeypWJGoldenPavillion2;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion3, cUnitStateAlive) > 0)
   {
      pavillionType = cUnitTypeypWJGoldenPavillion3;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion4, cUnitStateAlive) > 0)
   {
      pavillionType = cUnitTypeypWJGoldenPavillion4;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion5, cUnitStateAlive) > 0)
   {
      pavillionType = cUnitTypeypWJGoldenPavillion5;
   }

   // Quit if there is no golden pavillion
   if (pavillionType < 0)
   {
      return;
   }

   // Get upgrades one at the time, provided a sufficient number of units to be improved are available
   if ((kbTechGetStatus(cTechPaperCartridge) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPaperCartridge);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechPaperCartridge, getUnit(pavillionType), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechFlintlock) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFlintlock);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechFlintlock, getUnit(pavillionType), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechProfessionalGunners) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechProfessionalGunners);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechProfessionalGunners, getUnit(pavillionType), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechPillage) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 8))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPillage);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechPillage, getUnit(pavillionType), cMilitaryEscrowID, 50);
      return;
   }
}

rule newWayIroquoisMonitor
inactive
minInterval 90
{
   if (kbGetCiv() != cCivXPIroquois)
   {
      xsDisableSelf();
      return;
   }

   int upgradePlanID = -1;

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechRifling) == cTechStatusActive) &&
       (kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
       (kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
       (kbTechGetStatus(cTechCaracole) == cTechStatusActive) &&
       ((kbTechGetStatus(cTechHeatedShot) == cTechStatusActive) || (getUnit(cUnitTypeHomeCityWaterSpawnFlag) <= 0)))
   {
      xsDisableSelf();
      return;
   }

   // Get 'Heated Shot' upgrade on water maps
   if ((kbTechGetStatus(cTechHeatedShot) == cTechStatusObtainable) && (getUnit(cUnitTypeHomeCityWaterSpawnFlag) > 0))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeatedShot);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechHeatedShot, getUnit(cUnitTypeLonghouse), cMilitaryEscrowID, 50);
      return;
   }

   // Get other upgrades one at the time, provided a sufficient number of units to be improved are available
   if ((kbTechGetStatus(cTechRifling) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatRifleman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatMercRifleman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeMercJaeger, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatTracker, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatMercTracker, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatKlamathRifleman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatNavajoRifleman, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRifling);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechRifling, getUnit(cUnitTypeLonghouse), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechCaracole) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractLightCavalry, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCaracole);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechCaracole, getUnit(cUnitTypeLonghouse), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechCavalryCuirass) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCavalryCuirass);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechCavalryCuirass, getUnit(cUnitTypeLonghouse), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHandInfantry, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypShinobiHorse, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateShinobi, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateBestieros, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechInfantryBreastplate);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechInfantryBreastplate, getUnit(cUnitTypeLonghouse), cMilitaryEscrowID, 50);
      return;
   }
}


rule newWaySiouxMonitor
inactive
minInterval 90
{
   if (kbGetCiv() != cCivXPSioux)
   {
      xsDisableSelf();
      return;
   }

   int upgradePlanID = -1;

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechRifling) == cTechStatusActive) &&
       (kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
       (kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
       (kbTechGetStatus(cTechCaracole) == cTechStatusActive) &&
       (kbTechGetStatus(cTechPillage) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Get upgrades one at the time, provided a sufficient number of units to be improved are available
   if ((kbTechGetStatus(cTechCaracole) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractLightCavalry, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCaracole);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechCaracole, getUnit(cUnitTypeTeepee), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechPillage) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 8))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPillage);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechPillage, getUnit(cUnitTypeTeepee), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechCavalryCuirass) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCavalryCuirass);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechCavalryCuirass, getUnit(cUnitTypeTeepee), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechRifling) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatRifleman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatMercRifleman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeMercJaeger, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatTracker, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatMercTracker, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatKlamathRifleman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatNavajoRifleman, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRifling);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechRifling, getUnit(cUnitTypeTeepee), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeAbstractHandInfantry, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypShinobiHorse, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateShinobi, cUnitStateAlive) +
        kbUnitCount(cMyID, cUnitTypeypConsulateBestieros, cUnitStateAlive) >= 12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechInfantryBreastplate);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechInfantryBreastplate, getUnit(cUnitTypeTeepee), cMilitaryEscrowID, 50);
      return;
   }
}

rule veteranUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Disable rule for native or Asian civs
   if (civIsEuropean() == false)
   {
      xsDisableSelf();
      return;
   }

   // Get veteran upgrades one at the time, provided a sufficient number of units to be improved are available

   switch(kbGetCiv())
   {
      case cCivBritish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranGrenadiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranLongbowmen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranPikemen) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }
         if ((kbTechGetStatus(cTechVeteranGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranGrenadiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranMusketeers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechVeteranLongbowmen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranLongbowmen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranLongbowmen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechVeteranPikemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranPikemen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranPikemen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivDutch:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranGrenadiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranPikemen) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }
         if ((kbTechGetStatus(cTechVeteranGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranGrenadiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }        
         if ((kbTechGetStatus(cTechVeteranPikemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranPikemen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranPikemen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivFrench:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranCrossbowmen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranPikemen) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }        
         if ((kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranMusketeers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechVeteranCrossbowmen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranCrossbowmen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranCrossbowmen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }         
         if ((kbTechGetStatus(cTechVeteranPikemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranPikemen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranPikemen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivGermans:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechVeteranUhlans) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranDopplesoldners) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranCrossbowmen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranPikemen) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechVeteranUhlans) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeUhlan, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranUhlans);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranUhlans, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }       
         if ((kbTechGetStatus(cTechVeteranDopplesoldners) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDopplesoldner, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranDopplesoldners);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranDopplesoldners, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechVeteranCrossbowmen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranCrossbowmen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranCrossbowmen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }         
         if ((kbTechGetStatus(cTechVeteranPikemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranPikemen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranPikemen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivOttomans:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranAbusGuns) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranGrenadiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranJanissaries) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }
         if ((kbTechGetStatus(cTechVeteranAbusGuns) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranAbusGuns);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranAbusGuns, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechVeteranGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranGrenadiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechVeteranJanissaries) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranJanissaries);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranJanissaries, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivPortuguese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranCrossbowmen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranPikemen) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }         
         if ((kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranMusketeers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechVeteranCrossbowmen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranCrossbowmen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranCrossbowmen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }         
         if ((kbTechGetStatus(cTechVeteranPikemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranPikemen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranPikemen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivRussians:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechVeteranCossacks) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranGrenadiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranStrelets) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechVeteranCossacks) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCossack, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranCossacks);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranCossacks, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }         
         if ((kbTechGetStatus(cTechVeteranGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranGrenadiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranMusketeers, getUnit(cUnitTypeBlockhouse), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechVeteranStrelets) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranStrelets);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranStrelets, getUnit(cUnitTypeBlockhouse), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivSpanish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranRodeleros) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranCrossbowmen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechVeteranPikemen) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }         
         if ((kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranMusketeers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechVeteranRodeleros) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranRodeleros);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranRodeleros, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechVeteranCrossbowmen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranCrossbowmen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranCrossbowmen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }         
         if ((kbTechGetStatus(cTechVeteranPikemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranPikemen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechVeteranPikemen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
   }
}

rule guardUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Disable rule for native or Asian civs
   if (civIsEuropean() == false)
   {
      xsDisableSelf();
      return;
   }

   // Get guard upgrades one at the time, provided a sufficient number of units to be improved are available

   switch(kbGetCiv())
   {
      case cCivBritish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechRGLifeGuardHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardDragoons) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardGrenadiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGRedcoats) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardLongbowmen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGrapeShot) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechRGLifeGuardHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGLifeGuardHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGLifeGuardHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }
         if ((kbTechGetStatus(cTechGuardDragoons) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardDragoons);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardDragoons, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //6))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardGrenadiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechRGRedcoats) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGRedcoats);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGRedcoats, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardLongbowmen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardLongbowmen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardLongbowmen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeavyHorseArtillery);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHeavyHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivDutch:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechGuardHussars) == cTechStatusActive) &&            
             (kbTechGetStatus(cTechGuardGrenadiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGNassausLinearTactics) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardSkirmishers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGrapeShot) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusActive) &&
             ((kbTechGetStatus(cTechGuardRuyters) == cTechStatusActive) ||
             (kbTechGetStatus(cTechRGCarabineer) == cTechStatusActive)))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechGuardHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }
         if ((kbTechGetStatus(cTechGuardRuyters) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeRuyter, cUnitStateAlive) >= 2)) //8))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardRuyters);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardRuyters, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechRGCarabineer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeRuyter, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGCarabineer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGCarabineer, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //6))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardGrenadiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }        
         if ((kbTechGetStatus(cTechRGNassausLinearTactics) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGNassausLinearTactics);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGNassausLinearTactics, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardSkirmishers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardSkirmishers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardSkirmishers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeavyHorseArtillery);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHeavyHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivFrench:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechGuardHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGGendarmes) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardDragoons) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardHalberdiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGVoltigeur) == cTechStatusActive) &&
             (kbTechGetStatus(cTechFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGrapeShot) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechGuardHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }    
         if ((kbTechGetStatus(cTechRGGendarmes) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCuirassier, cUnitStateAlive) >= 2)) //6))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGGendarmes);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGGendarmes, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }   
         if ((kbTechGetStatus(cTechGuardDragoons) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardDragoons);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardDragoons, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechGuardMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardMusketeers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechGuardHalberdiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardHalberdiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardHalberdiers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }         
         if ((kbTechGetStatus(cTechRGVoltigeur) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGVoltigeur);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGVoltigeur, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeavyHorseArtillery);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHeavyHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivGermans:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechRGCzapkaUhlans) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardWarWagons) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardDopplesoldners) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGPrussianNeedleGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGrapeShot) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechRGCzapkaUhlans) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeUhlan, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGCzapkaUhlans);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGCzapkaUhlans, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }       
         if ((kbTechGetStatus(cTechGuardWarWagons) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeWarWagon, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardWarWagons);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardWarWagons, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechGuardDopplesoldners) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDopplesoldner, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardDopplesoldners);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardDopplesoldners, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }         
         if ((kbTechGetStatus(cTechRGPrussianNeedleGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGPrussianNeedleGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGPrussianNeedleGun, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }         
         if ((kbTechGetStatus(cTechFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeavyHorseArtillery);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHeavyHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivOttomans:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechRGGardener) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardAbusGuns) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGBaratcuCorps) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardJanissaries) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardCavalryArchers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGrapeShot) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechRGGardener) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGGardener);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGGardener, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }
         if ((kbTechGetStatus(cTechGuardAbusGuns) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardAbusGuns);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardAbusGuns, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechRGBaratcuCorps) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //6))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGBaratcuCorps);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGBaratcuCorps, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardJanissaries) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardJanissaries);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardJanissaries, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardCavalryArchers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCavalryArcher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardCavalryArchers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardCavalryArchers, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }        
         if ((kbTechGetStatus(cTechHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeavyHorseArtillery);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHeavyHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivPortuguese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechGuardHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGJinetes) == cTechStatusActive)
             (kbTechGetStatus(cTechRGGuerreiros) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardHalberdiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardCacadores) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRabauld) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGrapeShot) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechGuardHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }    
         if ((kbTechGetStatus(cTechRGJinetes) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGJinetes);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGJinetes, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }     
         if ((kbTechGetStatus(cTechRGGuerreiros) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGGuerreiros);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGGuerreiros, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechGuardHalberdiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardHalberdiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardHalberdiers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardCacadores) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardCacadores);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardCacadores, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }       
         if ((kbTechGetStatus(cTechRabauld) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeOrganGun, cUnitStateAlive) >= 2)) //3))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRabauld);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRabauld, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }  
         if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeavyHorseArtillery);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHeavyHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivRussians:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechGuardCossacks) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardOprichniks) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGTartarLoyalists) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGPavlovGrenadiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardHalberdiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardStrelets) == cTechStatusActive) &&
             (kbTechGetStatus(cTechFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGrapeShot) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechGuardCossacks) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCossack, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardCossacks);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardCossacks, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }     
         if ((kbTechGetStatus(cTechGuardOprichniks) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeOprichnik, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardOprichniks);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardOprichniks, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }    
         if ((kbTechGetStatus(cTechRGTartarLoyalists) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCavalryArcher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGTartarLoyalists);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGTartarLoyalists, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechRGPavlovGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //6))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGPavlovGrenadiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGPavlovGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardMusketeers, getUnit(cUnitTypeBlockhouse), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechGuardHalberdiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardHalberdiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardHalberdiers, getUnit(cUnitTypeBlockhouse), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardStrelets) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardStrelets);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardStrelets, getUnit(cUnitTypeBlockhouse), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeavyHorseArtillery);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHeavyHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivSpanish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechGuardHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGGarrochista) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardDragoons) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGuardMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechRGEspadachins) == cTechStatusActive) &&
             ((kbTechGetStatus(cTechGuardPikemen) == cTechStatusActive) ||
             (kbTechGetStatus(cTechRGTercio) == cTechStatusActive)) &&
             (kbTechGetStatus(cTechGuardSkirmishers) == cTechStatusActive)  &&
             (kbTechGetStatus(cTechFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechGrapeShot) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechGuardHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }       
         if ((kbTechGetStatus(cTechRGGarrochista) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeLancer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGGarrochista);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGGarrochista, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }  
         if ((kbTechGetStatus(cTechGuardDragoons) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardDragoons);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardDragoons, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardMusketeers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechRGEspadachins) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeRodelero, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGEspadachins);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGEspadachins, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }   
         if ((kbTechGetStatus(cTechGuardPikemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardPikemen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardPikemen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }      
         if ((kbTechGetStatus(cTechRGTercio) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGTercio);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGTercio, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGuardSkirmishers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardSkirmishers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGuardSkirmishers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeavyHorseArtillery);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechHeavyHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
   }
}

rule imperialUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Disable rule for native or Asian civs
   if (civIsEuropean() == false)
   {
      xsDisableSelf();
      return;
   }

   // Get imperial upgrades one at the time, provided a sufficient number of units to be improved are available

   switch(kbGetCiv())
   {
      case cCivBritish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImperialLifeGuard) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialDragoons) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialGrenadiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialRedcoat) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialLongbowmen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCulverin) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechImperialLifeGuard) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialLifeGuard);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialLifeGuard, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }
         if ((kbTechGetStatus(cTechImperialDragoons) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialDragoons);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialDragoons, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //6))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialGrenadiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialRedcoat) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialRedcoat);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialRedcoat, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialLongbowmen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialLongbowmen);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialLongbowmen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialCulverin) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCulverin);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCulverin, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //5))
	 {
	    upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHorseArtillery);
	    if (upgradePlanID >= 0)
	       aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechImperialHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
	    return;
	 }
         break;
      }
      case cCivDutch:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImperialHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCarabineer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialGrenadiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialNassauers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialSkirmishers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCulverin) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechImperialHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }
         if ((kbTechGetStatus(cTechImperialCarabineer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeRuyter, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCarabineer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCarabineer, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //6))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialGrenadiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }        
         if ((kbTechGetStatus(cTechImperialNassauers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialNassauers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialNassauers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialSkirmishers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialSkirmishers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialSkirmishers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialCulverin) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCulverin);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCulverin, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //5))
	 {
	    upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHorseArtillery);
	    if (upgradePlanID >= 0)
	       aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechImperialHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
	    return;
	 }
         break;
      }
      case cCivFrench:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImperialHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialGendarme) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialDragoons) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHalberdiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialVoltigeur) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCulverin) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechImperialHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }    
         if ((kbTechGetStatus(cTechImperialGendarme) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCuirassier, cUnitStateAlive) >= 2)) //8))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialGendarme);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialGendarme, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }   
         if ((kbTechGetStatus(cTechImperialDragoons) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialDragoons);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialDragoons, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechImperialMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialMusketeers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechImperialHalberdiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHalberdiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHalberdiers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }         
         if ((kbTechGetStatus(cTechImperialVoltigeur) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialVoltigeur);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialVoltigeur, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialCulverin) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCulverin);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCulverin, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //3))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //5))
	 {
	    upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHorseArtillery);
	    if (upgradePlanID >= 0)
	       aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechImperialHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
	    return;
	 }
         break;
      }
      case cCivGermans:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImperialCzapkaUhlans) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialWarWagons) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialDopplesoldner) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialNeedleGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCulverin) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechImperialCzapkaUhlans) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeUhlan, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCzapkaUhlans);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCzapkaUhlans, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }       
         if ((kbTechGetStatus(cTechImperialWarWagons) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeWarWagon, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialWarWagons);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialWarWagons, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechImperialDopplesoldner) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDopplesoldner, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialDopplesoldner);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialDopplesoldner, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }         
         if ((kbTechGetStatus(cTechImperialNeedleGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialNeedleGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechRGPrussianNeedleGun, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialCulverin) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCulverin);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCulverin, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //3))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //5))
	 {
	    upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHorseArtillery);
	    if (upgradePlanID >= 0)
	       aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechImperialHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
	    return;
	 }
         break;
      }
      case cCivOttomans:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImperialGardener) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialAbusGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialBaratcu) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialJanissaries) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCavalryArchers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCulverin) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechImperialGardener) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialGardener);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialGardener, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }
         if ((kbTechGetStatus(cTechImperialAbusGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialAbusGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialAbusGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialBaratcu) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //6))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialBaratcu);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialBaratcu, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialJanissaries) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialJanissaries);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialJanissaries, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialCavalryArchers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCavalryArcher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCavalryArchers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCavalryArchers, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialCulverin) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCulverin);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCulverin, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //3))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //5))
	 {
	    upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHorseArtillery);
	    if (upgradePlanID >= 0)
	       aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechImperialHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
	    return;
	 }
         break;
      }
      case cCivPortuguese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImperialHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialJinetes) == cTechStatusActive)
             (kbTechGetStatus(cTechImperialGuerreiros) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHalberdiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCacadores) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialRabaulds) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCulverin) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechImperialHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }    
         if ((kbTechGetStatus(cTechImperialJinetes) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialJinetes);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialJinetes, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }     
         if ((kbTechGetStatus(cTechImperialGuerreiros) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialGuerreiros);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialGuerreiros, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechImperialHalberdiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHalberdiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHalberdiers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialCacadores) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCacadores);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCacadores, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }     
         if ((kbTechGetStatus(cTechImperialRabaulds) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeOrganGun, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialRabaulds);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialRabaulds, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }    
         if ((kbTechGetStatus(cTechImperialCulverin) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCulverin);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCulverin, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //3))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //5))
	 {
	    upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHorseArtillery);
	    if (upgradePlanID >= 0)
	       aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechImperialHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
	    return;
	 }
         break;
      }
      case cCivRussians:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImperialCossack) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialOprichniks) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialTartarLoyalist) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialPavlovs) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHalberdiers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialStrelets) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCulverin) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechImperialCossack) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCossack, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCossack);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCossack, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }     
         if ((kbTechGetStatus(cTechImperialOprichniks) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeOprichnik, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialOprichniks);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialOprichniks, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }    
         if ((kbTechGetStatus(cTechImperialTartarLoyalist) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCavalryArcher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialTartarLoyalist);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialTartarLoyalist, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialPavlovs) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 2)) //6))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialPavlovs);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialPavlovs, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialMusketeers, getUnit(cUnitTypeBlockhouse), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechImperialHalberdiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHalberdiers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHalberdiers, getUnit(cUnitTypeBlockhouse), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialStrelets) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialStrelets);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialStrelets, getUnit(cUnitTypeBlockhouse), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //5))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialCulverin) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCulverin);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCulverin, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //3))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //5))
	 {
	    upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHorseArtillery);
	    if (upgradePlanID >= 0)
	       aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechImperialHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
	    return;
	 }
         break;
      }
      case cCivSpanish:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImperialHussars) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialGarrochistas) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialDragoons) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialMusketeers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialEspada) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialTercio) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialSkirmishers) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialFieldGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialCulverin) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHowitzer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechImperialHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHussars);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);    
            return;
         }       
         if ((kbTechGetStatus(cTechImperialGarrochistas) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeLancer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialGarrochistas);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialGarrochistas, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }  
         if ((kbTechGetStatus(cTechImperialDragoons) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialDragoons);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialDragoons, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialMusketeers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialMusketeers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         } 
         if ((kbTechGetStatus(cTechImperialEspada) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeRodelero, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialEspada);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialEspada, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }         
         if ((kbTechGetStatus(cTechImperialTercio) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialTercio);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialTercio, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialSkirmishers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialSkirmishers);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialSkirmishers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 2)) //5))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialFieldGun);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialCulverin) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 2)) //5))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCulverin);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialCulverin, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2)) //3))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHowitzer);
            if (upgradePlanID >= 0)
               aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImperialHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 2)) //5))
	 {
	    upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHorseArtillery);
	    if (upgradePlanID >= 0)
	       aiPlanDestroy(upgradePlanID);
	    createSimpleResearchPlan(cTechImperialHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
	    return;
	 }
         break;
      }
   }
}

rule artilleryUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Disable rule for Asians, Aztecs and Sioux 
   if ((civIsAsian() == true) || (kbGetCiv() == cCivXPAztec) || (kbGetCiv() == cCivXPSioux))
   {
      xsDisableSelf();
      return;
   }

   // Get artillery upgrades one at the time, provided a sufficient number of units to be improved are available
   if ((kbTechGetStatus(cTechFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldGun);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeavyHorseArtillery);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechHeavyHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechImperialHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHorseArtillery);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImperialHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechRabauld) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeOrganGun, cUnitStateAlive) >= 2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRabauld);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechRabauld, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechImperialRabaulds) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeOrganGun, cUnitStateAlive) >= 4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialRabaulds);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImperialRabaulds, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHowitzer);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechImperialHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialHowitzer);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImperialHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechFieldCannon) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpLightCannon, cUnitStateAlive) >= 4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldCannon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechFieldCannon, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechImpLegendaryLightCannon) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpLightCannon, cUnitStateAlive) >= 4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryLightCannon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImpLegendaryLightCannon, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
      return;
   }
}


rule eliteUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Disable rule for non-native civs
   if (civIsNative() == false)
   {
      xsDisableSelf();
      return;
   }

   // Get elite upgrades one at the time, provided a sufficient number of units to be improved are available
   switch(kbGetCiv())
   { 
      case cCivXPIroquois:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechEliteHorsemen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechEliteAennas) == cTechStatusActive) &&
             (kbTechGetStatus(cTechEliteTomahawks) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechEliteHorsemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteHorsemen);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechEliteHorsemen, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechEliteAennas) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteAennas);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechEliteAennas, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechEliteTomahawks) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteTomahawks);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechEliteTomahawks, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivXPSioux:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechEliteAxeRiders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechEliteBowRider) == cTechStatusActive) &&
             (kbTechGetStatus(cTechEliteWarBows) == cTechStatusActive) &&
             (kbTechGetStatus(cTechEliteWarClubs) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechEliteAxeRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpAxeRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteAxeRiders);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechEliteAxeRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechEliteBowRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpBowRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteBowRider);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechEliteBowRider, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechEliteWarBows) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteWarBows);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechEliteWarBows, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechEliteWarClubs) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteWarClubs);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechEliteWarClubs, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }        
      case cCivXPAztec:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechEliteCoyotemen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechEliteMacehualtins) == cTechStatusActive) &&
             (kbTechGetStatus(cTechElitePumaMen) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }
         
         if ((kbTechGetStatus(cTechEliteCoyotemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteCoyotemen);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
             createSimpleResearchPlan(cTechEliteCoyotemen, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechEliteMacehualtins) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteMacehualtins);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechEliteMacehualtins, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechElitePumaMen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechElitePumaMen);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechElitePumaMen, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
   }
}

rule championUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Disable rule for non-native civs
   if (civIsNative() == false)
   {
      xsDisableSelf();
      return;
   }

   // Get champion upgrades one at the time, provided a sufficient number of units to be improved are available
   switch(kbGetCiv())
   { 
      case cCivXPIroquois:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChampionMusketRiders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionHorsemen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionMusketWarriors) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionAennas) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionTomahawk) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionMantlets) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionRams) == cTechStatusActive) &&
             (kbTechGetStatus(cTechFieldCannon) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechChampionMusketRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMusketRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMusketRiders);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionMusketRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionHorsemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionHorsemen);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionHorsemen, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionMusketWarriors) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) >= 2)) //12))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMusketWarriors);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionMusketWarriors, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionAennas) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionAennas);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionAennas, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionTomahawk) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionTomahawk);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionTomahawk, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionMantlets) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMantlet, cUnitStateAlive) >= 2)) //8))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMantlets);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionMantlets, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionRams) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpRam, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionRams);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
           createSimpleResearchPlan(cTechChampionRams, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
           return;
         }
         if ((kbTechGetStatus(cTechFieldCannon) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpLightCannon, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldCannon);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechFieldCannon, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivXPSioux:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChampionRifleRiders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionAxeRiders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionBowRider) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionCoupRiders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionWarRifles) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionWarBows) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionWarClubs) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechChampionRifleRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpRifleRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionRifleRiders);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionRifleRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionAxeRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpAxeRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionAxeRiders);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionAxeRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionBowRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpBowRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionBowRider);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionBowRider, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionCoupRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpCoupRider, cUnitStateAlive) >= 2)) //8))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCoupRiders);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionCoupRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionWarRifles) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) >= 2)) //12))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionWarRifles);
            if (upgradePlanID >= 0)
             aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionWarRifles, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionWarBows) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionWarBows);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionWarBows, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionWarClubs) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionWarClubs);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionWarClubs, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }        
      case cCivXPAztec:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechChampionCoyotemen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionMacehualtins) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionPumaMen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionJaguarKnight) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionArrowKnight) == cTechStatusActive) &&
             (kbTechGetStatus(cTechChampionEagleKnight) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }
         
         if ((kbTechGetStatus(cTechChampionCoyotemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCoyotemen);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
             createSimpleResearchPlan(cTechChampionCoyotemen, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionMacehualtins) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMacehualtins);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionMacehualtins, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionPumaMen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionPumaMen);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionPumaMen, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionJaguarKnight) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpJaguarKnight, cUnitStateAlive) >= 2)) //12))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionJaguarKnight);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionJaguarKnight, getUnit(cUnitTypeNoblesHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionArrowKnight) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionArrowKnight);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionArrowKnight, getUnit(cUnitTypeNoblesHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechChampionEagleKnight) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) >= 2)) //12))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionEagleKnight);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechChampionEagleKnight, getUnit(cUnitTypeNoblesHut), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
   }
}

rule legendaryUpgradeMonitor
inactive
minInterval 10
{
   int upgradePlanID = -1;

   // Disable rule for non-native civs
   if (civIsNative() == false)
   {
      xsDisableSelf();
      return;
   }

   // Get legendary upgrades one at the time, provided a sufficient number of units to be improved are available
   switch(kbGetCiv())
   { 
      case cCivXPIroquois:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImpLegendaryMusketRiders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryHorsemen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryMusketWarriors) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryAennas) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryTomahawks) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryMantlets) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryRams) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryLightCannon) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechImpLegendaryMusketRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMusketRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryMusketRiders);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryMusketRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryHorsemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryHorsemen);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryHorsemen, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryMusketWarriors) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) >= 2)) //12))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryMusketWarriors);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryMusketWarriors, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryAennas) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryAennas);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryAennas, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryTomahawks) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryTomahawks);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryTomahawks, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryMantlets) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMantlet, cUnitStateAlive) >= 2)) //8))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryMantlets);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryMantlets, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryRams) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpRam, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryRams);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
           createSimpleResearchPlan(cTechImpLegendaryRams, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
           return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryLightCannon) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpLightCannon, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryLightCannon);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryLightCannon, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivXPSioux:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImpLegendaryRifleRiders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryAxeRiders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryBowRider) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryCoupRiders) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryWarRifles) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryWarBows) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryWarClubs) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechImpLegendaryRifleRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpRifleRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryRifleRiders);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryRifleRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryAxeRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpAxeRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryAxeRiders);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryAxeRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryBowRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpBowRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryBowRider);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryBowRider, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryCoupRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpCoupRider, cUnitStateAlive) >= 2)) //8))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryCoupRiders);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryCoupRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryWarRifles) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) >= 2)) //12))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryWarRifles);
            if (upgradePlanID >= 0)
             aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryWarRifles, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryWarBows) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryWarBows);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryWarBows, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryWarClubs) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryWarClubs);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryWarClubs, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }        
      case cCivXPAztec:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechImpLegendaryCoyoteMen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryMacehualtins) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryPumaMen) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryJaguarKnights) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryArrowKnights) == cTechStatusActive) &&
             (kbTechGetStatus(cTechImpLegendaryEagleKnights) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }
         
         if ((kbTechGetStatus(cTechImpLegendaryCoyoteMen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryCoyoteMen);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
             createSimpleResearchPlan(cTechImpLegendaryCoyoteMen, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryMacehualtins) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryMacehualtins);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryMacehualtins, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryPumaMen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryPumaMen);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryPumaMen, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryJaguarKnights) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpJaguarKnight, cUnitStateAlive) >= 2)) //12))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryJaguarKnights);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryJaguarKnights, getUnit(cUnitTypeNoblesHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryArrowKnights) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryArrowKnights);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryArrowKnights, getUnit(cUnitTypeNoblesHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechImpLegendaryEagleKnights) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) >= 2)) //12))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImpLegendaryEagleKnights);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechImpLegendaryEagleKnights, getUnit(cUnitTypeNoblesHut), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
   }
}

rule disciplinedUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Disable rule for non-Asian civs
   if (civIsAsian() == false)
   {
      xsDisableSelf();
      return;
   }

   // Get disciplined upgrades one at the time, provided a sufficient number of units to be improved are available
   switch(kbGetCiv())
   { 
      case cCivChinese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechYPDisciplinedChuKoNu) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedQiangPikeman) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedSteppeRider) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedKeshik) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedFlameThrower) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechYPDisciplinedChuKoNu) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedChuKoNu);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedChuKoNu, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedQiangPikeman) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedQiangPikeman);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedQiangPikeman, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechEliteTomahawks) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteTomahawks);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechEliteTomahawks, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedSteppeRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypSteppeRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedSteppeRider);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedSteppeRider, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedKeshik) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypKeshik, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedKeshik);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedKeshik, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedFlameThrower) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypFlameThrower, cUnitStateAlive) >= 2)) //4))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedFlameThrower);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedFlameThrower, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
      case cCivJapanese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechYPDisciplinedAshigaru) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedYumi) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedSamurai) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedNaginataRider) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechYPDisciplinedAshigaru) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedAshigaru);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedAshigaru, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedYumi) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedYumi);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedYumi, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedSamurai) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypKensei, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedSamurai);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedSamurai, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedNaginataRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypNaginataRider, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedNaginataRider);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedNaginataRider, getUnit(cUnitTypeypStableJapanese), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }        
      case cCivIndians:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechYPDisciplinedSepoy) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedGurkha) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedRajput) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedCamel) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedCamelGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPDisciplinedFlailElephant) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }
         
         if ((kbTechGetStatus(cTechYPDisciplinedSepoy) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSepoy, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedSepoy);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedSepoy, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedGurkha) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractGurkha, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedGurkha);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedGurkha, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedRajput) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractRajput, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedRajput);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedRajput, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedCamel) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSowar, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedCamel);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedCamel, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedCamelGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractZamburak, cUnitStateAlive) >= 2)) //10))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedCamelGun);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedCamelGun, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
            return;
         }
         if ((kbTechGetStatus(cTechYPDisciplinedFlailElephant) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractMercFlailiphant, cUnitStateAlive) >= 2)) //2))
         {
            upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedFlailElephant);
            if (upgradePlanID >= 0)
              aiPlanDestroy(upgradePlanID);
            createSimpleResearchPlan(cTechYPDisciplinedFlailElephant, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
            return;
         }
         break;
      }
   }
}

rule honoredUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Disable rule for non-Asian civs
   if (civIsAsian() == false)
   {
      xsDisableSelf();
      return;
   }

   // Get honored upgrades one at the time, provided a sufficient number of units to be improved are available
   switch(kbGetCiv())
   { 
      case cCivChinese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechYPHonoredIronFlail) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredMeteorHammer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredArquebusier) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredChangdao) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredChuKoNu) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredQiangPikeman) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredSteppeRider) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredKeshik) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredFlameThrower) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredHandMortar) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechYPHonoredIronFlail) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypIronFlail, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredIronFlail);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredIronFlail, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredMeteorHammer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypMeteorHammer, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredMeteorHammer);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredMeteorHammer, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredArquebusier) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypArquebusier, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredArquebusier);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredArquebusier, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredChangdao) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypChangdao, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredChangdao);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredChangdao, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredChuKoNu) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredChuKoNu);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredChuKoNu, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredQiangPikeman) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredQiangPikeman);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredQiangPikeman, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredSteppeRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypSteppeRider, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredSteppeRider);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredSteppeRider, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredKeshik) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypKeshik, cUnitStateAlive) >= 2)) //2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredKeshik);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredKeshik, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredFlameThrower) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypFlameThrower, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredFlameThrower);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredFlameThrower, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredHandMortar) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypHandMortar, cUnitStateAlive) >= 2)) //6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredHandMortar);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredHandMortar, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
         break;
      }
      case cCivJapanese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechYPHonoredAshigaru) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredYumi) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredSamurai) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredNaginataRider) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredYabusame) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredFlamingArrow) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredMorutaru) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechYPHonoredAshigaru) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredAshigaru);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredAshigaru, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredYumi) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredYumi);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredYumi, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredSamurai) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypKensei, cUnitStateAlive) >= 2)) //8))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredSamurai);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredSamurai, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredNaginataRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypNaginataRider, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredNaginataRider);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredNaginataRider, getUnit(cUnitTypeypStableJapanese), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredYabusame) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypYabusame, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredYabusame);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredYabusame, getUnit(cUnitTypeypStableJapanese), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredFlamingArrow) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypFlamingArrow, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredFlamingArrow);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredFlamingArrow, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredMorutaru) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypMorutaru, cUnitStateAlive) >= 2)) //2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredMorutaru);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredMorutaru, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
         break;
      }        
      case cCivIndians:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechYPHonoredSepoy) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredGurkha) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredRajput) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredCamel) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredCamelGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredMahout) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredHowdah) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredFlailElephant) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPHonoredSiegeElephant) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }
         
         if ((kbTechGetStatus(cTechYPHonoredSepoy) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSepoy, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredSepoy);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredSepoy, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredGurkha) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractGurkha, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredGurkha);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredGurkha, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredRajput) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractRajput, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredRajput);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredRajput, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
      return;
   }
         if ((kbTechGetStatus(cTechYPHonoredCamel) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSowar, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredCamel);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredCamel, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredCamelGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractZamburak, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredCamelGun);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredCamelGun, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredMahout) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractMahout, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredMahout);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredMahout, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredHowdah) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractHowdah, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredHowdah);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredHowdah, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredFlailElephant) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractMercFlailiphant, cUnitStateAlive) >= 2)) //2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredFlailElephant);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredFlailElephant, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPHonoredSiegeElephant) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSiegeElephant, cUnitStateAlive) >= 2)) //2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredSiegeElephant);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPHonoredSiegeElephant, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }  
         break;
      }
   }  
}

rule exaltedUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Disable rule for non-Asian civs
   if (civIsAsian() == false)
   {
      xsDisableSelf();
      return;
   }

   // Get exalted upgrades one at the time, provided a sufficient number of units to be improved are available
   switch(kbGetCiv())
   { 
      case cCivChinese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechYPExaltedIronFlail) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedMeteorHammer) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedArquebusier) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedChangdao) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedChuKoNu) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedQiangPikeman) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedSteppeRider) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedKeshik) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedFlameThrower) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedHandMortar) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechYPExaltedIronFlail) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypIronFlail, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedIronFlail);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedIronFlail, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedMeteorHammer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypMeteorHammer, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedMeteorHammer);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedMeteorHammer, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedArquebusier) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypArquebusier, cUnitStateAlive) >= 2)) //12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedArquebusier);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedArquebusier, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedChangdao) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypChangdao, cUnitStateAlive) >= 2)) //12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedChangdao);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedChangdao, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedChuKoNu) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 2)) //12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedChuKoNu);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedChuKoNu, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedQiangPikeman) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 2)) //12))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedQiangPikeman);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedQiangPikeman, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedSteppeRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypSteppeRider, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedSteppeRider);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedSteppeRider, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedKeshik) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypKeshik, cUnitStateAlive) >= 2)) //2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedKeshik);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedKeshik, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedFlameThrower) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypFlameThrower, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedFlameThrower);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedFlameThrower, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedHandMortar) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypHandMortar, cUnitStateAlive) >= 2)) //6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedHandMortar);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedHandMortar, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
         break;
      }
      case cCivJapanese:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechYPExaltedAshigaru) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedYumi) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedSamurai) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedNaginataRider) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedYabusame) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedFlamingArrow) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedMorutaru) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }

         if ((kbTechGetStatus(cTechYPExaltedAshigaru) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedAshigaru);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedAshigaru, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedYumi) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedYumi);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedYumi, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedSamurai) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypKensei, cUnitStateAlive) >= 2)) //8))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedSamurai);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedSamurai, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
      return;
   }
         if ((kbTechGetStatus(cTechYPExaltedNaginataRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypNaginataRider, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedNaginataRider);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedNaginataRider, getUnit(cUnitTypeypStableJapanese), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedYabusame) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypYabusame, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedYabusame);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedYabusame, getUnit(cUnitTypeypStableJapanese), cMilitaryEscrowID, 50);
      return;
   }  
   if ((kbTechGetStatus(cTechYPExaltedFlamingArrow) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypFlamingArrow, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedFlamingArrow);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedFlamingArrow, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedMorutaru) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypMorutaru, cUnitStateAlive) >= 2)) //2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedMorutaru);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedMorutaru, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
         break;
      }        
      case cCivIndians:
      {
         // Disable rule once all upgrades are available
         if ((kbTechGetStatus(cTechYPExaltedSepoy) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedGurkha) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedRajput) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedCamel) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedCamelGun) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedMahout) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedHowdah) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedFlailElephant) == cTechStatusActive) &&
             (kbTechGetStatus(cTechYPExaltedSiegeElephant) == cTechStatusActive))
         {
            xsDisableSelf();
            return;
         }
         
        if ((kbTechGetStatus(cTechYPExaltedSepoy) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSepoy, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedSepoy);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedSepoy, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedGurkha) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractGurkha, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedGurkha);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedGurkha, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedRajput) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractRajput, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedRajput);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedRajput, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
      return;
   }
         if ((kbTechGetStatus(cTechYPExaltedCamel) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSowar, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedCamel);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedCamel, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedCamelGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractZamburak, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedCamelGun);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedCamelGun, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedMahout) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractMahout, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedMahout);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedMahout, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedHowdah) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractHowdah, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedHowdah);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedHowdah, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedFlailElephant) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractMercFlailiphant, cUnitStateAlive) >= 2)) //2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedFlailElephant);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedFlailElephant, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechYPExaltedSiegeElephant) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSiegeElephant, cUnitStateAlive) >= 2)) //2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPExaltedSiegeElephant);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechYPExaltedSiegeElephant, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
      return;
   }
         break;
      }
   }  
}

rule warriorSocietyUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Get warrior society upgrades one at the time, provided a sufficient number of units to be improved are available
   // Research plans are "blindly" tried at different trading posts as there is no way to identify specific trading posts in the AI script

   if ((kbTechGetStatus(cTechWarriorSocietyAztecs) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatJaguarWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatEagleWarrior, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyAztecs);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyAztecs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyCaribs) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatBlowgunAmbusher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercBlowgunWarrior, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyCaribs);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyCaribs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyCherokee) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatRifleman, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercRifleman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyCherokee);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyCherokee, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyComanche) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatHorseArcher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercHorseArcher, cUnitStateAlive) >= 2)) //6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyComanche);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyComanche, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyCree) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatTracker, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercTracker, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyCree);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyCree, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyInca) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatHuaminca, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyInca);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyInca, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyIroquois) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatTomahawk, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMantlet, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyIroquois);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyIroquois, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
   }
   if ((kbTechGetStatus(cTechWarriorSocietyLakota) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatAxeRider, cUnitStateAlive) >= 2)) //6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyLakota);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyLakota, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyMaya) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatHolcanSpearman, cUnitStateAlive)+ kbUnitCount(cMyID, cUnitTypeNatMercHolcanSpearman, cUnitStateAlive)  >= 10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyMaya);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyMaya, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyNootka) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatClubman, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercClubman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyNootka);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyNootka, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietySeminoles) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietySeminoles);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietySeminoles, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyTupi) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyTupi);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyTupi, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyHuron) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatHuronMantlet, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercHuronMantlet, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyHuron);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyHuron, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyZapotec) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatLightningWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercLightningWarrior, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyZapotec);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyZapotec, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyKlamath) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatKlamathRifleman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyKlamath);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyKlamath, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
   }
   if ((kbTechGetStatus(cTechWarriorSocietyApache) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatApacheCavalry, cUnitStateAlive) >= 2)) //6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyApache);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyApache, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyNavajo) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatNavajoRifleman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyNavajo);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyNavajo, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyCheyenne) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatCheyenneRider, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercCheyenneRider, cUnitStateAlive) >= 2)) //6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyCheyenne);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyCheyenne, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechWarriorSocietyMapuche) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatMapucheClubman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyMapuche);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechWarriorSocietyMapuche, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
}


rule minorNativeChampionUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Get minor native champion upgrades one at the time, provided a sufficient number of units to be improved are available
   // Research plans are "blindly" tried at different trading posts as there is no way to identify specific trading posts in the AI script

   if ((kbTechGetStatus(cTechChampionAztecs) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatJaguarWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatEagleWarrior, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionAztecs);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionAztecs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionCaribs) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatBlowgunAmbusher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercBlowgunWarrior, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCaribs);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionCaribs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionCherokee) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatRifleman, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercRifleman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCherokee);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionCherokee, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionComanche) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatHorseArcher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercHorseArcher, cUnitStateAlive) >= 2)) //6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionComanche);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionComanche, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionCree) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatTracker, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercTracker, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCree);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionCree, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionInca) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatHuaminca, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionInca);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionInca, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionIroquois) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeNatTomahawk, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMantlet, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionIroquois);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionIroquois, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionLakota) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatAxeRider, cUnitStateAlive) >= 2)) //6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionLakota);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionLakota, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionMaya) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatHolcanSpearman, cUnitStateAlive)+ kbUnitCount(cMyID, cUnitTypeNatMercHolcanSpearman, cUnitStateAlive)  >= 10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMaya);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionMaya, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionNootka) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatClubman, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercClubman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionNootka);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionNootka, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionSeminoles) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionSeminoles);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionSeminoles, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionTupi) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionTupi);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionTupi, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionHuron) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatHuronMantlet, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercHuronMantlet, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionHuron);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionHuron, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionZapotec) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatLightningWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercLightningWarrior, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionZapotec);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionZapotec, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionKlamath) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatKlamathRifleman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionKlamath);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionKlamath, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionApache) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatApacheCavalry, cUnitStateAlive) >= 2)) //6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionApache);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionApache, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionNavajo) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatNavajoRifleman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionNavajo);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionNavajo, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionCheyenne) == cTechStatusObtainable) &&
       (kbUnitCount(cMyID, cUnitTypeNatCheyenneRider, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercCheyenneRider, cUnitStateAlive) >= 2)) //6))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCheyenne);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionCheyenne, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechChampionMapuche) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatMapucheClubman, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMapuche);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechChampionMapuche, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
      return;
   }
}

rule minorAsianDisciplinedUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Get disciplined upgrades for minor Asian civilizations one at the time, provided a sufficient number of units to be improved are available
   // Research plans are "blindly" tried at different trading posts as there is no way to identify specific trading posts in the AI script

   if ((kbTechGetStatus(cTechypNatDisciplinedBhakti) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatTigerClaw, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercTigerClaw, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedBhakti);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatDisciplinedBhakti, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypNatDisciplinedJesuit) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatConquistador, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercConquistador, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedJesuit);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatDisciplinedJesuit, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypNatDisciplinedShaolin) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatRattanShield, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercRattanShield, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedShaolin);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatDisciplinedShaolin, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypNatDisciplinedSufi) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatWarElephant, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercWarElephant, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedSufi);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatDisciplinedSufi, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypNatDisciplinedUdasi) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatChakram, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercChakram, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedUdasi);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatDisciplinedUdasi, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypNatDisciplinedZen) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatSohei, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercSohei, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedZen);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatDisciplinedZen, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
}


rule minorAsianHonoredUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Get honored upgrades for minor Asian civilizations one at the time, provided a sufficient number of units to be improved are available
   // Research plans are "blindly" tried at different trading posts as there is no way to identify specific trading posts in the AI script

   if ((kbTechGetStatus(cTechypNatHonoredBhakti) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatTigerClaw, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercTigerClaw, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredBhakti);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatHonoredBhakti, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypNatHonoredJesuit) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatConquistador, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercConquistador, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredJesuit);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatHonoredJesuit, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypNatHonoredShaolin) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatRattanShield, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercRattanShield, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredShaolin);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatHonoredShaolin, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypNatHonoredSufi) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatWarElephant, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercWarElephant, cUnitStateAlive) >= 2)) //4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredSufi);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatHonoredSufi, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypNatHonoredUdasi) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatChakram, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercChakram, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredUdasi);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatHonoredUdasi, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypNatHonoredZen) == cTechStatusObtainable) && 
       (kbUnitCount(cMyID, cUnitTypeypNatSohei, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercSohei, cUnitStateAlive) >= 2)) //10))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredZen);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypNatHonoredZen, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
      return;
   }
}


rule maintainCreeCoureurs
inactive
mininterval 30
{
   static int creePlan = -1;
   static int ambusherPlan = -1;
   int limit = 0;

   // Check build limit, exit if no cree coureurs are available
   limit = kbGetBuildLimit(cMyID, cUnitTypeCoureurCree);
   if (limit < 1)
      return;

   // Create/update maintain plan
   if (creePlan < 0)
   {
      creePlan = createSimpleMaintainPlan(cUnitTypeCoureurCree, limit, true, kbBaseGetMainID(cMyID), 1);
   }
   else
   {
      aiPlanSetVariableInt(creePlan, cTrainPlanNumberToMaintain, 0, limit);
   }
   //Spanish war dog maintain plan.
   //if ( (kbGetCiv() == cCivSpanish) && (aiGetFallenExplorerID() < 0) && (kbResourceGet(cResourceFood) > 500) && (kbGetAge() >= cAge2) )
   //{
      //createSimpleMaintainPlanGivenBuilding(cUnitTypeWarDog, kbGetBuildLimit(cMyID, cUnitTypeWarDog), false, kbBaseGetMainID(cMyID), 5, getUnit(cUnitTypeExplorer));
   //}
   // Create/update maintain plan of Pet Cougar from TC after a Tupi techs researched.
   if ( (kbGetAge() >= cAge2) && (kbResourceGet(cResourceFood) > 100) && (kbTechGetStatus(cTechNatAnimalLore) == cTechStatusActive) )
   {
      createSimpleMaintainPlanGivenBuilding(cUnitTypePetCougar, kbGetBuildLimit(cMyID, cUnitTypePetCougar), false, kbBaseGetMainID(cMyID), 5, getUnit(cUnitTypeTownCenter));
   }
   // Create/update maintain plan of Carib Ambusher.
   if ( (ambusherPlan < 0) && (kbTechGetStatus(cTechNatBlowgunnerAmbush) == cTechStatusActive) && (kbResourceGet(cResourceFood) > 65) && (kbResourceGet(cResourceWood) > 35) )
   {
      ambusherPlan = createSimpleMaintainPlanGivenBuilding(cUnitTypeNatBlowgunAmbusher, kbGetBuildLimit(cMyID, cUnitTypeNatBlowgunAmbusher), false, kbBaseGetMainID(cMyID), 5, getUnit(gExplorerUnit));
   }
   else
   {
      aiPlanSetVariableInt(ambusherPlan, cTrainPlanNumberToMaintain, 0, kbGetBuildLimit(cMyID, cUnitTypeNatBlowgunAmbusher));
   }
   //Chinese disciple maintain plan.
   if ( (kbGetCiv() == cCivChinese) && (aiGetFallenExplorerID() < 0) && (kbResourceGet(cResourceFood) > 1500.0) && (kbGetAge() >= cAge2) )
   {
      createSimpleMaintainPlanGivenBuilding(cUnitTypeypMonkDisciple, kbGetBuildLimit(cMyID, cUnitTypeypMonkDisciple), false, kbBaseGetMainID(cMyID), 5, getUnit(cUnitTypeAbstractChineseMonk));
   }
   /*Aztec Pet Jaguar maintain plan.
   if ( (kbGetCiv() == cCivXPAztec) && (aiGetFallenExplorerID() < 0) && (kbResourceGet(cResourceFood) > 1000) )
   {
      createSimpleMaintainPlanGivenBuilding(cUnitTypePetJaguar, kbGetBuildLimit(cMyID, cUnitTypePetJaguar), false, kbBaseGetMainID(cMyID), 5, getUnit(cUnitTypexpAztecWarchief));
   }
   //Sioux Pet Coyote maintain plan.
   if ( (kbGetCiv() == cCivXPSioux) && (aiGetFallenExplorerID() < 0) && (kbResourceGet(cResourceFood) > 1000) )
   {
      createSimpleMaintainPlanGivenBuilding(cUnitTypePetCoyote, kbGetBuildLimit(cMyID, cUnitTypePetCoyote), false, kbBaseGetMainID(cMyID), 5, getUnit(cUnitTypexpLakotaWarchief));
   }
   //Iroquoi Pet Wolf maintain plan.
   if ( (kbGetCiv() == cCivXPIroquois) && (aiGetFallenExplorerID() < 0) && (kbResourceGet(cResourceFood) > 1000) )
   {
      createSimpleMaintainPlanGivenBuilding(cUnitTypePetWolf, kbGetBuildLimit(cMyID, cUnitTypePetWolf), false, kbBaseGetMainID(cMyID), 5, getUnit(cUnitTypexpIroquoisWarChief));
   }
   */
}

rule setRevolutionFlag
inactive
mininterval 1
{
   if (kbUnitCount(cMyID, cUnitTypexpColonialMilitia, cUnitStateAlive) > 0)
   {
      gRevolutionFlag = true;
      xsDisableSelf();
      return;
   }
}

/*
rule revolutionMonitor
inactive
mininterval 25
{
   int revolutionary = -1;
   int revoltPlan = -1;

   //Are we greater age than our most hated enemy?
   int myAge=kbGetAge();
   int hatedPlayerAge=kbGetAgeForPlayer(aiGetMostHatedPlayerID());

   bool emergency = false;
   bool okToRevolt = false;

   // Quit and disable upon reaching Age 5
   if (kbGetAge() == cAge5)
   {
      xsDisableSelf();
      return;
   }

   // Quit and disable if any player (including myself) has already revolted,
   // i.e. if colonial militia, gatling guns or ironclads have been spotted
   for (player=0; <cNumberPlayers)
   {
      if ((kbUnitCount(player, cUnitTypexpColonialMilitia, cUnitStateAlive) > 0) ||
          (kbUnitCount(player, cUnitTypexpGatlingGun, cUnitStateAlive) > 0) ||
          (kbUnitCount(player, cUnitTypexpIronclad, cUnitStateAlive) > 0))
      {
         xsDisableSelf();
         return;
      }
   }

   // Check if revolution is feasible

   // Revolution aimed at delaying certain defeat
   if (checkRevolutionLastStand() == true)
   {
      emergency = true;
      okToRevolt = true;
   }
   // Revolution aimed at defending an overrun main base
   if (checkRevolutionMegaLevy() == true)
   {
      emergency = true;
      okToRevolt = true;
   }
   // Revolution aimed at breaking an opponent's trade monopoly in team games
   if (checkRevolutionMonopolyBreaker() == true)
   {
      emergency = true;
      okToRevolt = true;
   }
   // Revolution aimed at my greater age than our most hated enemy
   //if ( (myAge > hatedPlayerAge) && (checkRevolutionLastPush() == true) )
   //{  
     // emergency = true;
     // okToRevolt = true;
   //}
   
   // Revolt if revolution is both feasible and affordable
   if (okToRevolt == true)
   {
      // Choose designated revolutionary based on situation
      // No non-emergency situations are implemeted in this AI version
      revolutionary = chooseRevolutionary(emergency);

      if (kbCanAffordTech(revolutionary, cEmergencyEscrowID) == true)
      {
         if (revoltPlan < 0)
         {
            revoltPlan = createSimpleResearchPlan(revolutionary, getUnit(cUnitTypeTownCenter), cEmergencyEscrowID, 99);
            aiEcho("Revolting with politician "+kbGetTechName(revolutionary));
         }
      }
   }
}
*/

rule autoFeedRevolutionary
inactive
mininterval 30
{
   int playerToFeed = -1;

   // Quit and disable if I have revolted myself
   if (gRevolutionFlag == true)
   {
      xsDisableSelf();
      return;
   }

   // Check for a non-human ally who has revolted (there should be only one)
   for (player=0; <cNumberPlayers)
   {
      if (kbUnitCount(player, cUnitTypexpColonialMilitia, cUnitStateAlive) > 0)
      {
         if ((kbIsPlayerAlly(player) == true) && (kbIsPlayerHuman(player) == false) && (kbHasPlayerLost(player) == false))
         {
            playerToFeed = player;
         }
      }
   }

   if ((playerToFeed >= 0) && (playerToFeed != cMyID))
   {
      gFeedFoodTo = playerToFeed;
      gFeedWoodTo = playerToFeed;
      gFeedGoldTo = playerToFeed;

      if (xsIsRuleEnabled("monitorFeeding") == false)
      {
         xsEnableRule("monitorFeeding");
         monitorFeeding();
      }
   }
}

rule autoFeedLowestAlly
inactive
mininterval 30
{  
   if (getHighestResourceAmount() < 10000)
     return;
   
   int lowestAgeAlly = cAge5;
   int totalScoreAlly = 0;
   int averageScoreAlly = 0;
   int player = 1;

   for (player=0; < cNumberPlayers)
   {
      if (kbIsPlayerAlly(player) == true)
      {
	 totalScoreAlly = totalScoreAlly + aiGetScore(player);

	 if (kbGetAgeForPlayer(player) < lowestAgeAlly)
	  lowestAgeAlly = kbGetAgeForPlayer(player); 
      }
   }
   averageScoreAlly = totalScoreAlly / (getAllyCount() + 1);
   
   
for (player=0; < cNumberPlayers)
   {
      if (player == cMyID)
	continue;      
      if (kbIsPlayerAlly(player) == true)
      {
         if ( (kbGetAge() >= cAge5) && 
              (xsGetTime() > 25*60*1000) && 
              (gRevolutionFlag == false) && 
              (kbGetPopCap() - kbGetPop() < 5) && 
              (((kbGetAgeForPlayer(player) == lowestAgeAlly) && 
              (kbGetAgeForPlayer(player) < cAge5)) || 
              (aiGetScore(player) < averageScoreAlly * 0.8)) && 
              (kbHasPlayerLost(player) == false) ) 
	 {
            if (kbResourceGet(cResourceFood) >= 16000)
            {
               aiTribute(player, cResourceFood, 4000);
               sendStatement(cPlayerRelationAlly, cAICommPromptToAllyITributedFood);
            }
            if (kbResourceGet(cResourceWood) >= 16000)
            {
	       aiTribute(player, cResourceWood, 4000);
               sendStatement(cPlayerRelationAlly, cAICommPromptToAllyITributedWood);
            }
            if (kbResourceGet(cResourceGold) >= 16000)
            {
	       aiTribute(player, cResourceGold, 4000);
               sendStatement(cPlayerRelationAlly, cAICommPromptToAllyITributedCoin);
            }
	 }
      }
   }
} 

rule fortUpgradeMonitor
inactive
minInterval 60
{   
   int upgradePlanID = -1;

   // Disable rule once both upgrades are available
   if ((kbTechGetStatus(cTechRevetment) == cTechStatusActive) &&
       (kbTechGetStatus(cTechStarFort) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no fort
   if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive) < 1)
   {
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechRevetment) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRevetment);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechRevetment, getUnit(cUnitTypeFortFrontier), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechStarFort) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechStarFort);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechStarFort, getUnit(cUnitTypeFortFrontier), cMilitaryEscrowID, 50);
      return;
   }
}

rule agraFortUpgradeMonitor
inactive
minInterval 60
{
   // Disable rule for any civ but Indians.
   if (cMyCiv != cCivIndians)
   {
      xsDisableSelf();
      return;
   }

   int upgradePlanID = -1;
   int agraFortType = -1;

   // Disable rule once both upgrades are available
   if ((kbTechGetStatus(cTechypFrontierAgra) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypFortifiedAgra) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Check for agra fort
   if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort2, cUnitStateAlive) > 0)
   {
      agraFortType = cUnitTypeypWIAgraFort2;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort3, cUnitStateAlive) > 0)
   {
      agraFortType = cUnitTypeypWIAgraFort3;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort4, cUnitStateAlive) > 0)
   {
      agraFortType = cUnitTypeypWIAgraFort4;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort5, cUnitStateAlive) > 0)
   {
      agraFortType = cUnitTypeypWIAgraFort5;
   }

   // Quit if there is no agra fort
   if (agraFortType < 0)
   {
      return;
   }

   // Get upgrades one at a time as they become available
   if (kbTechGetStatus(cTechypFrontierAgra) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypFrontierAgra);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypFrontierAgra, getUnit(agraFortType), cMilitaryEscrowID, 50);
      return;
   }
   if (kbTechGetStatus(cTechypFortifiedAgra) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypFortifiedAgra);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypFortifiedAgra, getUnit(agraFortType), cMilitaryEscrowID, 50);
      return;
   }
}

rule shrineUpgradeMonitor
inactive
minInterval 90
{
   // Disable rule for any civ but Japanese.
   if (cMyCiv != cCivJapanese)
   {
      xsDisableSelf();
      return;
   }

   int upgradePlanID = -1;
   int limit = 0;

   // Disable rule once the upgrade is available
   if (kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusActive) 
   {
      xsDisableSelf();
      return;
   }

   // Quit if there are not at least 16 shrines, or a toshogu shrine and at least 10 normal ones
   if ((kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine2, cUnitStateAlive) > 0) ||
       (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine3, cUnitStateAlive) > 0) ||
       (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine4, cUnitStateAlive) > 0) ||
       (kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine5, cUnitStateAlive) > 0))
   {
      limit = 10;
   }
   else
   {
      limit = 16;
   }
   if (kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) < limit)
   {
      return;
   }

   // Get upgrade
   if (kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypShrineFortressUpgrade);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypShrineFortressUpgrade, getUnit(cUnitTypeypShrineJapanese), cEconomyEscrowID, 50);
      return;
   }
}

rule dojoUpgradeMonitor
inactive
minInterval 60
{
   // Disable rule for any civ but Japanese.
   if (cMyCiv != cCivJapanese)
   {
      xsDisableSelf();
      return;
   }

   int upgradePlanID = -1;

   // Disable rule once the upgrade is available
   if (kbTechGetStatus(cTechypDojoUpgrade1) == cTechStatusActive) 
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no dojo
   if (kbUnitCount(cMyID, cUnitTypeypDojo, cUnitStateAlive) < 1)
   {
      return;
   }

   // Get upgrade
   if (kbTechGetStatus(cTechypDojoUpgrade1) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypDojoUpgrade1);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypDojoUpgrade1, getUnit(cUnitTypeypDojo), cMilitaryEscrowID, 50);
      return;
   }
}

rule villageUpgradeMonitor
inactive
group tcComplete
minInterval 15
{
   int upgradePlanID = -1;

   // Disable rule for anybody but Chinese
   if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese))
   {
      xsDisableSelf();
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechypVillagePopCapIncrease) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypVillagePopCapIncrease2) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypVillagePopCapIncrease3) == cTechStatusActive) &&
       (kbTechGetStatus(cTechypVillagePopCapIncrease4) == cTechStatusActive))
   {
      xsDisableSelf();
      return;
   }

   // Quit if there is no village around
   if (kbUnitCount(cMyID, cUnitTypeypVillage, cUnitStateAlive) < 1)
   {
      return;
   }

   // Get upgrades one at a time upon advancing in age
   if ((kbTechGetStatus(cTechypVillagePopCapIncrease) == cTechStatusObtainable) && (kbGetAge() >= cAge2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypVillagePopCapIncrease, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 85);
      return;
   }
   if ((kbTechGetStatus(cTechypVillagePopCapIncrease2) == cTechStatusObtainable) && (kbGetAge() >= cAge3))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease2);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypVillagePopCapIncrease2, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 85);
      return;
   }
   if ((kbTechGetStatus(cTechypVillagePopCapIncrease3) == cTechStatusObtainable) && (kbGetAge() >= cAge4))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease3);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypVillagePopCapIncrease3, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechypVillagePopCapIncrease4) == cTechStatusObtainable) && (kbGetAge() >= cAge5))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease4);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypVillagePopCapIncrease4, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 50);
      return;
   }
}

rule factoryUpgradeMonitor
inactive
minInterval 30
{
   int upgradePlanID = -1;

   // Quit if there is no factory around
   if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) < 1)
   {
      return;
   }

   // Disable rule once all upgrades are available
   if ((kbTechGetStatus(cTechFactoryCannery) == cTechStatusActive) &&
       (kbTechGetStatus(cTechFactoryWaterPower) == cTechStatusActive) &&
       (kbTechGetStatus(cTechFactorySteamPower) == cTechStatusActive) &&
       (kbTechGetStatus(cTechFactoryMassProduction) == cTechStatusActive) ||
      ((kbTechGetStatus(cTechImperialBombard) == cTechStatusActive) ||
        (kbTechGetStatus(cTechImperialCannon) == cTechStatusActive) ||
        (kbTechGetStatus(cTechImperialRocket) == cTechStatusActive)))
   {
      xsDisableSelf();
      return;
   }
   
   // Get upgrades as they become useful
   if (kbTechGetStatus(cTechFactoryCannery) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFactoryCannery);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechFactoryCannery, getUnit(cUnitTypeFactory), cEconomyEscrowID, 85);
      return;
   }
   if (kbTechGetStatus(cTechFactoryWaterPower) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFactoryWaterPower);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechFactoryWaterPower, getUnit(cUnitTypeFactory), cEconomyEscrowID, 85);
      return;
   }
   if ((kbTechGetStatus(cTechFactorySteamPower) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 1))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFactorySteamPower);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechFactorySteamPower, getUnit(cUnitTypeFactory), cEconomyEscrowID, 85);
      return;
   }
   if (kbTechGetStatus(cTechFactoryMassProduction) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFactoryMassProduction);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechFactoryMassProduction, getUnit(cUnitTypeFactory), cMilitaryEscrowID, 85);
      return;
   }
   if ((kbTechGetStatus(cTechImperialBombard) == cTechStatusObtainable) && 
       (kbCanAffordTech(cTechImperialBombard, cMilitaryEscrowID) == true) && 
       (kbUnitCount(cMyID, cUnitTypeGreatBombard, cUnitStateAlive) >= 2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialBombard);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImperialBombard, getUnit(cUnitTypeFactory), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechImperialCannon) == cTechStatusObtainable) && 
       (kbCanAffordTech(cTechImperialCannon, cMilitaryEscrowID) == true) && 
       (kbUnitCount(cMyID, cUnitTypeCannon, cUnitStateAlive) >= 2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCannon);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImperialCannon, getUnit(cUnitTypeFactory), cMilitaryEscrowID, 50);
      return;
   }
   if ((kbTechGetStatus(cTechImperialRocket) == cTechStatusObtainable) && 
       (kbCanAffordTech(cTechImperialRocket, cMilitaryEscrowID) == true) && 
       (kbUnitCount(cMyID, cUnitTypeRocket, cUnitStateAlive) >= 2))
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialRocket);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechImperialRocket, getUnit(cUnitTypeFactory), cMilitaryEscrowID, 50);
      return;
   }
}

rule sheepBritishMonitor
inactive
minInterval 30
{

   static int sheepBritishPlan = -1;
   int numSheep = 0;

   // Build a livestockpen if there is none
   if (kbUnitCount(cMyID, cUnitTypeLivestockPen, cUnitStateAlive) < 1)
   {
      createSimpleBuildPlan(cUnitTypeLivestockPen, 1, 50, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      return;
   }

   // Check number of sheep as necessary to bring total number to 20
   numSheep = 20;

   // Create/update maintain plan
   if (sheepBritishPlan < 0)
   {
      sheepBritishPlan = createSimpleMaintainPlan(cUnitTypeSheep, numSheep, true, kbBaseGetMainID(cMyID), 1);
   }
   else
   {
      aiPlanSetVariableInt(sheepBritishPlan, cTrainPlanNumberToMaintain, 0, numSheep);
   }

   int upgradePlanID = -1;

   // Get selective breeding upgrade
   if (kbTechGetStatus(cTechSelectiveBreeding) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechSelectiveBreeding);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechSelectiveBreeding, getUnit(cUnitTypeLivestockPen), cMilitaryEscrowID, 50);
      return;
   }
}


rule sheepIroquoisMonitor
inactive
minInterval 30
{

   static int sheepIroquoisPlan = -1;
   int numSheep = 0;

   // Build a farm if there is none
   if (kbUnitCount(cMyID, cUnitTypeFarm, cUnitStateAlive) < 1)
   {
      createSimpleBuildPlan(cUnitTypeFarm, 1, 50, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      return;
   }

   // Check number of sheep as necessary to bring total number to 20
   numSheep = 20;

   // Create/update maintain plan
   if (sheepIroquoisPlan < 0)
   {
      sheepIroquoisPlan = createSimpleMaintainPlan(cUnitTypeSheep, numSheep, true, kbBaseGetMainID(cMyID), 1);
   }
   else
   {
      aiPlanSetVariableInt(sheepIroquoisPlan, cTrainPlanNumberToMaintain, 0, numSheep);
   }

   int upgradePlanID = -1;

   // Get selective breeding upgrade
   if (kbTechGetStatus(cTechSelectiveBreeding) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechSelectiveBreeding);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechSelectiveBreeding, getUnit(cUnitTypeFarm), cMilitaryEscrowID, 50);
      return;
   }
}

rule goatMonitor
inactive
minInterval 30
{

   static int goatPlan = -1;
   int numHerdables = 0;
   int numGoats = 0;

   // Build a village if there is none
   if (kbUnitCount(cMyID, cUnitTypeypVillage, cUnitStateAlive) < 1)
   {
      createSimpleBuildPlan(cUnitTypeypVillage, 1, 50, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      return;
   }

   // Check number of captured herdables, add goats as necessary to bring total number to 20
   numHerdables = kbUnitCount(cMyID, cUnitTypeHerdable, cUnitStateAlive) - kbUnitCount(cMyID, cUnitTypeypGoat, cUnitStateAlive);
   if (numHerdables < 0)
      numHerdables = 0;
   numGoats = 20 - numHerdables;
   if (numGoats > 0)
   {
      // Create/update maintain plan
      if (goatPlan < 0)
      {
         goatPlan = createSimpleMaintainPlan(cUnitTypeypGoat, numGoats, true, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(goatPlan, cTrainPlanNumberToMaintain, 0, numGoats);
      }
   }

   int upgradePlanID = -1;

   // Get selective breeding upgrade
   if (kbTechGetStatus(cTechSelectiveBreeding) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechSelectiveBreeding);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechSelectiveBreeding, getUnit(cUnitTypeypVillage), cMilitaryEscrowID, 50);
      return;
   }
}

rule sacredFieldMonitor
inactive
minInterval 60
{
   // Disable rule for anybody but Indians
   if (kbGetCiv() != cCivIndians)
   {
      xsDisableSelf();
      return;
   }

   static int cowPlan = -1;
   int numFields = kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateAlive);
   int numHerdables = kbUnitCount(cMyID, cUnitTypeHerdable, cUnitStateAlive);
   int numSacredCows = kbUnitCount(cMyID, cUnitTypeypSacredCow, cUnitStateAlive);
   int numNonSacredCows = numHerdables - numSacredCows; //sacred cows have also the 'herdable' lable.
   int numCowsToTrain = 10* numFields - numNonSacredCows;

   if ((kbGetAge() <= cAge4) && (numFields == 1) && (numHerdables >= 10))
      return;
   if ((kbGetAge() > cAge4) && (numFields == 2) && (numHerdables >= 20))
      return;

   // Build a sacred field if there is none
   if (((kbGetAge() > cAge3) || (numNonSacredCows > 6))&&(numFields < 1))
   {
      createSimpleBuildPlan(cUnitTypeypSacredField, 1, 50, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
      return;
   }

   if ((kbGetAge() > cAge4)&&(numFields < 2))
   {
      if (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateAlive) < 1)
      {
         createSimpleBuildPlan(cUnitTypeypSacredField, 1, 50, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
         return;
      }
      else // if already a sacred field exists, build another one adjoining it.
      {
         createLocationBuildPlan(cUnitTypeypSacredField, 1, 50, true, cEconomyEscrowID, kbUnitGetPosition(getUnit(cUnitTypeypSacredField)), 1);
         return;
      }
   }

   // Check number of sacred cows as necessary to bring total number to 20  
   // Create/update maintain plan
   if (cowPlan < 0)
   {  
      cowPlan = createSimpleMaintainPlan(cUnitTypeypSacredCow, numCowsToTrain, true, kbBaseGetMainID(cMyID), 1);   
   }
   else
   {  
      aiPlanSetVariableInt(cowPlan, cTrainPlanNumberToMaintain, 0, numCowsToTrain);  
   }

   int upgradePlanID = -1;
   // Get XP upgrade
   if (kbTechGetStatus(cTechypLivestockHoliness) == cTechStatusObtainable)
   {
      upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypLivestockHoliness);
      if (upgradePlanID >= 0)
         aiPlanDestroy(upgradePlanID);
      createSimpleResearchPlan(cTechypLivestockHoliness, getUnit(cUnitTypeypSacredField), cMilitaryEscrowID, 50);
      return;
   }
}

rule wagonMonitor
inactive
group tcComplete
minInterval 15
{
   int planID = -1;
   if ((kbUnitCount(cMyID, gCoveredWagonUnit, cUnitStateAlive) > 0) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeTownCenter) < 0))
   {
      xsEnableRule("useCoveredWagons");
   }
   if ((kbUnitCount(cMyID, cUnitTypeYPVillageWagon, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypVillage) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeypVillage, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
      aiPlanAddUnitType(planID, cUnitTypeYPVillageWagon, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeYPGroveWagon, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypGroveBuilding) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeypGroveBuilding, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
      aiPlanAddUnitType(planID, cUnitTypeYPGroveWagon, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeypArsenalWagon, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypArsenalAsian) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeypArsenalAsian, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
      aiPlanAddUnitType(planID, cUnitTypeypArsenalWagon, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeypBankWagon, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypBankAsian) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeypBankAsian, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
      aiPlanAddUnitType(planID, cUnitTypeypBankWagon, 1, 1, 1);
   }
   if (kbUnitCount(cMyID, cUnitTypeYPMilitaryRickshaw, cUnitStateAlive) > 0) 
   {
      planID = createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 75, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
      aiPlanAddUnitType(planID, cUnitTypeYPMilitaryRickshaw, 1, 1, 1);
   }
   if (kbUnitCount(cMyID, cUnitTypeYPDojoWagon, cUnitStateAlive) > 0) 
   {
      planID = createSimpleBuildPlan(cUnitTypeypDojo, 1, 75, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
      aiPlanAddUnitType(planID, cUnitTypeYPDojoWagon, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeypChurchWagon, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypChurch) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeypChurch, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
      aiPlanAddUnitType(planID, cUnitTypeypChurchWagon, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeypBlockhouseWagon, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBlockhouse) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeBlockhouse, 1, 75, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
      aiPlanAddUnitType(planID, cUnitTypeypBlockhouseWagon, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeFarmTravois, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeFarm) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeFarm, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
      aiPlanAddUnitType(planID, cUnitTypeFarmTravois, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeWarHutTravois, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeWarHut, 1, 75, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
      aiPlanAddUnitType(planID, cUnitTypeWarHutTravois, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeNoblesHutTravois, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeNoblesHut) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 75, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
      aiPlanAddUnitType(planID, cUnitTypeNoblesHutTravois, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeFortWagon, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeFortFrontier) < 0))
   {
      planID = createLocationBuildPlan(cUnitTypeFortFrontier, 1, 85, false, cMilitaryEscrowID, gForwardBaseLocation, 0);
      aiPlanAddUnitType(planID, cUnitTypeFortWagon, 1, 1, 1);
   }   
   // Check if we have a factory wagon, but no factory build plan....
   if ((kbUnitCount(cMyID, cUnitTypeFactoryWagon, cUnitStateAlive) > 0) &&
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeFactory) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeFactory, 1, 80, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0); //No settler builders
      aiPlanAddUnitType(planID, cUnitTypeFactoryWagon, 1, 1, 1);
   }  
   // Check if we have a rice paddy wagon, but no build plan....
   if ((kbUnitCount(cMyID, cUnitTypeYPRicePaddyWagon, cUnitStateAlive) > 0) &&
        (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypRicePaddy) < 0))
   {
      planID = createSimpleBuildPlan(cUnitTypeypRicePaddy, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);  // No settler builders
      aiPlanAddUnitType(planID, cUnitTypeYPRicePaddyWagon, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeypShrineWagon, cUnitStateAlive) > 0) && 
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypShrineJapanese) < 0))
   {  
      vector shrineBuildPlace = shrineBuildPlaceSearch();       
      planID =  createLocationBuildPlan(cUnitTypeypShrineJapanese, 1, 90, true, cEconomyEscrowID, shrineBuildPlace, 0);
      aiPlanAddUnitType(planID, cUnitTypeypShrineWagon, 1, 1, 1);
   }
   if ((kbUnitCount(cMyID, cUnitTypeYPBerryWagon1, cUnitStateAlive) > 0) && 
       (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypBerryBuilding) < 0))
   {     
      planID = createLocationBuildPlan(cUnitTypeypBerryBuilding, 1, 90, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 0);  
      aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 15.0);
      aiPlanAddUnitType(planID, cUnitTypeYPBerryWagon1, 1, 1, 1);
   }        
}

rule brigadeMonitor
inactive
minInterval 27
{
   // Quit if there is no consulate
   if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateAlive) < 1)
   {
      return;
   }

   // Research brigade technologies
   // Unavailable ones are simply ignored
   int brigadePlanID = -1;

   // British brigade
   if (kbTechGetStatus(cTechypConsulateBritishBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateBritishBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Dutch brigade
   if (kbTechGetStatus(cTechypConsulateDutchBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateDutchBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // French brigade
   if (kbTechGetStatus(cTechypConsulateFrenchBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateFrenchBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // German brigade
   if (kbTechGetStatus(cTechypConsulateGermansBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateGermansBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Ottoman brigade
   if (kbTechGetStatus(cTechypConsulateOttomansBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateOttomansBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateOttomansBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Portuguese brigade
   if (kbTechGetStatus(cTechypConsulatePortugueseBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulatePortugueseBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulatePortugueseBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Russian brigade
   if (kbTechGetStatus(cTechypConsulateRussianBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateRussianBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }

   // Spanish brigade
   if (kbTechGetStatus(cTechypConsulateSpanishBrigade) == cTechStatusObtainable)
   {
      brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateSpanishBrigade);
      if (brigadePlanID >= 0)
         aiPlanDestroy(brigadePlanID);
      createSimpleResearchPlan(cTechypConsulateSpanishBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
      return;
   }
}

rule consulateLevy
inactive
minInterval 43
{
   // Check to see if town is being overrun. If so, generate a plan
   // to research Ottoman levy at the consulate. 

   int levyPlan = -1;
   vector mainBaseVec = cInvalidVector;
   
   mainBaseVec =  kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, mainBaseVec, 40.0);
   int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive, mainBaseVec, 40.0);

   if (enemyCount >= (allyCount+6)) // We're behind by 6 or more
   {
      aiEcho("***** Starting consulate levy plan, there are "+enemyCount+" enemy units in my base against "+allyCount+" friendlies.");
      if (kbTechGetStatus(cTechypConsulateOttomansSettlerCombat) == cTechStatusObtainable)
         levyPlan = createSimpleResearchPlan(cTechypConsulateOttomansSettlerCombat, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 99); // Extreme priority
   }
}

rule porcelainTowerTacticMonitor
inactive
group tcComplete
mininterval 60
{
   // Disable rule for anybody but Chinese
   if (kbGetCiv() != cCivChinese)
   {
      xsDisableSelf();
      return;
   }

   int i=0;
   int porcelainTowerType = -1;
   static int resourceType = -1;

   // Check for porcelain tower
   if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower2, cUnitStateAlive) > 0)
   {
      porcelainTowerType = cUnitTypeypWCPorcelainTower2;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower3, cUnitStateAlive) > 0)
   {
      porcelainTowerType = cUnitTypeypWCPorcelainTower3;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower4, cUnitStateAlive) > 0)
   {
      porcelainTowerType = cUnitTypeypWCPorcelainTower4;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower5, cUnitStateAlive) > 0)
   {
      porcelainTowerType = cUnitTypeypWCPorcelainTower5;
   }


   float percentOnFood = aiGetResourceGathererPercentage(cResourceFood, cRGPActual);
   float percentOnWood = aiGetResourceGathererPercentage(cResourceWood, cRGPActual);
   float percentOnGold = aiGetResourceGathererPercentage(cResourceGold, cRGPActual);
   float totalResources = kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);

   if (porcelainTowerType > 0)
   {
      int porcelainTowerQueryID = -1;
      porcelainTowerQueryID = kbUnitQueryCreate("porcelainTowerQueryID");
      kbUnitQuerySetIgnoreKnockedOutUnits(porcelainTowerQueryID, true);
      if (porcelainTowerQueryID != -1)
      {
         kbUnitQuerySetPlayerRelation(porcelainTowerQueryID, -1);
         kbUnitQuerySetPlayerID(porcelainTowerQueryID, cMyID);
         kbUnitQuerySetUnitType(porcelainTowerQueryID, porcelainTowerType);
         kbUnitQuerySetState(porcelainTowerQueryID, cUnitStateAlive);
         kbUnitQueryResetResults(porcelainTowerQueryID);
         int numberFound = kbUnitQueryExecute(porcelainTowerQueryID);

         // Cycle resource generation through all three resources
         // (resources types are 0 - food, 1 - wood, 2 - coin)
         if (numberFound > 0)
         {
            
            for (i=0; < numberFound)
            {
               if ((percentOnFood < 0.40) && (kbResourceGet(cResourceFood) < (totalResources / 10.0)) )
                  aiUnitSetTactic(kbUnitQueryGetResult(porcelainTowerQueryID, i), cTacticWonderFood);

               if ((percentOnWood < 0.90) && (kbResourceGet(cResourceWood) < (totalResources / 10.0)) )
                  aiUnitSetTactic(kbUnitQueryGetResult(porcelainTowerQueryID, i), cTacticWonderWood);

               if ((percentOnGold < 0.30) && (kbResourceGet(cResourceGold) < (totalResources / 10.0)) )
                  aiUnitSetTactic(kbUnitQueryGetResult(porcelainTowerQueryID, i), cTacticWonderCoin);

               //if (totalResources > 10000)
                  //aiUnitSetTactic(kbUnitQueryGetResult(porcelainTowerQueryID, i), cTacticWonderRainbow);
            }            
         }
      }
   }
}

rule summerPalaceTacticMonitor
inactive
mininterval 16
{
   // Disable rule for anybody but Chinese
   if (kbGetCiv() != cCivChinese)
   {
      xsDisableSelf();
      return;
   }

   static bool summerPalaceBuilt = false;
   static bool summerPalaceBuiltConfirm = false;
   int summerPalaceType = -1;
   
   // Check for summer palace
   if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace2, cUnitStateAlive) > 0)
   {
      summerPalaceType = cUnitTypeypWCSummerPalace2;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace3, cUnitStateAlive) > 0)
   {
      summerPalaceType = cUnitTypeypWCSummerPalace3;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace4, cUnitStateAlive) > 0)
   {
      summerPalaceType = cUnitTypeypWCSummerPalace4;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace5, cUnitStateAlive) > 0)
   {
      summerPalaceType = cUnitTypeypWCSummerPalace5;
   }

   if (summerPalaceType < 0)
   {
      if (summerPalaceBuilt == false)  // not built yet.
	return;
      else  // built and lost 
      {
 	  xsDisableSelf();
	  return;   
      }
   }

   //when we're here, Summer Palace wonder has been built and still exists(summerPalaceType >= 0).
   if (summerPalaceBuiltConfirm == false)
   {
      summerPalaceBuilt = true;
      summerPalaceBuiltConfirm = true;
   }

   if (summerPalaceType > 0)
   {
      int summerPalaceQueryID = -1;
      summerPalaceQueryID = kbUnitQueryCreate("summerPalaceQueryID");
      kbUnitQuerySetIgnoreKnockedOutUnits(summerPalaceQueryID, true);
      if (summerPalaceQueryID != -1)
      {
         kbUnitQuerySetPlayerRelation(summerPalaceQueryID, -1);
         kbUnitQuerySetPlayerID(summerPalaceQueryID, cMyID);
         kbUnitQuerySetUnitType(summerPalaceQueryID, summerPalaceType);
         kbUnitQuerySetState(summerPalaceQueryID, cUnitStateAlive);
         kbUnitQueryResetResults(summerPalaceQueryID);
         int numberFound = kbUnitQueryExecute(summerPalaceQueryID);

         // In Age 2 and above, spawn ming army
         if ((numberFound > 0) && (kbGetAge() >= cAge2))
         {
            aiUnitSetTactic(kbUnitQueryGetResult(summerPalaceQueryID, 0), cTacticOldHanArmy);
            xsDisableSelf();
         }
      }
   }
}

rule goldenPavillionTacticMonitor
inactive
group tcComplete
mininterval 34
{
   // Disable rule for anybody but Japanese
   if (kbGetCiv() != cCivJapanese)
   {
      xsDisableSelf();
      return;
   }

   static bool goldenPavillionBuilt = false;
   static bool goldenPavillionBuiltConfirm = false;
   int goldenPavillionType = -1;

   // Check for golden pavillion
   if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion2, cUnitStateAlive) > 0)
   {
      goldenPavillionType = cUnitTypeypWJGoldenPavillion2;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion3, cUnitStateAlive) > 0)
   {
      goldenPavillionType = cUnitTypeypWJGoldenPavillion3;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion4, cUnitStateAlive) > 0)
   {
      goldenPavillionType = cUnitTypeypWJGoldenPavillion4;
   }
   else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion5, cUnitStateAlive) > 0)
   {
      goldenPavillionType = cUnitTypeypWJGoldenPavillion5;
   }

   if (goldenPavillionType < 0)
   {
      if (goldenPavillionBuilt == false) // not built yet.
	 return;
      else // built and lost 
      {
 	 xsDisableSelf();
	 return;
      }
   }

   //when we're here, Golden Pavillion wonder has been built and still exists(goldenPavillionType >= 0).
   if (goldenPavillionBuiltConfirm == false)
   {
      goldenPavillionBuilt = true;
      goldenPavillionBuiltConfirm = true;
   }

   static int enemyPointQuery = -1;
   enemyPointQuery = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeLogicalTypeLandMilitary, cUnitStateABQ);
   kbUnitQueryResetResults(enemyPointQuery);
   int enemyCount = kbUnitQueryExecute(enemyPointQuery);

   if (enemyCount < 5) //don't bother if little enemy found.
      return;

   int enemyPointID = 0;
   vector enemyPointVector = cInvalidVector;
   int enemyPointCount = 0;
   int selfPointCount = 0;
   int selfRangedUnitCount = 0;
   int selfHandUnitCount = 0;
   bool rangedUnitDominating = false;
   int i = 0;
   for (i=0; <enemyCount)
   {
	enemyPointID = kbUnitQueryGetResult(enemyPointQuery, i);
	enemyPointVector = kbUnitGetPosition(enemyPointID);
	enemyPointCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, enemyPointVector, 30.0);
	selfPointCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cMyID, cUnitStateAlive, enemyPointVector, 30.0);
	selfRangedUnitCount = getUnitCountByLocation(cUnitTypeAbstractRangedInfantry, cMyID, cUnitStateAlive, enemyPointVector, 30.0) + getUnitCountByLocation(cUnitTypeAbstractRangedCavalry, cMyID, cUnitStateAlive, enemyPointVector, 30.0);
	selfHandUnitCount = selfPointCount - selfRangedUnitCount;	   
	if ((enemyPointCount >= 5) && (selfRangedUnitCount > 10)&&(selfRangedUnitCount > selfHandUnitCount*2))
	{
	   rangedUnitDominating = true;
	   break;
	}
   }
   if (rangedUnitDominating == true)
      aiUnitSetTactic(goldenPavillionType, cTacticRangeDamage);
   else
      aiUnitSetTactic(goldenPavillionType, cTacticUnitHitpoints);
}

rule dojoTacticMonitor
inactive
minInterval 16
{
   int randomizer = -1;
   static int dojoTactic1 = -1;
   static int dojoTactic2 = -1;

   // Randomize unit generation option for first dojo
   if (dojoTactic1 < 0)
   {
      randomizer = aiRandInt(2);
      switch (randomizer)
      {
         case 0:
         {
            dojoTactic1 = cTacticSamurai;
            break;
         }
         default:
         {
            dojoTactic1 = cTacticYabusame;
            break;
         }
      }
   }

   // Randomize unit generation option for second dojo
   if (dojoTactic2 < 0)
   {
      randomizer = aiRandInt(2);
      switch (randomizer)
      {
         case 0:
         {
            dojoTactic2 = cTacticSamurai;
            break;
         }
         default:
         {
            dojoTactic2 = cTacticYabusame;
            break;
         }
      }
   }

   // Define a query to get all matching units
   int dojoQueryID=-1;
   dojoQueryID=kbUnitQueryCreate("dojoGetUnitQuery");
   kbUnitQuerySetIgnoreKnockedOutUnits(dojoQueryID, true);
   if (dojoQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(dojoQueryID, -1);
      kbUnitQuerySetPlayerID(dojoQueryID, cMyID);
      kbUnitQuerySetUnitType(dojoQueryID, cUnitTypeypDojo);
      kbUnitQuerySetState(dojoQueryID, cUnitStateAlive);
      kbUnitQueryResetResults(dojoQueryID);
      int numberFound=kbUnitQueryExecute(dojoQueryID);
      if (numberFound == 1)
      {
         aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 0), dojoTactic1);
      }
      else if (numberFound == 2)
      {
         aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 0), dojoTactic1);
         aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 1), dojoTactic2);
         xsDisableSelf();
      }
   }
}

rule factoryTacticMonitor
inactive
minInterval 16
{
  
   // Define a query to get all matching units
   int factoryQueryID=-1;
   factoryQueryID=kbUnitQueryCreate("factoryGetUnitQuery");
   kbUnitQuerySetIgnoreKnockedOutUnits(factoryQueryID, true);
   if (factoryQueryID != -1)
   {
      kbUnitQuerySetPlayerRelation(factoryQueryID, -1);
      kbUnitQuerySetPlayerID(factoryQueryID, cMyID);
      kbUnitQuerySetUnitType(factoryQueryID, cUnitTypeFactory);
      kbUnitQuerySetState(factoryQueryID, cUnitStateAlive);
      kbUnitQueryResetResults(factoryQueryID);
   }
   
   int numberFound=kbUnitQueryExecute(factoryQueryID);
   // wait until a factory is found.
   if (numberFound < 1)
     return;

   int index = 0;
   float percentOnFood = aiGetResourceGathererPercentage(cResourceFood, cRGPActual);
   float percentOnWood = aiGetResourceGathererPercentage(cResourceWood, cRGPActual);
   float percentOnGold = aiGetResourceGathererPercentage(cResourceGold, cRGPActual);
   float totalResources = kbResourceGet(cResourceFood) + kbResourceGet(cResourceWood) + kbResourceGet(cResourceGold);
   
   for (index = 0; < numberFound) 
   {
       if ((percentOnFood < 0.40) && (kbResourceGet(cResourceFood) < (totalResources / 10.0)) )
          aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, index), cTacticFood);

       if ((percentOnWood < 0.90) && (kbResourceGet(cResourceWood) < (totalResources / 10.0)) )
          aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, index), cTacticWood);

       if ((percentOnGold < 0.30) && (kbResourceGet(cResourceGold) < (totalResources / 10.0)) )
          aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, index), cTacticNormal);
   }
}

rule mansabdarMonitor
inactive
minInterval 40
{
   // Disable rule for anybody but Indians
   if (kbGetCiv() != cCivIndians)
   {
      xsDisableSelf();
      return;
   }

   static int mansabdarGurkhaPlan = -1;
   static int mansabdarSepoyPlan = -1;
   static int mansabdarZamburakPlan = -1;
   static int mansabdarSiegeElephantPlan = -1;
   static int mansabdarFlailiphantPlan = -1;

   int numGurkhas = -1;
   int numSepoys = -1;
   int numZamburaks = -1;
   int numSiegeElephants = -1;
   int numFlailiphants = -1;

   // Check number of gurkhas, maintain mansabdar gurkha as long as there are at least 10
   numGurkhas = kbUnitCount(cMyID, cUnitTypeypNatMercGurkha, cUnitStateAlive);
   if (numGurkhas >= 0)
   {
      // Create/update maintain plan
      if (mansabdarGurkhaPlan < 0)
      {
         mansabdarGurkhaPlan = createSimpleMaintainPlan(cUnitTypeypNatMercGurkhaJemadar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarGurkhaPlan , cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarGurkhaPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarGurkhaPlan , cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of sepoys, maintain mansabdar sepoy as long as there are at least 10
   numSepoys = kbUnitCount(cMyID, cUnitTypeypSepoy, cUnitStateAlive);
   if (numSepoys >= 0)
   {
      // Create/update maintain plan
      if (mansabdarSepoyPlan < 0)
      {
         mansabdarSepoyPlan = createSimpleMaintainPlan(cUnitTypeypSepoyMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarSepoyPlan , cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarSepoyPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarSepoyPlan , cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of zamburaks, maintain mansabdar zamburak as long as there are at least 10
   numZamburaks = kbUnitCount(cMyID, cUnitTypeypZamburak, cUnitStateAlive);
   if (numZamburaks >= 0)
   {
      // Create/update maintain plan
      if (mansabdarZamburakPlan < 0)
      {
         mansabdarZamburakPlan = createSimpleMaintainPlan(cUnitTypeypZamburakMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarZamburakPlan , cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarZamburakPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarZamburakPlan , cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of siegeelephants, maintain mansabdar siegeelephant as long as there are at least 2
   numSiegeElephants = kbUnitCount(cMyID, cUnitTypeypSiegeElephant, cUnitStateAlive);
   if (numSiegeElephants >= 0)
   {
      // Create/update maintain plan
      if (mansabdarSiegeElephantPlan < 0)
      {
         mansabdarSiegeElephantPlan = createSimpleMaintainPlan(cUnitTypeypSiegeElephantMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarSiegeElephantPlan , cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarSiegeElephantPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarSiegeElephantPlan , cTrainPlanNumberToMaintain, 0, 0);
      }
   }
   // Check number of flailiphants, maintain mansabdar flailiphant as long as there are at least 10
   numFlailiphants = kbUnitCount(cMyID, cUnitTypeAbstractMercFlailiphant, cUnitStateAlive);
   if (numFlailiphants >= 0)
   {
      // Create/update maintain plan
      if (mansabdarFlailiphantPlan < 0)
      {
         mansabdarFlailiphantPlan = createSimpleMaintainPlan(cUnitTypeypMercFlailiphantMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
      }
      else
      {
         aiPlanSetVariableInt(mansabdarFlailiphantPlan , cTrainPlanNumberToMaintain, 0, 1);
      }
   }
   else
   {
      // Update maintain plan, provided it exists
      if (mansabdarFlailiphantPlan >= 0)
      {
         aiPlanSetVariableInt(mansabdarFlailiphantPlan , cTrainPlanNumberToMaintain, 0, 0);
      }
   }
}

rule sendChatToMyAllies
inactive
group tcComplete
mininterval 10
{
    static bool agingUpTo2ChatSent = false;
    static bool agingUpTo3ChatSent = false;
    static bool agingUpTo4ChatSent = false;
    static bool agingUpTo5ChatSent = false;

    if (agingUpTo2ChatSent == false)
    {
       if (agingUpTo(cAge2) == true)
       {
	   sendChatToAllies("Aging up to Colonial soon");          
	   econMaster();
	   xsEnableRule("age2Monitor");
	   agingUpTo2ChatSent = true;
       }       
    }
    if (agingUpTo3ChatSent == false)
    {
       if (agingUpTo(cAge3) == true)
       { 
	  sendChatToAllies("Aging up to Fortress soon");        
	  econMaster();
	  xsEnableRule("age3Monitor");
	  agingUpTo3ChatSent = true;
       }
     }
     if (agingUpTo4ChatSent == false)
     {
	if (agingUpTo(cAge4) == true) 
	{
	   sendChatToAllies("Aging up to Industrial soon");
	   econMaster();
	   xsEnableRule("age4Monitor");
	   agingUpTo4ChatSent = true;
	}
     }
     if (agingUpTo5ChatSent == false)
     {
	if (agingUpTo(cAge5) == true)
	{ 
	   sendChatToAllies("Aging up to Imperial soon");
	   econMaster();           
	   xsEnableRule("age5Monitor");
	   agingUpTo5ChatSent = true;
	}
    }

    static bool strategyChatSent = false;
    if (strategyChatSent == false)
    {
       if (xsGetTime() > 10000)
       {
	  strategyChatSent = true;
	  if (kbGetAge() >= cAge1)
	  {
	     if (gInitialStrategy == 0)
		sendChatToAllies("Target Strategy: FI");
	     if (gInitialStrategy == 1)
		sendChatToAllies("Target Strategy: Rush");
             if (gInitialStrategy == 2)	
                sendChatToAllies("Target Strategy: FF");
             if (gInitialStrategy == 3)
                sendChatToAllies("Target Strategy: Turtle");
          }
       }
    }

    static int lastTribSentTime = 0;
    /////////Tell allies your military combination/////////
    int gLandUnit = kbUnitPickGetResult(gLandUnitPicker, 0);
    string namePrimary = kbGetUnitTypeName(gLandUnit);
    if (gLandPrimaryArmyUnit < 0)
       namePrimary ="----";		
    if (gInitialStrategy != -1)
    {
       if ( ((xsGetTime() - lastTribSentTime) > 120000) && (kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive) > 1) )
       {
          sendChatToAllies("Primary Army Unit: "+namePrimary+"");
          lastTribSentTime = xsGetTime();
       }
    }
    /////////////////////////////////////////////////////////
}

rule attackMonitor
inactive
group tcComplete
minInterval 1
{  
   int reserveAvail = aiPlanGetNumberUnits(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary) + aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
   bool homeBaseUnderAttack = false;
   if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
      homeBaseUnderAttack = true;

   if ( (homeBaseUnderAttack == true) ||(aiTreatyActive() == true) || (agingUp() == true)) // || ((xsGetTime() > 15*60*1000) && (kbGetAge() < cAge3)) || ((xsGetTime() > 20*60*1000) && (kbGetAge() < cAge4)) || ((xsGetTime() > 25*60*1000) && (kbGetAge() < cAge5)))
   // ( (homeBaseUnderAttack == true) || (aiTreatyActive() == true)) // || (reserveAvail < (gGoodArmyPop/2.5)) )
   {
      aiEcho("Sorry, not enough units.");
      return;
   }  

    static int enemyPointQuery = -1;  

    int i = 0;
    int targetID = -1;
    int targetPlayerID = -1;
    int targetBaseID = -1;
    vector targetLocation = cInvalidVector;
    vector targetBaseLocation = cInvalidVector; 
    int militaryCount = kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive)-kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive)-kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive);
    float militaryEquivalence = militaryCount;

    ////////////////military stance setting//////////////
    static int stancePlan = -1;
    if (stancePlan < 0)
    {
       stancePlan = aiPlanCreate("stancePlan", cPlanAttack);      
       aiPlanAddUnitType(stancePlan, cUnitTypeLogicalTypeLandMilitary, 0, 5, 10);
       aiPlanAddUnitType(stancePlan, cUnitTypexpMedicineManAztec, 0, 0, 0);
					
       aiPlanSetUnitStance(stancePlan, cUnitStanceAggressive);
       //aiPlanSetUnitStance(stancePlan, cUnitStanceDefensive);

       aiPlanSetDesiredPriority(stancePlan, 90);
       aiPlanSetVariableInt(stancePlan, cAttackPlanRefreshFrequency, 0, 1);
       aiPlanSetActive(stancePlan);
    }
    else
    {       
       aiPlanAddUnitType(stancePlan, cUnitTypeLogicalTypeLandMilitary, 0, 5, 10);
       aiPlanAddUnitType(stancePlan, cUnitTypexpMedicineManAztec, 0, 0, 0);
       aiPlanSetActive(stancePlan);
    }  
    ////////////////military stance setting//////////////
    
    ///////////find a high score enemy as 'mosthatedplayer'.
    static int lostPlayerEnemy = 0;
    static int lostPlayerAlly = 0;
    static int lastUpdateTime = 0;
    if (getEnemyCount()-lostPlayerEnemy > 1)
    {
       int totalScoreEnemy = 0;
       int averageScoreEnemy = 0;
       int totalScoreAlly = 0;
       int averageScoreAlly = 0;
       int militaryBaseAttackAlly = 0;
       int jointAttackTarget = -1;
       int player = 0;
       if (xsGetTime() - lastUpdateTime > .25*60*1000)  //every 3 minutes.
       {
	  lastUpdateTime = xsGetTime();
	  for (player=1; < cNumberPlayers)
	  {
	     if (kbIsPlayerEnemy(player) == true)
	     {
		if (kbHasPlayerLost(player) == false)
		  totalScoreEnemy = totalScoreEnemy + aiGetScore(player);
		else
		  lostPlayerEnemy = lostPlayerEnemy + 1;                   
	     }
	     else
	     {
		if (kbHasPlayerLost(player) == false)
		  totalScoreAlly = totalScoreAlly + aiGetScore(player);
		else
		  lostPlayerAlly = lostPlayerAlly + 1; 
				}
	     }
		averageScoreEnemy = totalScoreEnemy / (getEnemyCount()-lostPlayerEnemy);
		averageScoreAlly = totalScoreAlly / (getAllyCount()+1-lostPlayerAlly);
		for (player=1; < cNumberPlayers)
		{
		   if ((kbIsPlayerEnemy(player) == true)&&(kbHasPlayerLost(player) == false))
		   {
		      militaryBaseAttackAlly = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive, kbBaseGetLocation(player, kbBaseGetMainID(player)), 80.0);
		      if (militaryBaseAttackAlly > 30)
		      {
			 jointAttackTarget = player; 
		      }		   
		      if (aiGetScore(player) > averageScoreEnemy*1.1)
		      {
			 cvPlayerToAttack = player;
			 kbUnitPickSetEnemyPlayerID(gLandUnitPicker, player);
			 break;
		      }
		      else
		      {
			 cvPlayerToAttack = -1;
		      }
		   }
	        }
	     }
	}
    ///////////find a high score enemy as 'mosthatedplayer'

    /////////////////////base attack//////////////////////
    if ((cvPlayerToAttack >= 0)&&(kbHasPlayerLost(cvPlayerToAttack) == false))
      targetPlayerID = cvPlayerToAttack;
    else
      targetPlayerID = aiGetMostHatedPlayerID();

    targetBaseLocation = kbBaseGetLocation(targetPlayerID, kbBaseGetMainID(targetPlayerID));
    targetLocation = targetBaseLocation;
    static int lastBaseAttackTime = 0;
    bool baseAttackIsOK = false;
	
    /*if (kbGetAge() >= cAge5) 
    {
	 baseAttackIsOK = true;
    }
    else if (militaryEquivalence >= gGoodArmyPop)
	{
	 baseAttackIsOK = true;
    }
	else*/
	if (kbGetAge() == cAge2) // && (gInitialStrategy == 1) && (getEnemyCount() <= 2))
    {
       if ((xsGetTime() < 900000) && (kbGetAgeForPlayer(targetPlayerID) >= cAge1) && (militaryEquivalence*10000 > xsGetTime()))
	 baseAttackIsOK = true;
    }
    else if (jointAttackTarget >= 0)
    {
       baseAttackIsOK = true;
         targetBaseLocation = kbBaseGetLocation(jointAttackTarget, kbBaseGetMainID(jointAttackTarget));
    }
    else if ((militaryEquivalence * 8500 > xsGetTime())&&(xsGetTime() <= 1200000))
       baseAttackIsOK = true;
    else if ((militaryEquivalence > (2*gGoodArmyPop-10*kbGetAge()))&&(aiGetScore(cMyID) > 1.2 * aiGetScore(targetPlayerID)) && (aiGetScore(cMyID) - aiGetScore(targetPlayerID) > 100))
       baseAttackIsOK = true;
    else if ((gMaxPop - kbGetPop() < 5) && (agingUp() == false) && (xsGetTime() - gAgeUpTime > 150000))
       baseAttackIsOK = true;
    else if ((aiGetScore(cMyID) > 1.5 * aiGetScore(targetPlayerID)) && (aiGetScore(cMyID) - aiGetScore(targetPlayerID) > 100) && (militaryEquivalence > gGoodArmyPop))
       baseAttackIsOK = true;
    else if ((kbGetAge() > cAge4)&&(xsGetTime()-lastBaseAttackTime > 180000)&&(gMaxPop - kbGetPop() < 5))
       baseAttackIsOK = true;
    else if ((averageScoreAlly > averageScoreEnemy*1.5)&&(totalScoreAlly > totalScoreEnemy*0.7)&&(gMaxPop - kbGetPop() < 5))
       baseAttackIsOK = true;
    else if ((averageScoreAlly > averageScoreEnemy*0.7)&&(totalScoreAlly > totalScoreEnemy*1.5)&&(gMaxPop - kbGetPop() < 5))
       baseAttackIsOK = true;
    else if ((averageScoreAlly > averageScoreEnemy*1.1)&&(totalScoreAlly > totalScoreEnemy*1.1)&&(gMaxPop - kbGetPop() < 5))
       baseAttackIsOK = true;
    else if (militaryEquivalence >= gGoodArmyPop * 1.0)
       baseAttackIsOK = true;

    int totalMilitary = kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive)-kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive)-kbUnitCount(cMyID, gSiegeWeaponUnit, cUnitStateAlive);
    if ((baseAttackIsOK == true) && (getUnitCountByLocation(cUnitTypeBuilding, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 50.0) >= 5))
    {		
       if (gBaseAttackPlan < 0)
       {
	  gBaseAttackPlan = aiPlanCreate("gBaseAttackPlan", cPlanAttack);
	  gBaseAttackLocation = targetBaseLocation;
	  aiPlanSetVariableInt(gBaseAttackPlan, cAttackPlanPlayerID, 0, targetPlayerID);
	  aiPlanSetNumberVariableValues(gBaseAttackPlan, cAttackPlanTargetTypeID, 2, true);
	  aiPlanSetVariableInt(gBaseAttackPlan, cAttackPlanTargetTypeID, 0, cUnitTypeLogicalTypeLandMilitary);
	  aiPlanSetVariableInt(gBaseAttackPlan, cAttackPlanTargetTypeID, 1, cUnitTypeAbstractVillager);
	  aiPlanSetVariableVector(gBaseAttackPlan, cAttackPlanGatherPoint, 0, gBaseAttackLocation);
	  aiPlanSetVariableFloat(gBaseAttackPlan, cAttackPlanGatherDistance, 0, 60.0);
	  aiPlanSetVariableInt(gBaseAttackPlan, cAttackPlanRefreshFrequency, 0, 1);
	  aiPlanSetDesiredPriority(gBaseAttackPlan, 90);
	  //aiPlanSetInitialPosition(gBaseAttackPlan, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
	  aiPlanAddUnitType(gBaseAttackPlan, cUnitTypeLogicalTypeLandMilitary, totalMilitary, totalMilitary, totalMilitary);
	  aiPlanAddUnitType(gBaseAttackPlan, cUnitTypexpMedicineManAztec, 0, 0, 0);
	  if (jointAttackTarget >= 0)
	    sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillAttackWithYou, gBaseAttackLocation);
	  else
	    sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillAttackEnemyTown, gBaseAttackLocation);
	  aiPlanSetActive(gBaseAttackPlan);
	  lastBaseAttackTime = xsGetTime();
       }
    }
    if (gBaseAttackPlan >= 0)
    {
       aiPlanAddUnitType(gBaseAttackPlan, cUnitTypeLogicalTypeLandMilitary, totalMilitary, totalMilitary, totalMilitary);
       aiPlanAddUnitType(gBaseAttackPlan, cUnitTypexpMedicineManAztec, 0, 0, 0);
       aiPlanSetActive(gBaseAttackPlan);
    }
    /////////////////////base attack///////////////////

    /////////////////////harass plan///////////////////
    enemyPointQuery = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeAbstractVillager, cUnitStateAlive);
    kbUnitQueryResetResults(enemyPointQuery);
    int enemyVillagerCount = kbUnitQueryExecute(enemyPointQuery);
    if (enemyVillagerCount > 0) 
    {
       targetID = kbUnitQueryGetResult(enemyPointQuery, aiRandInt(enemyVillagerCount));
       targetPlayerID = kbUnitGetPlayerID(targetID);
       targetLocation = kbUnitGetPosition(targetID);
       targetBaseLocation = kbBaseGetLocation(targetPlayerID, kbBaseGetMainID(targetPlayerID));
       static vector lastHarassLocation = cInvalidVector;
       if ( (distance(targetLocation, targetBaseLocation) > 80.0) && (distance(targetLocation, lastHarassLocation) > 20.0) )
       {
	  if ( (getUnitCountByLocation(cUnitTypeFortFrontier, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 60.0) < 1)&&
	       (getUnitCountByLocation(cUnitTypeMilitaryBuilding, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 40.0) < 1)&&
	       (getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 30.0) < 1)&&
	       (kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) == kbAreaGroupGetIDByPosition(targetLocation)) && 							
	       (militaryEquivalence >= 5))
	  {
	     int harassPlan = aiPlanCreate("harassPlan", cPlanAttack);
	     aiPlanSetVariableInt(harassPlan, cAttackPlanPlayerID, 0, targetPlayerID);
	     aiPlanSetNumberVariableValues(harassPlan, cAttackPlanTargetTypeID, 2, true);
	     aiPlanSetVariableInt(harassPlan, cAttackPlanTargetTypeID, 0, cUnitTypeLogicalTypeLandMilitary);
	     aiPlanSetVariableInt(harassPlan, cAttackPlanTargetTypeID, 1, cUnitTypeAbstractVillager);             
	     aiPlanSetVariableVector(harassPlan, cAttackPlanGatherPoint, 0, targetLocation);
             aiPlanSetUnitStance(harassPlan, cUnitStanceAggressive);
	     aiPlanSetVariableFloat(harassPlan, cAttackPlanGatherDistance, 0, 60.0);
	     aiPlanSetVariableInt(harassPlan, cAttackPlanRefreshFrequency, 0, 1);
	     aiPlanSetDesiredPriority(harassPlan, 90);
	     //aiPlanSetInitialPosition(harassPlan, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));             
	     if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) > 2)
		aiPlanAddUnitType(harassPlan, cUnitTypeAbstractCavalry, 0, 3, 5);
             else if (kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) > 2)
                aiPlanAddUnitType(harassPlan, cUnitTypexpCoyoteMan, 0, 3, 5);     
	     else
		aiPlanAddUnitType(harassPlan, cUnitTypeAbstractCavalryInfantry, 3, 5, 10);
	     sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillAttackEnemySettlers, targetLocation);
	     aiPlanSetActive(harassPlan);
	     lastHarassLocation = targetLocation;
	  }
       }
    } ////////////////////harass plan////////////////////

    /////////////////////offlying building attack plan///////////////////
	int randomizer = aiRandInt(10);
	if (randomizer < 4)
	   enemyPointQuery = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeypShrineJapanese, cUnitStateAlive);
	else if (randomizer < 8)
	   enemyPointQuery = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeTradingPost, cUnitStateAlive);
	else
	   enemyPointQuery = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeMilitaryBuilding, cUnitStateAlive);
	kbUnitQueryResetResults(enemyPointQuery);
	int enemyBuildingCount = kbUnitQueryExecute(enemyPointQuery);
	if (enemyBuildingCount> 0)
	{
		targetID = kbUnitQueryGetResult(enemyPointQuery, aiRandInt(enemyBuildingCount));
		targetPlayerID = kbUnitGetPlayerID(targetID);
		targetLocation = kbUnitGetPosition(targetID);
		targetBaseLocation = kbBaseGetLocation(targetPlayerID, kbBaseGetMainID(targetPlayerID));
		static vector lastOffLyingLocation = cInvalidVector;  
		if ((kbUnitIsType(targetID, cUnitTypeWallConnector) == false) &&
			(kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) == kbAreaGroupGetIDByPosition(targetLocation)) && 		 
			(distance(targetLocation, targetBaseLocation) > 120.0) && 
			(distance(targetLocation, lastOffLyingLocation) > 30.0))
		{
			int numOutpost = getUnitCountByLocation(cUnitTypeOutpost, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 40.0);
			int numCastle = getUnitCountByLocation(cUnitTypeOutpost, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 40.0);
			int numBlockHouse = getUnitCountByLocation(cUnitTypeBlockhouse, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 40.0);
			int numWarHut = getUnitCountByLocation(cUnitTypeWarHut, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 40.0);
			int numNoblesHut = getUnitCountByLocation(cUnitTypeNoblesHut, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 40.0);
			int numTaskUnit = 6*numOutpost + 10*numCastle + 8*numBlockHouse + 8*numWarHut + 10*numNoblesHut;
			if  ((getUnitCountByLocation(cUnitTypeFortFrontier, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 50.0) <= 0)&&
				(getUnitCountByLocation(cUnitTypeAbstractAgraFort, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 50.0) <= 0)&&
				(getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 30.0) <= 0)&&
				(militaryEquivalence >= 15)&& (kbUnitCount(cMyID, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive) >= numTaskUnit)&&(gDefenseReflexBaseID != kbBaseGetMainID(cMyID)))
			{
				int offlyingAttack = aiPlanCreate("offlyingAttack", cPlanAttack);
				aiPlanSetVariableInt(offlyingAttack, cAttackPlanPlayerID, 0, targetPlayerID);
				aiPlanSetNumberVariableValues(offlyingAttack, cAttackPlanTargetTypeID, 3, true);
				aiPlanSetVariableInt(offlyingAttack, cAttackPlanTargetTypeID, 0, cUnitTypeLogicalTypeLandMilitary);
				aiPlanSetVariableInt(offlyingAttack, cAttackPlanTargetTypeID, 1, cUnitTypeAbstractVillager);
				//aiPlanSetVariableInt(offlyingAttack, cAttackPlanTargetTypeID, 2, cUnitTypeBuilding);
				aiPlanSetVariableVector(offlyingAttack, cAttackPlanGatherPoint, 0, targetLocation);
				aiPlanSetVariableFloat(offlyingAttack, cAttackPlanGatherDistance, 0, 60.0);
				aiPlanSetVariableInt(offlyingAttack, cAttackPlanRefreshFrequency, 0, 1);
				aiPlanSetDesiredPriority(offlyingAttack, 95);
				//aiPlanSetInitialPosition(offlyingAttack, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
				aiPlanAddUnitType(offlyingAttack, cUnitTypeAbstractHeavyInfantry, 3+numTaskUnit, 5+numTaskUnit, 10+numTaskUnit);	
				aiPlanSetActive(offlyingAttack);
				lastOffLyingLocation = targetLocation;
			}
		}
	}
    /////////////////////offlying building attack plan///////////////////
    
    /////////////////////helpout plan///////////////////
    static int startTime = -1;       // Time last plan was started, to make sure we're not waiting on an obsolete plan.    
    if (getAllyCount()-lostPlayerAlly >= 1)
    {
	vector allyBaseLocation = cInvalidVector;
	vector allyFortLocation = cInvalidVector;
	vector selfBaseLocation = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
	float distanceBetween = 0.0; 
	float helpRange = 0.0;
	int numEnemyMilitary = 0;
	int numAllyMilitary = 0;
	int numSelfMilitary = 0;
	int numMilitaryToSend = 0;
	bool allyIsInTrouble = false;
	int helpOutPlan = -1;
	player = 0;
	for (player=1; < cNumberPlayers)
	{           
	   if (kbIsPlayerAlly(player) == true)
	   {
	      allyBaseLocation = kbBaseGetLocation(player, kbBaseGetMainID(player));
	      targetLocation = allyBaseLocation;
	      distanceBetween = distance(selfBaseLocation, targetLocation);
	      numEnemyMilitary = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 100.0);
	      numAllyMilitary = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive, targetLocation, distanceBetween)-getUnitCountByLocation(cUnitTypexpMedicineManAztec, cPlayerRelationAlly, cUnitStateAlive, targetLocation, distanceBetween);
	      numSelfMilitary = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cMyID, cUnitStateAlive, targetLocation, distanceBetween)-kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive);
	      if ((numEnemyMilitary > 1.2 * numAllyMilitary) && (numEnemyMilitary - numAllyMilitary > 5))
	      {
		 allyIsInTrouble = true;                 
		 helpRange = 20.0;
	      }
	      if ((allyIsInTrouble == true)&&(numSelfMilitary >= 3))
	      {	
		 numMilitaryToSend = 1.2 * (numEnemyMilitary - numAllyMilitary);
		 if (numMilitaryToSend < 3 )
		   numMilitaryToSend = 0;
		 if (numMilitaryToSend > numSelfMilitary )
		   numMilitaryToSend = numSelfMilitary;
		 helpOutPlan = aiPlanCreate("helpOutPlan", cPlanAttack);
		 aiPlanSetVariableInt(helpOutPlan, cAttackPlanPlayerID, 0, -1);
		 aiPlanSetNumberVariableValues(helpOutPlan, cAttackPlanTargetTypeID, 2, true);
		 aiPlanSetVariableInt(helpOutPlan, cAttackPlanTargetTypeID, 0, cUnitTypeLogicalTypeLandMilitary);
		 aiPlanSetVariableInt(helpOutPlan, cAttackPlanTargetTypeID, 1, cUnitTypeUnit);
		 aiPlanSetVariableVector(helpOutPlan, cAttackPlanGatherPoint, 0, targetLocation);
		 aiPlanSetVariableFloat(helpOutPlan, cAttackPlanGatherDistance, 0, helpRange);
		 aiPlanSetVariableInt(helpOutPlan, cAttackPlanRefreshFrequency, 0, 1);
		 aiPlanSetDesiredPriority(helpOutPlan, 99);
		 aiPlanSetInitialPosition(helpOutPlan, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
                 aiPlanSetUnitStance(helpOutPlan, cUnitStanceAggressive);
		 aiPlanAddUnitType(helpOutPlan, cUnitTypeLogicalTypeLandMilitary, numMilitaryToSend, numMilitaryToSend, numMilitaryToSend);	
		 sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillHelpDefend, targetLocation);
		 aiPlanSetActive(helpOutPlan);
                 startTime = xsGetTime();
	      }
              if (((helpOutPlan >= 0) && (aiPlanGetActive(helpOutPlan) == false)) ||
                  ((helpOutPlan >= 0) && (aiPlanGetState(helpOutPlan) < 0)) ||
                  (kbBaseGetUnderAttack(cMyID, kbBaseGetMainID(cMyID)) == true) ||
                  ((startTime > 0) && (xsGetTime() > (startTime + 120000))) )
              {
                  aiPlanDestroy(helpOutPlan);
                  helpOutPlan = -1;
                  startTime = -1;
              }
	   }
	}
     }
     /////////////////////helpout plan///////////////////////
     
     //////////////counter forward rush/////////////////
     bool enemyForwardRush = false;
	if (xsGetTime() < 360000)
	{ 
	    enemyPointQuery = createSimpleQuery(cPlayerRelationEnemyNotGaia, cUnitTypeMilitaryBuilding, cUnitStateAlive);
		kbUnitQueryResetResults(enemyPointQuery);
		int enemyMilitaryBuildingCount = kbUnitQueryExecute(enemyPointQuery);
		vector enemyForwardPlace = cInvalidVector; 
		for (i=0; <enemyMilitaryBuildingCount)
		{
			targetID = kbUnitQueryGetResult(enemyPointQuery, i);
			targetPlayerID = kbUnitGetPlayerID(targetID);
			targetLocation = kbUnitGetPosition(targetID);
			if ((kbUnitIsType(targetID, cUnitTypeWallConnector) == false)&&
				(distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), targetLocation) < 200.0)&&
				(distance(kbBaseGetLocation(targetPlayerID, kbBaseGetMainID(targetPlayerID)), targetLocation) > 100.0))	
			{
				enemyForwardRush = true;
				break;
			}
		}
	}
	if ((enemyForwardRush == true)&&(xsGetTime() < 900000))
	{
        if (getUnitCountByLocation(cUnitTypeMilitaryBuilding, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 50) > 0)
		{
			btRushBoom = 1.0;
			gInitialStrategy = 1;	
			btOffenseDefense = btOffenseDefense - 1.0;
			if (btOffenseDefense < -1)
			   btOffenseDefense = -1;	
			xsEnableRule("turtleUp");
			aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary , totalMilitary, totalMilitary, totalMilitary);
			aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, 30); 
			aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, 60.0);
			aiPlanSetDesiredPriority(gLandDefendPlan0, 90); 
			aiPlanSetActive(gLandDefendPlan0);
			if (((militaryEquivalence * 9000 > xsGetTime())&&(xsGetTime() <= 1200000))||
				((aiGetScore(cMyID) > 1.5 * aiGetScore(targetPlayerID)) && (aiGetScore(cMyID) - aiGetScore(targetPlayerID) > 100) && (militaryEquivalence > 50))||
				((gMaxPop - kbGetPop() < 5) && (agingUp() == false) && (xsGetTime() - gAgeUpTime > 150000)))
			{
				aiPlanAddUnitType(offlyingAttack, cUnitTypeLogicalTypeLandMilitary, totalMilitary, totalMilitary, totalMilitary);	
				aiPlanSetVariableVector(offlyingAttack, cAttackPlanGatherPoint, 0, targetLocation);
				aiPlanSetVariableFloat(offlyingAttack, cAttackPlanGatherDistance, 0, 60.0);
				aiPlanSetInitialPosition(offlyingAttack, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
				sendStatement(cPlayerRelationAlly, cAICommPromptToAllyConfirm, targetLocation);
				aiPlanSetActive(offlyingAttack);
			}
		}
		if (getUnitCountByLocation(cUnitTypeMilitaryBuilding, cPlayerRelationEnemyNotGaia, cUnitStateAlive, targetLocation, 50) < 1)
		{
			aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary , 0, 0, 1);
			aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);  
			aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusActive - 10.0);
			aiPlanSetDesiredPriority(gLandDefendPlan0, 10); 
			aiPlanSetActive(gLandDefendPlan0);
		 }
    }
    ////////////////counter forward rush/////////////////

   //Sioux war chief to attack artillery.
 	if ((kbGetCiv() == cCivXPSioux)&&(kbGetAge() >= cAge3)&&(kbTechGetStatus(cTechBigFirepitBattleAnger) == cTechStatusActive))
	{
		if (aiGetFallenExplorerID() < 0)
		{
			vector chiefLoaction = kbUnitGetPosition(getUnit(gExplorerUnit));
			targetID = getUnitByLocation(cUnitTypeAbstractArtillery, cPlayerRelationEnemyNotGaia, cUnitStateAlive, chiefLoaction, 200.0);
			targetPlayerID = kbUnitGetPlayerID(targetID);
			targetLocation = kbUnitGetPosition(targetID);
			if (targetID >= 0)
			{
				int artilleryAttackPlan = aiPlanCreate("artilleryAttackPlan", cPlanAttack);
				//aiPlanSetVariableInt(artilleryAttackPlan, cAttackPlanPlayerID, 0, targetPlayerID);
				aiPlanSetNumberVariableValues(artilleryAttackPlan, cAttackPlanTargetTypeID, 1, true);
				aiPlanSetVariableInt(artilleryAttackPlan, cAttackPlanTargetTypeID, 0, cUnitTypeAbstractArtillery);
				aiPlanSetVariableVector(artilleryAttackPlan, cAttackPlanGatherPoint, 0, targetLocation);
				aiPlanSetVariableFloat(artilleryAttackPlan, cAttackPlanGatherDistance, 0, 5.0);
				aiPlanSetVariableInt(artilleryAttackPlan, cAttackPlanRefreshFrequency, 0, 1);
				aiPlanSetDesiredPriority(artilleryAttackPlan, 99);
				aiPlanSetInitialPosition(artilleryAttackPlan, chiefLoaction);
				aiPlanAddUnitType(artilleryAttackPlan, gExplorerUnit, 1, 1, 1);
				aiPlanSetActive(artilleryAttackPlan);
			}
		}
	}
}



/*
//==============================================================================
// RULE: buildFortress (when resources allow)
//==============================================================================*/
rule buildFortress
inactive
minInterval 30
{
   //if ((kbGetAge() < cAge4) || (kbGetCiv() != cCivRussians) )
   //   return;
  
   float currentWood = kbResourceGet(cResourceWood);
   float currentGold = kbResourceGet(cResourceGold);
    
   int numFortresses = kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive);
   if (numFortresses >= kbGetBuildLimit(cMyID, cUnitTypeFortFrontier))
     return;
   
   //If we're going to build fort, do it
   if ((kbGetCiv() == cCivRussians) && (currentWood > 1000) && (currentGold > 1000)) // && (kbTechGetStatus(HCXPNationalRedoubt) == cTechStatusActive))
   {      
      //forwardBaseCallback();

      //-- reserve some building space in the base for the fort.
      int fortBPID = kbBuildingPlacementCreate( "FortBP" );
      if (fortBPID != -1)
      {
         kbBuildingPlacementSetBuildingType(cUnitTypeFortFrontier);
         kbBuildingPlacementSetBaseID(kbBaseGetMainID(cMyID), cBuildingPlacementPreferenceBack);
         kbBuildingPlacementStart();
      }
      //createBuildBuildingGoal("Fort Goal", cUnitTypeFortFrontier, -1, 4, 5, gForwBaseID, 30, cUnitTypeMusketeer, true, 100, fortBPID);
   }
}  
/*rule buildFortress
inactive
minInterval 25
{
   if (kbGetAge() < cAge3)
       return;
  
   float currentWood = kbResourceGet(cResourceWood);
   float currentGold = kbResourceGet(cResourceGold);
    
   int numFortresses = kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive);
   if (numFortresses >= kbGetBuildLimit(cMyID, cUnitTypeFortFrontier))
     return;
   
   //If we're going to build fort, do it
   if ( (kbGetCiv() == civIsEuropean) && (currentWood > 1000) && (currentGold > 600) )
   {      
      forwardBaseCallback();

      //-- reserve some building space in the base for the fort.
      int fortBPID = kbBuildingPlacementCreate( "FortBP" );
      if (fortBPID != -1)
      {
         kbBuildingPlacementSetBuildingType(cUnitTypeFortFrontier);
         kbBuildingPlacementSetBaseID(kbBaseGetMainID(cMyID), cBuildingPlacementPreferenceBack);
         kbBuildingPlacementStart();
      }
      createBuildBuildingGoal("Fort Goal", cUnitTypeFortFrontier, -1, 4, 5, gForwBaseID, 30, cUnitTypeSettler, true, 100, fortBPID);
      createBuildBuildingGoal("Fort Goal", cUnitTypeFortFrontier, -1, 4, 5, gForwBaseID, 30, cUnitTypeMusketeer, true, 100, fortBPID);
   }
   if ( (kbGetCiv() == civIsEuropean) && (currentWood > 2000) && (currentGold > 1200) )
   {      

      //-- reserve some building space in the base for the fort.
      int FactoryBPID = kbBuildingPlacementCreate( "FactorytBP" );
      if (FactoryBPID != -1)
      {
         kbBuildingPlacementSetBuildingType(cUnitTypeFactory);
         kbBuildingPlacementSetBaseID(kbBaseGetMainID(cMyID), cBuildingPlacementPreferenceBack);
         kbBuildingPlacementStart();
      }
   
      planID = createSimpleBuildPlan(cUnitTypeFactory, 1, 80, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0); //No settler builders
      aiPlanAddUnitType(planID, cUnitTypeAbstractVillager, 1, 1, 1);
     }
   
}  
*/